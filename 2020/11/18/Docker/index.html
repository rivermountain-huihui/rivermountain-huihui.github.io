<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="容器管理 DockerBuild,Ship and Run Any App,Anywhere重点：  容器镜像制作和管理，超级重点！！！ 镜像仓库管理，超级重点！！！ docker基本操作 数据卷管理 网络管理 容器编排管理工具 docker compose 容器资源限制 可视化容器管理工具Portainer  1 Docker介绍和基础操作1.1 Docker 介绍1.1.1 容器介绍Docke">
<meta property="og:type" content="article">
<meta property="og:title" content="辉辉的数据库">
<meta property="og:url" content="http://example.com/2020/11/18/Docker/index.html">
<meta property="og:site_name" content="辉辉的数据库">
<meta property="og:description" content="容器管理 DockerBuild,Ship and Run Any App,Anywhere重点：  容器镜像制作和管理，超级重点！！！ 镜像仓库管理，超级重点！！！ docker基本操作 数据卷管理 网络管理 容器编排管理工具 docker compose 容器资源限制 可视化容器管理工具Portainer  1 Docker介绍和基础操作1.1 Docker 介绍1.1.1 容器介绍Docke">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201112211529434.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201113202046662.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201113202145345.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201113103103493.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201114154956782.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201114155433028.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201114163854325.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201114163906945.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201113150551644.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201118110004990.png">
<meta property="og:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201118114909203.png">
<meta property="article:published_time" content="2020-11-18T13:35:42.923Z">
<meta property="article:modified_time" content="2020-11-18T13:06:28.876Z">
<meta property="article:author" content="huihui">
<meta property="article:tag" content="notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/a/AppData/Roaming/Typora/typora-user-images/image-20201112211529434.png">

<link rel="canonical" href="http://example.com/2020/11/18/Docker/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | 辉辉的数据库</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">辉辉的数据库</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我们要丈量大地！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/18/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huihui">
      <meta itemprop="description" content="学习和看笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉辉的数据库">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-18 21:35:42 / Modified: 21:06:28" itemprop="dateCreated datePublished" datetime="2020-11-18T21:35:42+08:00">2020-11-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="容器管理-Docker"><a href="#容器管理-Docker" class="headerlink" title="容器管理 Docker"></a>容器管理 Docker</h1><h2 id="Build-Ship-and-Run-Any-App-Anywhere"><a href="#Build-Ship-and-Run-Any-App-Anywhere" class="headerlink" title="Build,Ship and Run Any App,Anywhere"></a>Build,Ship and Run Any App,Anywhere</h2><p>重点：</p>
<ul>
<li>容器镜像制作和管理，超级重点！！！</li>
<li>镜像仓库管理，超级重点！！！</li>
<li>docker基本操作</li>
<li>数据卷管理</li>
<li>网络管理</li>
<li>容器编排管理工具 docker compose</li>
<li>容器资源限制</li>
<li>可视化容器管理工具Portainer</li>
</ul>
<h1 id="1-Docker介绍和基础操作"><a href="#1-Docker介绍和基础操作" class="headerlink" title="1 Docker介绍和基础操作"></a>1 Docker介绍和基础操作</h1><h2 id="1-1-Docker-介绍"><a href="#1-1-Docker-介绍" class="headerlink" title="1.1 Docker 介绍"></a>1.1 Docker 介绍</h2><h3 id="1-1-1-容器介绍"><a href="#1-1-1-容器介绍" class="headerlink" title="1.1.1 容器介绍"></a>1.1.1 容器介绍</h3><p>Docker是一个可以将应用程序及其依赖打包到几乎可以在任何服务器上运行的容器的工具</p>
<p>KVM中每个虚拟机有自己的内核，而所有容器使用内核</p>
<p>容器：共用一个内核，同时可以在容器之间保持较好的隔离性</p>
<p>每个容器间是互相隔离的，每个容器内都有一个属于自己的独立的文件系统、独立的进程、独立的用户和用户组、独立的网络空间等，这是容器之间彼此不相互影响的原因</p>
<p>Docker、虚拟机、物理主机的关系</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201112211529434.png" alt="image-20201112211529434"></p>
<p>相比虚拟机，容器的好处是：</p>
<ul>
<li>资源利用率高，因为减少了每个个体中内核的资源消耗。一台物理机能开十几个虚拟机的话，跑容器能跑上百个</li>
<li>启动速度快，可以在几秒内完成</li>
<li>占用空间小，一般以MB计算，而虚拟机得以GB计算大小</li>
<li>集成性好，和CI/CD（持续集成/持续部署）相关技术结合性好，实现打包镜像发布测试一键运行</li>
</ul>
<h3 id="1-1-2-容器组成"><a href="#1-1-2-容器组成" class="headerlink" title="1.1.2 容器组成"></a>1.1.2 容器组成</h3><ul>
<li>docker主机，物理机或虚拟机，一般称为宿主机</li>
<li>docker服务端，Docker守护进程，运行docker容器</li>
<li>docker客户端，使用docker命令和其他工具调用dockerAPI</li>
<li>docker镜像，实例的模板，本质上是一些文件的集合</li>
<li>docker仓库，保存镜像的仓库，有官方仓库，也可以建立私有仓库</li>
<li>docker容器，容器就是对镜像进行复制，然后运行里面的程序后生成的进程</li>
</ul>
<p>namespace：实现隔离的技术</p>
<p>namespace在内核层实现；一些不同类型的命名空间被部署在内核内，各个Docker容器运行在同一个Docker主进程并且共用一个宿主机系统内核；</p>
<p>MNT Namespace：Mount</p>
<p>让每个容器都有自己的根目录</p>
<p>宿主机使用chroot技术把容器锁定到一个制定的运行目录里面，容器在这个目录里面有自己的根目录，但是不能访问宿主机的目录</p>
<p>IPC Namespace：Inter-Process Communication</p>
<p>让每个容器内的进程之间可以通信</p>
<p>UTS Namespace：UNIX Timesharing System</p>
<p>UTS namespace包含了运行内核的名称、版本、底层体系结构类型等信息，用于系统标识，其中包括了主机名hostname和域名domainname，它让每个容器有自己的主机标识，包括主机名和域名</p>
<p>PID Namespace：Process Identification</p>
<p>Linux系统中，有一个PID为1的进程(init/systemd)是其他所有进程的父进程，那么在每个容器内也要有一个父进程来管理其下属的子进程，那么多个容器的进程通过PID namespace进程隔离。比如PID编号重复、容器内的主进程生成与回收子进程等。让每个容器内都有自己的进程、子进程</p>
<p>NET Namespace：Network             </p>
<p>问题：docker0就一个吗？是的 </p>
<p>是不是所有容器桥接到docker0？是的</p>
<p>Docker使用network namespace启动一个vethX接口，这样容器将拥有自己的桥接IP地址，通常是docker0，而docker0实质就是Linux的虚拟网桥，网桥在OSI七层模型的数据链路层的网络设备，通过MAC地址对网络进行划分，并且在不同网络直接传递数据</p>
<p>每个容器有自己的网卡、监听端口、TCP/IP协议栈</p>
<p>User Namespace：User</p>
<p>User Namespace运行在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户UID和GID，只是会把用户的作用范围限制在每个容器内。</p>
<p>让每个容器内有自己的用户和用户组</p>
<p>对内核要求高，因此使用Ubuntu更多了，Ubuntu内核版本高</p>
<table>
<thead>
<tr>
<th>隔离类型</th>
<th>功能</th>
<th>系统调用参数</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>MNT Namespace</td>
<td>提供磁盘挂载点和文件系统的隔离能力</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>提供进程间通信的隔离能力，包括信号量，消息队列和共享内存</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>提供内核，主机名和域名隔离能力</td>
<td>CLONE_NEWTUS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>提供进程隔离能力</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Net Namespace</td>
<td>提供网络隔离能力，包括网络设备，网络栈，端口等</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>提供用户隔离能力，包括用户和组</td>
<td>CLONE_NEWUSER</td>
<td>3.8</td>
</tr>
</tbody></table>
<p><strong>进程：</strong></p>
<p>每当运行一个容器，体现在宿主机上就是containerd进程又开启了一个containerd-shim子进程和一些线程</p>
<p>容器内的进程体现在宿主机上就是containerd进程的子进程containerd-shim的一个线程</p>
<p>容器内进程号和宿主机是相互独立的</p>
<p>每当运行一个需要进行主机间网络通信的容器（提供服务，需要开端口的容器），那么体现在宿主机上就是containerd又开启一个containerd-shim子进程，并且，docker守护进程dockerd也开启了一个子进程docker-proxy和一些线程</p>
<p><strong>文件系统：</strong></p>
<p>镜像文件本身存放在宿主机上</p>
<p>运行容器实际上就是从镜像文件拷贝一份，然后运行这些文件中的程序</p>
<p>容器内有自己的文件系统，与宿主机相对独立，比如容器有自己的根目录</p>
<p>但是容器内的文件本质上还是存储在宿主机上，文件一般在<code>/var/lib/docker/overlay2/</code>下，需要根据容器ID号去寻找对应的文件夹</p>
<p><strong>网络：</strong></p>
<p>docker的网络是这样的：</p>
<p>开启dockerd（docker守护进程）后，宿主机会多一个网卡，docker0，这个网卡一般的网段是<code>172.17.0.0/16</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:f3:33:fc:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1&#x2F;16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:f3ff:fe33:fc01&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>这是一个提供给容器的桥接网卡</p>
<p>每当运行一个容器，宿主机上就会看到多了一个网卡，这个网卡代表容器的网卡，它桥接与docker0网卡上，然后通过docker0网卡与宿主机通信</p>
<p>docker0网卡与宿主机之间还有宿主机的防火墙（内核Netfilter模块提供的五个钩子函数），通过防火墙上配置NAT表的SNAT规则，可以实现让容器处于NAT网络下对外界网络主机进行访问；通过设置DNAT规则（容器和宿主机之间的端口映射）实现让外界网络主机访问容器服务的功能</p>
<p>docker0网桥的观察，此时运行着两个容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242f333fc01       no              veth224b0e8</span><br><span class="line">                                                        veth64218fc</span><br><span class="line">root@ubuntu1804:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1&#x2F;128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 00:0c:29:4c:15:a7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.55&#x2F;24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe4c:15a7&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:f3:33:fc:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1&#x2F;16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:f3ff:fe33:fc01&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">11: veth64218fc@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link&#x2F;ether 7e:7a:14:d9:84:96 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::7c7a:14ff:fed9:8496&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">13: veth224b0e8@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link&#x2F;ether d6:59:58:b7:e6:1a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::d459:58ff:feb7:e61a&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>正好，两个容器，两个新增网卡，网桥上也看到两个桥接网卡</p>
<p>大概的连接图</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113202046662.png" alt="image-20201113202046662"></p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113202145345.png" alt="image-20201113202145345"></p>
<p>宿主机的nat表规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# iptables -t nat -vnL</span><br><span class="line">Chain PREROUTING (policy ACCEPT 41 packets, 8332 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">   30  1505 DOCKER     all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 41 packets, 8332 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 117 packets, 8872 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">    0     0 DOCKER     all  --  *      *       0.0.0.0&#x2F;0           !127.0.0.0&#x2F;8          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 136 packets, 9860 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">    0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0&#x2F;16        0.0.0.0&#x2F;0     </span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.2           172.17.0.2           tcp dpt:80</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.3           172.17.0.3           tcp dpt:4000</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0       </span><br><span class="line">    2   104 DNAT       tcp  --  !docker0 *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:32768 to:172.17.0.2:80</span><br><span class="line">   19   988 DNAT       tcp  --  !docker0 *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:4000 to:172.17.0.3:4000</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Control groups：</strong></p>
<p>对容器使用资源的限制，包括CPU、内存、磁盘、网络带宽等</p>
<p>Linux Control Groups，Linux内核功能</p>
<p>通过查看/boot/config-xxx文件来看</p>
<p><strong>容器管理技术</strong></p>
<p>LXC，Linux Container，最初使用，现在不怎么使用了</p>
<p>docker，增强版的LXC</p>
<p>pouch，阿里巴巴研究的容器技术</p>
<p>podman，centos8集成的功能，pod manager tool，与Kubernetes关系紧密</p>
<p><strong>docker与镜像</strong></p>
<p>docker的镜像是分层的，镜像底层为库文件，只能读，叫做只读层，镜像被运行为容器后，多了一个读写层，其写入的数据会复制到宿主机上对应容器的目录，但是容器被删除后目录也会被删除；</p>
<p>docker的启动需要一个外部模板，也称为镜像；</p>
<p>镜像可以被修改后再次保存成另外一个镜像；</p>
<p>一个镜像可以被启动为多个容器；</p>
<p><strong>docker的优点和不足</strong></p>
<p>优点：</p>
<p>一次打包，到处执行；</p>
<p>资源利用率高；</p>
<p>快速部署；</p>
<p>快速迁移；</p>
<p>高内聚、低耦合；</p>
<p>不足：</p>
<p>各个容器公用一个内核，隔离的不如虚拟机彻底；</p>
<p>进入容器、查看容器进程比较困难；</p>
<p>容器为了节省空间，很多工具都不装，但是如果要进入容器内进行操作还需要安装工具；</p>
<p><strong>容器的核心技术</strong></p>
<p>OCI：Open Container Initiative</p>
<p>容器规范：runtime spec和image format spec</p>
<p>遵守上面的两个规范就可以保证容器的可移植性和相互可操作性</p>
<p>runtime：runtime是真正运行容器的地方，docker容器技术的一个模块</p>
<p>runtime的类型有几个，但是目前docker使用的是runc</p>
<p><strong>容器管理工具</strong></p>
<p>管理runc的工具是docker engine，docker engine包括daemon和cli两部分，docker就是指docker engine</p>
<p><strong>容器定义工具</strong></p>
<p>docker image，docker容器的模板，runtime依据docker image创建容器</p>
<p>dockerfile，包含N个命令的文本文件，通过dockerfile创建出docker image</p>
<p>ACI，APP Container Image，与docker image类似</p>
<p><strong>镜像仓库 Registry</strong></p>
<p>docker hub，docker官方仓库</p>
<p>Harbor，VMware提供的自带web界面、自带认证功能的镜像私有仓库，有不少公司在用</p>
<p><strong>容器编排工具</strong></p>
<p>当多个容器在多个主机运行的时候，单独管理容器是相当复杂而且很容易出错，而且也无法实现某一台主机宕机后容器自动迁移到其他主机从而实现高可用的目的，而且也无法实现动态伸缩的功能，因此需要一种工具可以实现统一管理、动态伸缩、故障自愈、批量执行等功能，实现这种功能的工具就是容器编排工具</p>
<p>容器编排通常包括容器管理、调度、集群定义和服务发现等功能</p>
<p>有这么几种容器编排工具</p>
<ul>
<li>Docker compose，docker官方实现单机容器编排的工具</li>
<li>Docker swarm，docker官方开发的容器编排引擎</li>
<li>Kubernetes，Google开发的容器编排工具，事实上的标准</li>
</ul>
<p><strong>容器依赖的技术</strong></p>
<p>容器网络：</p>
<p>docker自带的网络docker network仅支持管理单机的容器网络，当多个主机运行时需要使用第三方开源网络，例如：calico、flannel等</p>
<p>服务发现：</p>
<p>容器的动态扩容特性决定了容器IP也会随之变化，因此需要有一种机制开源自动识别并将用户请求动态转发到新创建的容器上，kubernetes自带服务发现功能，需要结合kube-dns服务解析内部域名</p>
<p>容器监控：</p>
<p>可以通过原生的命令docker ps/top/stats查看容器运行状态，另外也可以使用Prometheus、heapster等监控工具</p>
<p>数据管理：</p>
<p>容器的动态迁移会导致其在不同的Host之间迁移，因此如何保证与容器相关的数据也能随之迁移或随时访问，可以使用逻辑卷/存储挂载等方式解决</p>
<p>日志收集：</p>
<p>docker原生的docker logs，但是容器内部的日志需要通过ELK等专门的日志收集分析和展示工具进行处理</p>
<p>docker是一种容器的管理工具</p>
<p>docker是使用GO语言开发</p>
<p>docker存储引擎：overlay</p>
<p>联合挂载文件系统：aufs</p>
<p>ABI：可执行应用程序接口，Application Binary Interface，也就是执行程序的统一接口</p>
<p>API：可编程应用程序接口，Application Program Interface，也即是编写程序的统一接口</p>
<h2 id="1-2-Docker安装及基础命令介绍"><a href="#1-2-Docker安装及基础命令介绍" class="headerlink" title="1.2 Docker安装及基础命令介绍"></a>1.2 Docker安装及基础命令介绍</h2><h3 id="1-2-1-安装docker"><a href="#1-2-1-安装docker" class="headerlink" title="1.2.1 安装docker"></a>1.2.1 安装docker</h3><p>基本上所有系统都要自己去网上找资源下载安装，docker版本要跟k8s配合</p>
<p>kubernetes的github</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://github.com/kubernetes/kubernetes/blob/v1.17.2/CHANGELOG-1.17.md</span></span><br></pre></td></tr></table></figure>

<p>docker的文档：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://docs.docker.com/</span></span><br></pre></td></tr></table></figure>

<p>docker的版本是一个季度更新一次，例如17.09表示2017年9月份发布</p>
<p>docker的github名字是moby</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://github.com/moby/moby</span></span><br></pre></td></tr></table></figure>

<p>docker两个包：docker-ce,docker-ce-cli，一个服务，一个客户端工具</p>
<p>docker command 就是客户端命令</p>
<p>可以通过网络资源下载或者二进制安装</p>
<p>阿里云的docker安装文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;developer.aliyun.com&#x2F;mirror&#x2F;docker-ce?spm&#x3D;a2c6h.13651102.0.0.3e221b11guHCWE</span><br></pre></td></tr></table></figure>



<p>Ubuntu</p>
<p>阿里云上在ubuntu上安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># step 2: 安装GPG证书</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><span class="line"><span class="comment"># Step 4: 更新并安装Docker-CE</span></span><br><span class="line">sudo apt-get -y update</span><br><span class="line"><span class="comment"># Step 5: 选择docker-ce的版本并安装</span></span><br><span class="line">apt list docker-ce -a</span><br><span class="line">apt install docker-ce=5:19.03.13~3-0~ubuntu-bionic</span><br></pre></td></tr></table></figure>

<p>docker删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt purge docker-ce</span><br><span class="line">rm -f &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>



<p>Centos</p>
<p>Centos6不建议安装docker</p>
<p>Centos7下载docker要从官方源或者镜像源站点下载安装</p>
<p>Centos8上有新技术podman代替docker，如果要安装docker，那么需要把阿里云centos8的docker连接写到/etc/yum.repos.d/下面</p>
<p>综合来看，docker更适合在Ubuntu上跑，centos系列的话，使用centos7来跑docker</p>
<p>centos7安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># Step 2: 添加软件源信息</span></span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># Step 3: 更新并安装Docker-CE</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"><span class="comment"># 如果要选择不同版本的软件，那么加上--showduplicates选项</span></span><br><span class="line">yum install docker-ce --showduplicates</span><br><span class="line"></span><br><span class="line">中间centos7需要额外安装一个软件</span><br><span class="line">wget http://mirror.centos.org/centos/7/extras/x86_64/Packages/container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm</span><br><span class="line">yum install container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: 开启Docker服务</span></span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

<p>centos8下载安装docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo</span><br><span class="line">  1 [docker]</span><br><span class="line">  2 name&#x3D;docker</span><br><span class="line">  3 baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;8&#x2F;x86_64&#x2F;stable&#x2F;</span><br><span class="line">  4 gpgcheck&#x3D;0</span><br><span class="line">  5 enable&#x3D;1</span><br><span class="line">dnf repolist</span><br><span class="line">dnf install docker-ce -y</span><br></pre></td></tr></table></figure>



<p>当上网下载不合适的时候，使用docker的二进制包进行安装，下面的二进制包的下载地址</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是官方提供的二进制安装文档，docker官方文档也有镜像，可以下载下来跑成容器，然后本地浏览文档</span><br><span class="line">docker run -it -d -p 4000:4000 docs/docker.github.io:latest</span><br><span class="line"></span><br><span class="line">官方文档</span><br><span class="line">https://docs.docker.com/engine/install/binaries/</span><br></pre></td></tr></table></figure>



<p>二进制安装的要求：</p>
<p>Before attempting to install Docker from binaries, be sure your host machine meets the prerequisites:</p>
<ul>
<li>A 64-bit installation</li>
<li>Version 3.10 or higher of the Linux kernel. The latest version of the kernel available for your platform is recommended.</li>
<li><code>iptables</code> version 1.4 or higher</li>
<li><code>git</code> version 1.7 or higher</li>
<li>A <code>ps</code> executable, usually provided by <code>procps</code> or a similar package.</li>
<li><a target="_blank" rel="noopener" href="http://tukaani.org/xz/">XZ Utils</a> 4.9 or higher</li>
<li>A <a target="_blank" rel="noopener" href="https://github.com/tianon/cgroupfs-mount/blob/master/cgroupfs-mount">properly mounted</a> <code>cgroupfs</code> hierarchy; a single, all-encompassing <code>cgroup</code> mount point is not sufficient. See Github issues <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/2683">#2683</a>, <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/3485">#3485</a>, <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/4568">#4568</a>).</li>
</ul>
<p>安装步骤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line">[root@centos8 src]<span class="variable">$wget</span> https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64/docker-19.03.13.tgz</span><br><span class="line"><span class="comment"># 解压，注意.tgz的包需要先gzip -d 解压，然后使用tar解包</span></span><br><span class="line">gzip -d docker-19.03.13.tgz</span><br><span class="line">tar xf docker-19.03.13.tar</span><br><span class="line"><span class="comment"># 把解压解包出来的docker文件夹下的可执行文件放到PATH变量中某一个目录下</span></span><br><span class="line">cp docker/* /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"><span class="comment"># 执行dockerd就可以开启docker守护进程了</span></span><br><span class="line">docker &amp;</span><br><span class="line"><span class="comment"># 关闭的时候杀只能杀进程关闭</span></span><br><span class="line"><span class="built_in">kill</span> `pidof dockerd`</span><br><span class="line"><span class="comment"># 编写service文件，注意一共有三个</span></span><br><span class="line">第一个，docker.service</span><br><span class="line">[root@centos8 system]<span class="variable">$grep</span> -Ev <span class="string">&quot;^#|^$&quot;</span> docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">BindsTo=containerd.service</span><br><span class="line">After=network-online.target firewalld.service containerd.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=docker.socket</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">TasksMax=infinity</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[root@centos8 system]<span class="variable">$grep</span> -Ev <span class="string">&quot;^#|^$&quot;</span> docker.socket</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Socket <span class="keyword">for</span> the API</span><br><span class="line">PartOf=docker.service</span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=/var/run/docker.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">SocketUser=root</span><br><span class="line">SocketGroup=docker</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br><span class="line"></span><br><span class="line">[root@centos8 system]<span class="variable">$grep</span> -Ev <span class="string">&quot;^#|^$&quot;</span> containerd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=containerd container runtime</span><br><span class="line">Documentation=https://containerd.io</span><br><span class="line">After=network.target local-fs.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe overlay</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/containerd</span><br><span class="line">Type=notify</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=always</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">TasksMax=infinity</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">然后重新加载一下systemd，启动服务就可以了</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-docker配置国内加速器"><a href="#1-2-2-docker配置国内加速器" class="headerlink" title="1.2.2 docker配置国内加速器"></a>1.2.2 docker配置国内加速器</h3><p>去阿里云注册一个账号，然后获得一个阿里云的docker镜像加速地址，之后把这个内容写到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line"> &#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>docker默认服务使用socket文件，但是可以修改为监听端口，修改的方法有两种</p>
<p>1.修改/etc/docker/daemon.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;, &quot;tcp:&#x2F;&#x2F;127.0.0.1:2375&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.修改/lib/systemd/syste/docker.service文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F; -H tcp:&#x2F;&#x2F;127.0.0.1:2375</span><br></pre></td></tr></table></figure>

<p>脚本：</p>
<p>centos7一键安装docker脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Centos7一键安装docker同时配置阿里云的镜像加速器脚本</span><br><span class="line"># 采用的方法是使用阿里云的Yum源</span><br><span class="line"></span><br><span class="line"># 调用Linux系统自带函数action</span><br><span class="line">source &#x2F;etc&#x2F;init.d&#x2F;functions</span><br><span class="line"></span><br><span class="line"># 定义变量</span><br><span class="line">DOWNLOAD_DIR&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;src&quot;</span><br><span class="line">VERSION&#x3D;&quot;19.03.13-3.el7&quot;</span><br><span class="line"></span><br><span class="line"># 定义函数</span><br><span class="line">function install_docker() &#123;</span><br><span class="line">    echo &quot;开始安装docker，请稍等&quot;</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">    yum install -y yum-utils device-mapper-persistent-data lvm2 &amp;&gt;&#x2F;dev&#x2F;null || &#123; action &quot;必要工具下载失败，请检查yum源&quot; false;exit 9; &#125;</span><br><span class="line">    # Step 2: 添加软件源信息</span><br><span class="line">    yum-config-manager --add-repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    # Step 3: 更新并安装Docker-CE</span><br><span class="line">    yum makecache fast &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    # 中间centos7需要额外安装一个包</span><br><span class="line">    cd $&#123;DOWNLOAD_DIR&#125;</span><br><span class="line">    wget -q http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;7&#x2F;extras&#x2F;x86_64&#x2F;Packages&#x2F;container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm</span><br><span class="line">    yum -y install container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    yum -y install docker-ce-$&#123;VERSION&#125; &amp;&gt;&#x2F;dev&#x2F;null &amp;&amp; action &quot;docker-ce-$&#123;VERSION&#125;安装成功！&quot; || &#123; action &quot;安装docker-ce-$&#123;VERSION&#125;失败&quot; false;exit 9; &#125;</span><br><span class="line">    # 如果要选择不同版本的软件，那么加上--showduplicates选项</span><br><span class="line">    # yum list docker-ce --showduplicates</span><br><span class="line">    # Step 4: 开启Docker服务</span><br><span class="line">    systemctl enable --now docker &amp;&amp; action &quot;Docker守护进程已开启！&quot; || &#123; action &quot;Docker守护进程启动失败&quot; false;exit 9; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function speedUp() &#123;</span><br><span class="line">    tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"># 调用函数</span><br><span class="line">install_docker</span><br><span class="line">speedUp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Ubuntu一键安装docker脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Ubuntu一键安装docker并且配置阿里云加速的脚本</span><br><span class="line"></span><br><span class="line"># 定义变量</span><br><span class="line">VERSION&#x3D;&quot;5:19.03.13~3-0~ubuntu-&quot;</span><br><span class="line">CLASS&#x3D;&#96;lsb_release -cs&#96;</span><br><span class="line"></span><br><span class="line"># 定义函数</span><br><span class="line">function install_docker() &#123;</span><br><span class="line">	echo &quot;开始安装docker&quot;</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">    apt update &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    apt -y install apt-transport-https ca-certificates curl software-properties-common &amp;&gt;&#x2F;dev&#x2F;null || &#123; echo &quot;安装基础包失败，请检查apt源&quot;;exit 9; &#125;</span><br><span class="line">    # step 2: 安装GPG证书</span><br><span class="line">    curl -fsSL https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br><span class="line">    # Step 3: 写入软件源信息</span><br><span class="line">    add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot; </span><br><span class="line">    # Step 4: 更新并安装Docker-CE</span><br><span class="line">    apt -y update &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    # Step 5: 选择docker-ce的版本并安装</span><br><span class="line">    # apt list docker-ce -a 通过这个命令可以查看软件包版本</span><br><span class="line">    apt -y install docker-ce&#x3D;$&#123;VERSION&#125;$&#123;CLASS&#125; &amp;&gt;&#x2F;dev&#x2F;null &amp;&amp; echo &quot;docker-ce $&#123;VERSION&#125;安装完成！&quot; || &#123; echo &quot;docker-ce $&#123;VERSION&#125;安装失败&quot;;exit 9; &#125;</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function speedUp() &#123;</span><br><span class="line">    tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">install_docker</span><br><span class="line">speedUp</span><br></pre></td></tr></table></figure>

<p>centos8一键安装docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Centos8一键安装docker同时配置阿里云的镜像加速器脚本</span><br><span class="line"># 采用的方法是使用阿里云的Yum源</span><br><span class="line"></span><br><span class="line"># 调用Linux系统自带函数action</span><br><span class="line">source &#x2F;etc&#x2F;init.d&#x2F;functions</span><br><span class="line"></span><br><span class="line"># 定义变量</span><br><span class="line">DOWNLOAD_DIR&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;src&quot;</span><br><span class="line">VERSION&#x3D;&quot;19.03.13-3.el8&quot;</span><br><span class="line"></span><br><span class="line"># 定义函数</span><br><span class="line">function install_docker() &#123;</span><br><span class="line">    echo &quot;开始安装docker，请稍等&quot;</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">    yum install -y yum-utils device-mapper-persistent-data lvm2 &amp;&gt;&#x2F;dev&#x2F;null || &#123; action &quot;必要工具下载失败，请检查yum源&quot; false;exit 9; &#125;</span><br><span class="line">    # 生成docker.repo仓库配置文件</span><br><span class="line">    tee &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;EOF</span><br><span class="line">[docker]</span><br><span class="line">name&#x3D;docker</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;8&#x2F;x86_64&#x2F;stable&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enable&#x3D;1</span><br><span class="line">EOF</span><br><span class="line">    dnf repolist &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    dnf -y install docker-ce-$&#123;VERSION&#125; &amp;&gt;&#x2F;dev&#x2F;null &amp;&amp; action &quot;docker-ce-$&#123;VERSION&#125;已安装完成！&quot; || &#123; action &quot;docker-ce-$&#123;VERSION&#125;安装失败&quot; false;exit 9; &#125;</span><br><span class="line">    systemctl enable --now docker &amp;&amp; action &quot;Docker守护进程已开启！&quot; || &#123; action &quot;Docker守护进程启动失败&quot; false;exit 9; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function speedUp() &#123;</span><br><span class="line">    tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"># 调用函数</span><br><span class="line">install_docker</span><br><span class="line">speedUp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>通信流程</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113103103493.png" alt="image-20201113103103493"></p>
<h3 id="1-2-3-存储引擎"><a href="#1-2-3-存储引擎" class="headerlink" title="1.2.3 存储引擎"></a>1.2.3 存储引擎</h3><p>联合文件系统：Union FS</p>
<p>把不同的物理位置的目录合并mount到同一个目录中，简单来说就是支持将不同目录挂载到一个虚拟文件系统想，这样可以层层叠加修改文件，无论底下有多少层，都是只读层，只有最上层才是可以写的</p>
<p>只读层就是复制的镜像，可写层就是容器</p>
<p>docker目前使用的UnionFS是overlay2</p>
<h3 id="1-2-4-docker进程关系"><a href="#1-2-4-docker进程关系" class="headerlink" title="1.2.4 docker进程关系"></a>1.2.4 docker进程关系</h3><p>dockerd启动–&gt;containerd启动，同时启动grpc，grpc监听dockerd请求</p>
<p>grpc接收到dockerd请求后，发送给containerd，containerd根据请求作出操作</p>
<h2 id="1-3-镜像管理"><a href="#1-3-镜像管理" class="headerlink" title="1.3 镜像管理"></a>1.3 镜像管理</h2><h3 id="1-3-1-镜像结构和分层"><a href="#1-3-1-镜像结构和分层" class="headerlink" title="1.3.1 镜像结构和分层"></a>1.3.1 镜像结构和分层</h3><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114154956782.png" alt="image-20201114154956782"></p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114155433028.png" alt="image-20201114155433028"></p>
<p>镜像即创建容器的模板，含有启动容器所需要的文件系统及所需要的内容，因此镜像主要用于方便和快速的创建并启动容器</p>
<p>docker的镜像是一层一层搭出来的，docker分层的好处就是可以复用，节省空间</p>
<p>分层是需要文件系统支持的，这个文件系统是Union FS，联合文件系统</p>
<p>一个典型的Linux文件系统由bootfs和rootfs组成</p>
<p>bootfs主要包括bootloader和kernel，BootLoader主要用于引导加载kernel，Linux刚启动时会加载bootfs文件系统，当boot加载完成后，kernel会被加载到内存中然后接管系统的控制权，bootfs会被umount，而容器使用宿主机的bootfs，因此不需要bootfs了</p>
<p>rootfs，根文件系统，包含的就是典型的Linux系统中的/dev,/proc,/bin,etc等标准目录和文件，不同的Linux发行版如Ubuntu和Centos主要在rootfs这一层有区别</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114163854325.png" alt="image-20201114163854325"></p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114163906945.png" alt="image-20201114163906945"></p>
<p>容器是最顶层，一个可以进行写操作的层，容器的下面是镜像层，镜像是不可写的</p>
<p>查看一个镜像中的层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# docker image history nginx:latest</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">c39a868aad02        8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  STOPSIGNAL SIGTERM           0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  EXPOSE 80                    0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENTRYPOINT [&quot;&#x2F;docker-entr…   0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop) COPY file:13577a83b18ff90a…   1.96kB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop) COPY file:e7e183879c35719c…   1.2kB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c set -x     &amp;&amp; addgroup --system -…   63.6MB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENV PKG_RELEASE&#x3D;1~buster     0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENV NJS_VERSION&#x3D;0.4.4        0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENV NGINX_VERSION&#x3D;1.19.4     0B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         &#x2F;bin&#x2F;sh -c #(nop)  LABEL maintainer&#x3D;NGINX Do…   0B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         &#x2F;bin&#x2F;sh -c #(nop) ADD file:0dc53e7886c35bc21…   69.2MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<p>docker image inspect image_name</p>
<p>保存一个镜像文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save  image_name -o xxx.tar</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-搜索镜像"><a href="#1-3-2-搜索镜像" class="headerlink" title="1.3.2 搜索镜像"></a>1.3.2 搜索镜像</h3><p>docker的官网：dockerhub</p>
<p>docker search image_name</p>
<p>docker search可以支持选择性的搜索</p>
<p>alpine是个面向安全的Linux发行版，包管理器是apk</p>
<h3 id="1-3-3-下载镜像"><a href="#1-3-3-下载镜像" class="headerlink" title="1.3.3 下载镜像"></a>1.3.3 下载镜像</h3><p>从docker仓库下载到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [options] name[:tags]</span><br></pre></td></tr></table></figure>

<p>下载的时候不要使用默认的latest镜像，而要使用具体版本号的镜像</p>
<p>docker存储引擎：overlay2，覆盖，包裹住</p>
<h3 id="1-3-4-镜像查看、镜像保存、镜像导入"><a href="#1-3-4-镜像查看、镜像保存、镜像导入" class="headerlink" title="1.3.4 镜像查看、镜像保存、镜像导入"></a>1.3.4 镜像查看、镜像保存、镜像导入</h3><p>镜像保存</p>
<p>docker save busybox -o busybox.tar</p>
<p>镜像导入</p>
<p>docker load &lt; busybox.tar</p>
<p>或者</p>
<p>docker load -i busybox.tar</p>
<h3 id="1-3-5-镜像删除"><a href="#1-3-5-镜像删除" class="headerlink" title="1.3.5 镜像删除"></a>1.3.5 镜像删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image remove busybox:latest</span><br><span class="line">或者</span><br><span class="line">docker rmi busybox:latest</span><br></pre></td></tr></table></figure>

<p>镜像文件存储在</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/overlay2</span><br></pre></td></tr></table></figure>

<p>镜像就是模板，运行容器时就是把镜像复制一份然后去使用</p>
<p>可以使用docker image -q列出全部镜像的ID，然后</p>
<p>删除镜像之前要把使用这个镜像的容器先删除</p>
<p>删除容器的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container remove container_id</span><br><span class="line">或者</span><br><span class="line">docker rm container_id</span><br></pre></td></tr></table></figure>

<p>老师设置的别名：</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113150551644.png" alt="image-20201113150551644"></p>
<h3 id="1-3-6-镜像打标签"><a href="#1-3-6-镜像打标签" class="headerlink" title="1.3.6 镜像打标签"></a>1.3.6 镜像打标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure>



<h3 id="1-3-7-alpine介绍"><a href="#1-3-7-alpine介绍" class="headerlink" title="1.3.7 alpine介绍"></a>1.3.7 alpine介绍</h3><p>Alpine是一个面向安全的轻型Linux发行版，采用musl libc和busy box，包管理工具是apk</p>
<p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;apk&#x2F;repositories</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;</span><br><span class="line">apk update</span><br><span class="line">apk add vim</span><br><span class="line">apk del vim</span><br></pre></td></tr></table></figure>

<h3 id="1-3-8-建议安装的包"><a href="#1-3-8-建议安装的包" class="headerlink" title="1.3.8 建议安装的包"></a>1.3.8 建议安装的包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install procps</span><br><span class="line">apt install psmisc</span><br><span class="line">apt install iputils-ping</span><br><span class="line">apt install net-tools</span><br></pre></td></tr></table></figure>



<h2 id="1-4-容器操作基础命令"><a href="#1-4-容器操作基础命令" class="headerlink" title="1.4 容器操作基础命令"></a>1.4 容器操作基础命令</h2><h3 id="1-4-1-启动容器"><a href="#1-4-1-启动容器" class="headerlink" title="1.4.1 启动容器"></a>1.4.1 启动容器</h3><p>docker run 会自动搜索本地和官方仓库</p>
<p>步骤：</p>
<ul>
<li>创建容器</li>
<li>启动容器</li>
</ul>
<p>两个步骤可以合并起来，使用run命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# docker run --help</span><br><span class="line"></span><br><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line">-i,--interactive 交互模式</span><br><span class="line">-t,--tty  分配pseudo-tty，通常和-i一起使用，注意对应的容器必须运行shell才支持</span><br><span class="line">-d，--detach  后台运行容器，并打印容器ID</span><br><span class="line">--name 设定容器名称</span><br><span class="line">--h，hostname，设定容器主机名</span><br><span class="line">--rm，Automatically remove the container when it exits</span><br><span class="line">-p，--publish list Publish a container&#39;s port(s) to the host</span><br><span class="line">-P，--publish-all  Publish all exposed ports to random ports</span><br><span class="line">--dns list                       Set custom DNS servers</span><br><span class="line">--entrypoint string              Overwrite the default ENTRYPOINT of the image</span><br><span class="line">--restart string                 Restart policy to apply when a container exits (default &quot;no&quot;)</span><br><span class="line">重启容器的规则，默认是不重启，可以跟always，只要容器退出就重启</span><br><span class="line">还有on-failure</span><br><span class="line">unless-stopped</span><br><span class="line"></span><br><span class="line">--privileged Give extended privileges to this container</span><br><span class="line">-e,--env&#x3D;[]		Set environment variables，设定容器的环境变量</span><br><span class="line">--env-file&#x3D;[]		Read in a line delimited file of environment variables</span><br></pre></td></tr></table></figure>

<p>宿主机开启，自动开启容器的方法：</p>
<p><code>docker run  --restart always</code></p>
<p>启动容器时执行命令，适合一次性的命令：</p>
<p><code>docker run xxxx cat /etc/issues</code></p>
<p>给容器定义名称</p>
<p><code>docker run --name centos8-1 centos8:latest</code></p>
<p>在启动容器时进入交互式命令</p>
<p><code>docker run --name centos8-2 -it centos8 sh </code></p>
<p>容器内的文件在宿主机的<code>/var/lib/docker/overlay2/xxxxx</code>下面</p>
<p>退出容器的交互式命令，但是不关闭容器</p>
<p><code>ctrl + p + q</code></p>
<p>设置容器的主机名</p>
<p><code>docker run -it -h we1.dota.org centos8:latest bash</code></p>
<p>停止容器并删除容器</p>
<p><code>docker run --rm  centos8:latest</code></p>
<p>查看容器映射到宿主机的端口</p>
<p><code>docker port container_id</code></p>
<p>暴露容器端口的方法</p>
<p><code>docker run -P httpd</code></p>
<p>使用wget冒充curl</p>
<p><code>wget -qO - IP</code></p>
<p>系统级的容器如果想要后台运行，需要分配一个终端</p>
<p><code>docker run -td centos8</code></p>
<p>运行容器时，给容器某些权限</p>
<p><code>--privileged</code></p>
<p>官方文档</p>
<p><code>https://docs.docker.com/</code></p>
<p>查看当前正在运行的容器</p>
<p><code>docker container ps </code>，还可以加<code>-a</code>显示全部的(包括停止的)镜像，<code>-q</code>显示容器ID，<code>-l</code>表示最近的容器，<code>-s</code>显示容器的空间大小，<code>-f</code>可以指定是什么状态的容器</p>
<p>运行一个docker文档的镜像</p>
<p><code> docker run -it -d -p 4000:4000 docs/docker.github.io:latest</code></p>
<p>查看容器内运行的程序</p>
<p><code>docker top container_id</code></p>
<p>一些我们常用的、但是镜像内一般没有的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psmisc --&gt; pstree</span><br><span class="line">procps --&gt; ps</span><br></pre></td></tr></table></figure>

<p>查看容器资源使用情况</p>
<p><code>docker stats container_id</code></p>
<p>对容器资源的使用限制，暂时没有记录</p>
<p>查看容器或者镜像的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container_id </span><br><span class="line">docker inspect image_name</span><br><span class="line">加-f选项后面跟具体的配置</span><br></pre></td></tr></table></figure>

<p>删除容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm container_id</span><br><span class="line">可以加-f选项，强制删除，哪怕容器正在运行</span><br><span class="line">根据容器状态进行筛选后删除，status&#x3D;exitd</span><br></pre></td></tr></table></figure>

<p>暂停容器和停止容器是不一样的，暂停容器，宿主机上可以看到容器进程了，停止容器，宿主机上就看不到容器进程了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pause  #暂停</span><br><span class="line">docker unpause #取消暂停</span><br><span class="line">docker stop #停止</span><br><span class="line">docker start #开启</span><br></pre></td></tr></table></figure>

<p>进入正在运行的容器</p>
<p><code>docker attach container_id</code></p>
<p>使用exec命令进入容器执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container exec container_id &#x3D;it COMMAND</span><br><span class="line">这里的COMMAND一定是容器中包含的命令，一般用sh</span><br></pre></td></tr></table></figure>

<p>暴露容器端口，本质上是在宿主机的防火墙上配置了DNAT规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rum -P </span><br><span class="line">这个是随机分配一个端口给容器</span><br></pre></td></tr></table></figure>

<h4 id="指定端口映射"><a href="#指定端口映射" class="headerlink" title="指定端口映射"></a>指定端口映射</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80</span><br><span class="line">表示把容器的80端口映射出去，宿主机端口随机，效果与-P相同</span><br><span class="line"></span><br><span class="line">docker run -p 81:80</span><br><span class="line">表示把容器的80端口映射出去，宿主机端口是81</span><br><span class="line">前面的端口是宿主机端口，后面的端口是容器端口</span><br><span class="line"></span><br><span class="line">docker run -p 10.0.0.100:81:80 </span><br><span class="line">表示必须是本地的10.0.0.100的81端口被映射成容器的80端口</span><br></pre></td></tr></table></figure>

<p>容器间的端口冲突也要提防！容器使用什么端口都要记录和分配好</p>
<p>案例：修改一个已经设定好端口映射的、正在运行的容器的端口映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通过docker container list找到当前容器的ID，如</span><br><span class="line">docker container list</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">c383f8ce793d        nginx               &quot;&#x2F;docker-entrypoint.…&quot;   5 minutes ago       Up About a minute   0.0.0.0:80-&gt;80&#x2F;tcp   web1</span><br><span class="line">然后进入这个目录，&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;</span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers</span><br><span class="line">找到与容器ID匹配的文件夹，进入</span><br><span class="line">然后就能看到hostconfig.json文件了</span><br><span class="line">vim hostconfig.json</span><br><span class="line"></span><br><span class="line">可以看到</span><br><span class="line">PortBindings&quot;:&#123;&quot;80&#x2F;tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;80&quot;&#125;]&#125;</span><br><span class="line">后面的HostPort跟着的就是宿主机的映射端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>查看容器日志 –&gt; 叫做日志，其实是容器的输出</p>
<p>docker logs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs [options] container_name</span><br><span class="line">或者</span><br><span class="line">docker container logs [OPTIONS] CONTAINER</span><br><span class="line">-f，--follow Follow log output</span><br><span class="line">--tail string 从下往上看日志</span><br><span class="line">-t，--timestamps</span><br></pre></td></tr></table></figure>



<p>传递运行命令</p>
<p>一个容器如果没有默认前台执行的进程，那么开启后就会立即退出，但是我们可以人为给这样的容器增加一个前台运行的命令，比如tail -f /etc/hosts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm alpine -d &#x2F;bin&#x2F;sh tail -f &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>



<p>容器内部自己的hosts文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker container run --add-host 域名:IP         Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">例如：</span><br><span class="line">docker run -d --name web1 -p 8080:80 --add-host shicheng:6.6.6.6 nginx</span><br><span class="line"></span><br><span class="line">docker container list</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">88505c96e232        nginx               &quot;&#x2F;docker-entrypoint.…&quot;   10 seconds ago      Up 8 seconds        0.0.0.0:8080-&gt;80&#x2F;tcp   web1</span><br><span class="line"></span><br><span class="line">docker exec -it web1 sh</span><br><span class="line"># cat &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">6.6.6.6 shicheng</span><br><span class="line">172.17.0.2      88505c96e232</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>指定容器的DNS</p>
<p>容器DNS默认使用宿主机DNS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker container run --dns list  Set custom DNS servers</span><br><span class="line">或者通过设置宿主机的&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">docker run -d --name web1 -p 8080:80 --dns&#x3D;8.8.8.8 nginx</span><br><span class="line">docker exec -it web1 sh</span><br><span class="line"># cat &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>实现容器和宿主机之间复制文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">        docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line"></span><br><span class="line">Copy files&#x2F;folders between a container and the local filesystem</span><br><span class="line"></span><br><span class="line">Use &#39;-&#39; as the source to read a tar archive from stdin</span><br><span class="line">and extract it to a directory destination in a container.</span><br><span class="line">Use &#39;-&#39; as the destination to stream a tar archive of a</span><br><span class="line">container source to stdout.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --archive       Archive mode (copy all uid&#x2F;gid information)</span><br><span class="line">  -L, --follow-link   Always follow symbol link in SRC_PATH</span><br></pre></td></tr></table></figure>

<p>例如：从宿主机复制文件到容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前有个web1容器在运行</span><br><span class="line">docker cp test web1:&#x2F;root&#x2F;</span><br></pre></td></tr></table></figure>

<p>例如：从容器复制文件到宿主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp web1:&#x2F;root&#x2F;test .</span><br></pre></td></tr></table></figure>



<p>使用宿主机的systemd控制容器运行</p>
<p>这种方法很少用，会使用k8s进行编排调度</p>
<p>方法：编写一个.service文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"> Description&#x3D;Hello</span><br><span class="line"> After&#x3D;docker.service</span><br><span class="line"> Requires&#x3D;docker.service</span><br><span class="line"> [Service]</span><br><span class="line"> TimeoutStartSec&#x3D;0 </span><br><span class="line"> ExecStartPre&#x3D;-&#x2F;usr&#x2F;bin&#x2F;docker kill busybox-hello  #注意这里的-，如果不加，那么当目前没有一个叫busybox-hello的容器在运行时，服务无法启动</span><br><span class="line"> ExecStartPre&#x3D;-&#x2F;usr&#x2F;bin&#x2F;docker rm busybox-hello</span><br><span class="line"> ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;docker run --name busybox-hello busybox &#x2F;bin&#x2F;sh -c &quot;while true;   do echo Hello World;sleep 1;done&quot;</span><br><span class="line"> ExecStop&#x3D;&#x2F;usr&#x2F;bin&#x2F;docker kill busybox-hello</span><br><span class="line"> [Install]</span><br><span class="line"> WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>传递环境变量</p>
<p>有些容器运行时，需要传递变量，可以使用-e选项或–env-file实现</p>
<p>如何知道要传什么变量呢？去看dockerhub中该容器的介绍，或者自己编写的Dockerfile心里应该有数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意，一个环境变量一个-e选项</span><br><span class="line">-e password&#x3D;xxx -e user&#x3D;xxx</span><br></pre></td></tr></table></figure>

<p>–env-file如何写：每行一个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim env.list</span><br><span class="line">MYSQL_ROOT_PASSWORD&#x3D;123456</span><br><span class="line">MYSQL_DATABASE&#x3D;xxxx</span><br><span class="line">MYSQL_USER&#x3D;wp</span><br><span class="line">MYSQL_PASSWORD&#x3D;xxx</span><br></pre></td></tr></table></figure>



<p>podman管理容器</p>
<p>podman命令与docker基本一致，但是结构不一样，docker是c/s架构的，需要启动服务，后台运行的，podman不是，podman是用的时候启动，不用的时候关闭</p>
<p>podman进程数比较少，conmon一个进程，容器都是conmon的子进程</p>
<h1 id="2-Docker-镜像制作和管理"><a href="#2-Docker-镜像制作和管理" class="headerlink" title="2 Docker 镜像制作和管理"></a>2 Docker 镜像制作和管理</h1><h2 id="2-1-Docker镜像说明"><a href="#2-1-Docker镜像说明" class="headerlink" title="2.1 Docker镜像说明"></a>2.1 Docker镜像说明</h2><p><strong>1.镜像中有没有内核？</strong></p>
<p>没有，容器使用宿主机内核，而镜像本身则只提供相应的rootfs</p>
<p><strong>2.容器中的程序后台运行会导致容器启动后退出，因此需要将容器中的服务进程以前台方式运行，或者使用一些类似tail，top的前台运行的程序也行，常用的保持前台运行方法是：<code>tail -f /etc/hosts</code></strong></p>
<p><strong>3.docker镜像生命周期</strong></p>
<p>dockerfile–&gt;bulid命令–&gt;生成镜像–&gt;push–&gt;镜像仓库–&gt;被pull到主机–&gt;跑成容器</p>
<p>dockerfile可以理解为脚本文件，它有自己的编写格式和要求</p>
<p><strong>4.制作镜像</strong></p>
<p>Docker镜像制作类似于虚拟机的镜像制作，即按照实际业务需求将需要安装的软件、相关配置等基础环境配置完成，然后将其做成镜像，最后再批量从镜像生成容器实例，这样可以极大的简化相同环境的部署工作</p>
<p>镜像制作有两种方式：基于容器的手动制作；基于Dockerfile的自动制作；通常使用Dockerfile制作镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit # 通过修改现有容器，将之手动构建为镜像</span><br><span class="line">docker build  # 通过Dockerfile文件，批量构建为镜像</span><br></pre></td></tr></table></figure>



<h2 id="2-2-将现有容器通过-docker-commit-手动构建镜像"><a href="#2-2-将现有容器通过-docker-commit-手动构建镜像" class="headerlink" title="2.2 将现有容器通过 docker commit 手动构建镜像"></a>2.2 将现有容器通过 docker commit 手动构建镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit [options] container [repository[:tag]]</span><br><span class="line">Create a new image from a container&#39;s changes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --author string    Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)</span><br><span class="line">  -c, --change list      Apply Dockerfile instruction to the created image</span><br><span class="line">  -m, --message string   Commit message</span><br><span class="line">  -p, --pause            Pause container during commit (default true)</span><br></pre></td></tr></table></figure>

<p><strong>手动制作镜像流程：</strong></p>
<p>1.下载一个系统的官方基础镜像</p>
<p>2.基于基础镜像启动一个容器，并进入到容器</p>
<p>3.在容器里面做配置操作</p>
<ul>
<li>安装基础命令</li>
<li>配置运行环境</li>
<li>安装服务和配置服务</li>
<li>放业务代码</li>
</ul>
<p>4.提交为一个新镜像，docker commit</p>
<p>5.基于自己的镜像创建容器并检验功能</p>
<p>实验：基于 busybox 制作 httpd 镜像</p>
<p>实验：使用docker commit基于Tomcat官方镜像制作一个自定义的tomcat镜像</p>
<p>实验：使用docker commit基于Ubuntu官方镜像制作一个自定义的Ubuntu+Nginx镜像</p>
<p>实验：使用docker commit基于Centos的基础镜像利用yum安装手动制作nginx镜像</p>
<p>端口暴露的几种写法，去回顾一下：<a href="#%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84">指定端口映射</a></p>
<p>docker run -p 80</p>
<p>docker run -p 8080:80</p>
<p>docker run -P</p>
<p>docker run -p 10.0.0.55:8080:80</p>
<p>docker run -p 10.0.0.55:8080:80/tcp</p>
<p>docker run -p 10.0.0.55:8080:80/tcp -p 10.0.0.55:90:90/udp</p>
<p>docker run -p 10.0.0.55::80 </p>
<h2 id="2-3-利用DockerFile-文件执行-docker-build-自动构建镜像"><a href="#2-3-利用DockerFile-文件执行-docker-build-自动构建镜像" class="headerlink" title="2.3 利用DockerFile 文件执行 docker build 自动构建镜像"></a>2.3 利用DockerFile 文件执行 docker build 自动构建镜像</h2><h3 id="2-3-1-Dockerfile-使用详解"><a href="#2-3-1-Dockerfile-使用详解" class="headerlink" title="2.3.1 Dockerfile 使用详解"></a>2.3.1 Dockerfile 使用详解</h3><p><strong>1.Dockerfile概念</strong></p>
<p>​    Dockerfile是一种被Docker程序解释执行的脚本，由一条条的命令组成的，每条命令对应Linux下面的一条命令，Docker程序将这些Dockerfile指令再翻译成真正的Linux命令，Dockerfile有自己的书写方式和支持的命令，Docker程序读取Dockerfile并根据指令生成Docker镜像，相比手动制作镜像的方式，Dockerfile更能直观的展示镜像是怎么产生的，有了Dockerfile，当后期有额外的需求时，只需要在之前的Dockerfile添加或者修改响应的命令即可重新生成新的Docker镜像，避免了重复手动制作镜像的麻烦，类似shell脚本一样，可以方便高效的制作镜像</p>
<p><strong>注意：每条指令都是独立运行的，每条指令之间没有关系，每条指令都会生成一个镜像层</strong></p>
<p>比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;tmp</span><br><span class="line">RUN echo &quot;nihao&quot; &gt; nihao.txt</span><br><span class="line"># 这个时候，nihao.txt并不存放在&#x2F;tmp中，因为两条命令之间没有关系</span><br></pre></td></tr></table></figure>

<p><strong>注意：Docker经尽可能重用中间映像，也就是缓存，用来加速 docker build 命令的执行过程，这由Using cache控制台输出中的消息指示</strong></p>
<p><strong>2.Dockerfile镜像制作和使用流程</strong></p>
<p>dockerfile–&gt;bulid命令–&gt;生成镜像–&gt;push–&gt;镜像仓库–&gt;被pull到主机–&gt;跑成容器</p>
<p><strong>3.Dockerfile文件制作镜像的分层结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[Centos&#x2F;Ubuntu] --&gt;B(安装常用命令和初始化配置)</span><br><span class="line">    B --&gt; C(保存成镜像)</span><br><span class="line">    C --&gt; D(添加业务代码,提供服务)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以生成类似的目录来存放镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/&#123;system/&#123;alpine,centos,ubuntu&#125;,web/&#123;apache,nginx,tomcat&#125;&#125;</span><br><span class="line">root@ubuntu1804:/data# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── system</span><br><span class="line">│   ├── alpine</span><br><span class="line">│   ├── centos</span><br><span class="line">│   └── ubuntu</span><br><span class="line">└── web</span><br><span class="line">    ├── apache</span><br><span class="line">    ├── nginx</span><br><span class="line">    └── tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-Dockerfile文件格式"><a href="#2-3-2-Dockerfile文件格式" class="headerlink" title="2.3.2 Dockerfile文件格式"></a>2.3.2 Dockerfile文件格式</h3><p>官方文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;builder&#x2F;</span><br><span class="line">or</span><br><span class="line">man 5 dockerfile</span><br></pre></td></tr></table></figure>

<p><strong>Dockerfile 文件说明：</strong></p>
<ul>
<li>每一行以Dockerfile的指令开头，指令不区分大小写，但是惯例使用大写</li>
<li>使用<code>#</code>开始作为注释</li>
<li>每一行只支持一条指令，每条指令可以携带多个参数</li>
<li>指令按照文件的顺序从上到下依次执行</li>
<li>每个指令的执行都会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令</li>
<li>制作镜像一般可能需要反复多次，每次执行Dockerfile都按顺序执行，从头开始，已经执行过的指令已经被缓存，不需要执行，如果有一行新的指令没有被执行过，其往后的指令将会重新执行，所以为了加速镜像执行，将最长变化的内容放到Dockerfile文件的下面</li>
</ul>
<h4 id="Dockerfile-相关指令"><a href="#Dockerfile-相关指令" class="headerlink" title="Dockerfile 相关指令"></a>Dockerfile 相关指令</h4><p>常用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM</span><br><span class="line">LABEL</span><br><span class="line">ADD</span><br><span class="line">COPY</span><br><span class="line">RUN</span><br><span class="line">CMD</span><br><span class="line">ENTRYPOINT</span><br><span class="line">EXPOSE</span><br><span class="line">VOLUME</span><br><span class="line">WORKDIR</span><br><span class="line">USER</span><br><span class="line">STOPSIGNAL</span><br></pre></td></tr></table></figure>



<h5 id="1-FROM：指定基础镜像"><a href="#1-FROM：指定基础镜像" class="headerlink" title="1.FROM：指定基础镜像"></a>1.FROM：指定基础镜像</h5><p>定制镜像，需要先有一个基础镜像，在这个基础镜像上进行定制</p>
<p>scratch：空镜像，所有镜像的原始镜像，Dockerfile中必须有一个FROM，因此需要这么一个空镜像</p>
<p>FROM的工作流程：</p>
<blockquote>
<p>FROM通常放在Dockerfile文件的第一个、非注释行，后续的指令运行在这个FROM指定的基础镜像的环境中，基础镜像可以是任意可以使用的镜像，docker程序默认先从本地找，如果本地有就用本地的，如果本地没有，就去dockerhub上拉取镜像</p>
<p>建议使用各个开源软件官方提供的镜像，安全可靠</p>
</blockquote>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p>例子：如果要指定版本号，就需要提前调查，调查的方式是dockerhub上查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">FROM ubuntu</span><br><span class="line">FROM centos</span><br></pre></td></tr></table></figure>



<h5 id="2-LABEL：指定镜像元数据"><a href="#2-LABEL：指定镜像元数据" class="headerlink" title="2.LABEL：指定镜像元数据"></a>2.LABEL：指定镜像元数据</h5><p>给镜像添加元数据，也就是作者、联系方式等信息</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt;...</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL Author&#x3D;&quot;huihui&quot; Version&#x3D;&quot;1.0&quot; Telephone&#x3D;&quot;123&quot;</span><br><span class="line"># 还可以写多行</span><br><span class="line">LABEL XXX&#x3D;12</span><br><span class="line">LABEL XXX&#x3D;JJJ</span><br></pre></td></tr></table></figure>

<h5 id="3-RUN：执行shell命令"><a href="#3-RUN：执行shell命令" class="headerlink" title="3.RUN：执行shell命令"></a>3.RUN：执行shell命令</h5><p>RUN指令用来在构建镜像阶段需要执行FROM指定镜像所支持的Shell命令</p>
<p>尽量把命令写在一个RUN里面，减少分层</p>
<p>每个RUN都是独立运行的，命令和命令之间互不相关</p>
<p>格式说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 有两种格式，一种是shell格式，另一种是exec格式，建议用exec的格式，我感觉这个比较全面</span><br><span class="line"># exec格式</span><br><span class="line">RUN [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</span><br><span class="line"># shell格式</span><br><span class="line">RUN echo hello   # 相当于 RUN &#x2F;bin&#x2F;sh -c echo hello</span><br><span class="line"></span><br><span class="line">这两种格式的区别在于shell命令不是容器中pid为1的进程，它前面一定有sh了，而exec会顶替掉当前进程，自己变成当前进程，继承它的进程号，exec执行的命令可以成为Pid为1的进程</span><br><span class="line">exec格式不支持环境变量，shell支持</span><br></pre></td></tr></table></figure>

<p>/bin/bash -c 命令的意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把一个字符串当成一个命令执行，第一个参数是$0，后面的参数是$1，$2...</span><br></pre></td></tr></table></figure>



<h5 id="4-ENV：设置环境变量"><a href="#4-ENV：设置环境变量" class="headerlink" title="4.ENV：设置环境变量"></a>4.ENV：设置环境变量</h5><p><strong>ENV的作用范围：制作镜像的时候以及运行成容器的时候，全部时间都生效</strong></p>
<p><strong>ENV可以定义环境变量和值，会被后续指令比如RUN、ENV、ADD、COPY等通过${VALUE}或者$VALUE的方式调用</strong></p>
<p>相关的几个环境变量的优先级，前提是，下面这两个加参数的选项他们影响的只是运行容器时的变量，构建容器时的变量他们改不了：</p>
<p>Dockerfile中的ENV：优先级低</p>
<p>docker run 的时候参数–env-file：优先级第二高</p>
<p>docker run 的时候参数-e：优先级最高</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENV key1&#x3D;value1 key2&#x3D;value2 \</span><br><span class="line">	key3&#x3D;value3 \</span><br><span class="line">	xxx</span><br><span class="line"># 支持高级变量赋值</span><br><span class="line">A&#x3D;$&#123;key:-word&#125;	意思是，当key没有被定义或赋值的时候，A的值是$word，否则A的值是$key</span><br><span class="line">A&#x3D;$&#123;key:+word&#125;	意思是，当key没有被定义或赋值的时候，A的值是空，否则A的值是$word</span><br></pre></td></tr></table></figure>



<h5 id="5-COPY：复制宿主机文件到容器"><a href="#5-COPY：复制宿主机文件到容器" class="headerlink" title="5.COPY：复制宿主机文件到容器"></a>5.COPY：复制宿主机文件到容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown&#x3D;user:group] src dest</span><br><span class="line">OR</span><br><span class="line">COPY [--chown&#x3D;user:group] [&quot;src&quot;,&quot;dest&quot;]</span><br></pre></td></tr></table></figure>

<p>几个注意的点：</p>
<p>可以是多个，可以使用通配符，通配符满足go语言规范，go语言规范在：<a target="_blank" rel="noopener" href="https://golang.org/pkg/path/filepath/#Match">https://golang.org/pkg/path/filepath/#Match</a></p>
<p>只复制目录数据，不复制目录本身</p>
<p>复制文件的时候，如果目标文件夹不存在，会递归创建出来</p>
<p>如果写相对路径，那么必须在Dockerfile所在目录；可以写绝对路径</p>
<p>源文件的元数据会被保留，比如所属组、用户、权限等</p>
<p>可以覆盖文件，如果要复制的地方已经有了文件的话</p>
<h5 id="5-ADD：复制和解包文件"><a href="#5-ADD：复制和解包文件" class="headerlink" title="5.ADD：复制和解包文件"></a>5.ADD：复制和解包文件</h5><p>增强版的COPY，复制完还能解压缩</p>
<p>zip包不能解压</p>
<p>可以是一个URL，URL下载完的文件不会被解压，权限会被设置成600</p>
<p>tar.gz,tar.bz2,tar.xz等文件会被解压，前提是由gzip,bzip2等软件</p>
<h5 id="6-CMD：容器启动命令"><a href="#6-CMD：容器启动命令" class="headerlink" title="6.CMD：容器启动命令"></a>6.CMD：容器启动命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Image1--&gt;|docker build| Image2</span><br><span class="line">Image1--&gt;|RUN| Image2</span><br><span class="line">Image2 --&gt;|docker run| Container</span><br><span class="line">Image2 --&gt;|CMD| Container</span><br></pre></td></tr></table></figure>

<p><strong>如上图，CMD命令是在镜像已经被打好，需要被运行成一个容器时才执行的</strong></p>
<p>容器中必须有一个运行在前台的、持续的命令</p>
<p>一个容器中需要持续运行的进程一般只有一个，CMD用来指定启动容器时默认执行的一个命令，且命令停止后，容器也会停止，所以CMD指定的命令为持续运行的且为前台的命令</p>
<p><strong>注意：一个Dockerfile只能有一个CMD命令，如果有多个CMD，那么只运行最后一条</strong></p>
<p><strong>注意：如果用户启动容器的时候指定了运行命令，那么CMD命令会被覆盖</strong></p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">or</span><br><span class="line">CMD command param1 param2</span><br><span class="line">or</span><br><span class="line">如果Dockerfile文件中有ENTRYPOINT，那么CMD的命令将成为ENTRYPOINT命令的参数，这时候这么写</span><br><span class="line">CMD [&quot;param1&quot;，&quot;param2&quot;] # 直接写参数，不用写&#x2F;bin&#x2F;bash这种执行文件了，比如</span><br><span class="line">CMD[&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off&quot;]</span><br></pre></td></tr></table></figure>



<h5 id="7-ENTRYPOINT：入口点"><a href="#7-ENTRYPOINT：入口点" class="headerlink" title="7.ENTRYPOINT：入口点"></a>7.ENTRYPOINT：入口点</h5><p>在运行一个容器的时候才会执行</p>
<p><strong>ENTRYPOINT命令不会被docker run提供的命令替换掉</strong></p>
<p>如有Dockerfile中有ENTRYPOINT，那么docker run 后面跟的命令会变成ENTRYPOINT命令的参数</p>
<p>entrypoint的高级用法</p>
<p>-e选项和entrypoint的关系，大家都是在docker run 的时候生效，所以-e选项带来的环境变量可以影响到ENTRYPOINT命令中的变量</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable_file&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">or</span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure>

<p>注意：可以通过docker run –entrypoint string参数在运行时替换</p>
<h5 id="8-ARG：构建参数"><a href="#8-ARG：构建参数" class="headerlink" title="8.ARG：构建参数"></a>8.ARG：构建参数</h5><p>ARG指令在build阶段生效，在docker run阶段就无效了</p>
<p>ENV优先级高于ARG，如果参数名和ENV重复，那么ENV生效</p>
<p>ARG可以比FROM还早的使用</p>
<h5 id="9-VOLUME：挂载点"><a href="#9-VOLUME：挂载点" class="headerlink" title="9.VOLUME：挂载点"></a>9.VOLUME：挂载点</h5><p>在容器中创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保存的数据</p>
<p>在删除容器的时候，加上-v选项才能把挂载点文件也删除</p>
<p><code>docker container rm -fv container_name</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data1&quot;,&quot;&#x2F;data2&quot;]</span><br></pre></td></tr></table></figure>

<p>在宿主机的位置：</p>
<p><code>/var/lib/docker/volumes/&lt;volume_id&gt;/_data</code></p>
<h5 id="10-EXPOSE：暴露端口"><a href="#10-EXPOSE：暴露端口" class="headerlink" title="10.EXPOSE：暴露端口"></a>10.EXPOSE：暴露端口</h5><p>指定默认暴露的端口，但只是指定，并不会主动暴露，还是需要在docker run阶段使用-p,-P来进行暴露</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt;[&#x2F; &lt;protocol&gt;]</span><br><span class="line">protocol是udp或tcp</span><br><span class="line">例如：</span><br><span class="line">EXPOSE 80 443</span><br></pre></td></tr></table></figure>



<h5 id="11-WORKDIR：指定工作目录"><a href="#11-WORKDIR：指定工作目录" class="headerlink" title="11.WORKDIR：指定工作目录"></a>11.WORKDIR：指定工作目录</h5><p>可以指定一个目录，影响Dockerfile文件中位于它后面的命令的工作目录</p>
<p>如果指定的目录不存在，那么就会被创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span><br><span class="line">如果出现多个WORKDIR，并且使用相对路径，那么都是基于前面的WORKDIR路径</span><br></pre></td></tr></table></figure>



<h5 id="12-ONBUILD：子镜像引用父镜像的指令"><a href="#12-ONBUILD：子镜像引用父镜像的指令" class="headerlink" title="12.ONBUILD：子镜像引用父镜像的指令"></a>12.ONBUILD：子镜像引用父镜像的指令</h5><p>自己不执行，让引用它镜像的子镜像执行的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br><span class="line">例如：</span><br><span class="line">ONBUILD RUN rm -rf &#x2F;*</span><br></pre></td></tr></table></figure>



<h5 id="13-USER：指定当前用户"><a href="#13-USER：指定当前用户" class="headerlink" title="13.USER：指定当前用户"></a>13.USER：指定当前用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER mysql:mysql</span><br></pre></td></tr></table></figure>



<h5 id="14-HEALTHCHECK：健康检查"><a href="#14-HEALTHCHECK：健康检查" class="headerlink" title="14.HEALTHCHECK：健康检查"></a>14.HEALTHCHECK：健康检查</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [OPTIONS] CMD &lt;COMMANDS&gt;</span><br></pre></td></tr></table></figure>



<h5 id="15-STOPSIGNAL：退出容器的信号"><a href="#15-STOPSIGNAL：退出容器的信号" class="headerlink" title="15.STOPSIGNAL：退出容器的信号"></a>15.STOPSIGNAL：退出容器的信号</h5><p>设置被发送到容器退出的系统调用信号，默认信号是9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>

<h5 id="16-SHELL：指定SHELL"><a href="#16-SHELL：指定SHELL" class="headerlink" title="16.SHELL：指定SHELL"></a>16.SHELL：指定SHELL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable_file&quot;,&quot;parameters&quot;]</span><br></pre></td></tr></table></figure>



<h5 id="17-“-dockerignore”文件"><a href="#17-“-dockerignore”文件" class="headerlink" title="17. “.dockerignore”文件"></a>17. “.dockerignore”文件</h5><p>生成构建上下文时Docker应该忽略的文件和文件夹格式</p>
<p>官方文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;builder&#x2F;#dockerignore-file</span><br></pre></td></tr></table></figure>



<p>.dockerignore文件使用GO语言的文件路径规则filepath.Match</p>
<p>18.按照作用范围对Dockerfile的指令进行分类</p>
<table>
<thead>
<tr>
<th>BUILD</th>
<th>RUN</th>
<th>BOTH</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>CMD</td>
<td>ENV</td>
</tr>
<tr>
<td>RUN</td>
<td>ENTRYPOINT</td>
<td>WORKDIR</td>
</tr>
<tr>
<td>LABEL</td>
<td>VOLUME</td>
<td>USER</td>
</tr>
<tr>
<td>ADD</td>
<td>EXPOSE</td>
<td></td>
</tr>
<tr>
<td>COPY</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ONBUILD</td>
<td></td>
<td></td>
</tr>
<tr>
<td>.dockerignore</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-3-3-docker-build-命令介绍"><a href="#2-3-3-docker-build-命令介绍" class="headerlink" title="2.3.3 docker build 命令介绍"></a>2.3.3 docker build 命令介绍</h4><p>在写完了Dockerfile后，使用docker build命令利用Dockerfile来创建镜像</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker build [options] path | url | -</span><br><span class="line">path：指定路径，一般就是使用.，表示当前目录</span><br><span class="line">url：指定一个URL</span><br><span class="line">-：表示从标准输入获得Dockerfile</span><br><span class="line">options：</span><br><span class="line">-f,--file string #指定Dockerfile的文件名，默认就是Dockerfile</span><br><span class="line">--no-cache  #不使用缓存</span><br><span class="line">--force-rm	#总是删除中间层容器，创建容器失败时，删除临时容器</span><br><span class="line">-q	#不显示docker build的过程</span><br><span class="line">--rm&#x3D;true  #创建镜像成功时，删除临时容器</span><br><span class="line">-t，--tag list #设置镜像的名称、标签，格式为：&lt;注册中心&gt;&#x2F;&lt;镜像名称&gt;:&lt;标签&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-3-4-案例一：基于centos7镜像构建基于YUM安装的nginx镜像"><a href="#2-3-4-案例一：基于centos7镜像构建基于YUM安装的nginx镜像" class="headerlink" title="2.3.4 案例一：基于centos7镜像构建基于YUM安装的nginx镜像"></a>2.3.4 案例一：基于centos7镜像构建基于YUM安装的nginx镜像</h4><p>Dockerfile文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:centos7.8.2003</span><br><span class="line">LABEL mantainer&#x3D;&quot;huihui&quot;</span><br><span class="line">RUN rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*</span><br><span class="line">COPY Base.repo epel.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">RUN yum install -y nginx \</span><br><span class="line">    &amp;&amp; rm -f &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html \</span><br><span class="line">    &amp;&amp; echo Good afternoon! My friends! &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line"># 构建、运行</span><br><span class="line">docker build -t centos7:v1.0 .</span><br><span class="line">docker run -d --name c1 -P centos7:v1.0</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像"><a href="#2-3-5-案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像" class="headerlink" title="2.3.5 案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像"></a>2.3.5 案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像</h4><p>第一步：制作基础镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 首先需要按照功能，把镜像分类管理，就按照文件夹来进行分类</span><br><span class="line">root@ubuntu1804:&#x2F;data# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── system</span><br><span class="line">│   ├── alpine</span><br><span class="line">│   ├── centos</span><br><span class="line">│   └── ubuntu</span><br><span class="line">└── web</span><br><span class="line">    ├── apache</span><br><span class="line">    ├── nginx</span><br><span class="line">    └── tomcat</span><br><span class="line">#然后编写Dockerfile，下面的Dockerfile文件需要提前在当前文件夹下准备repo文件</span><br><span class="line"> FROM centos:centos7.8.2003</span><br><span class="line"> LABEL mantainer&#x3D;&quot;huihui&quot;</span><br><span class="line"> RUN rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*</span><br><span class="line"> COPY Base.repo epel.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"> RUN yum install -y vim-enhanced tcpdump lrzsz tree telnet bash-completion psmisc \</span><br><span class="line">     net-tools wget bzip2 lsof tmux man-pages zip unzip nfs-utils gcc make iproute \</span><br><span class="line">     gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel zlib-devel &amp;&amp; \</span><br><span class="line">     yum clean all &amp;&amp; \</span><br><span class="line">     rm -f &#x2F;etc&#x2F;localtime &amp;&amp; \</span><br><span class="line">     ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br><span class="line"># 构建新镜像，然后运行成容器验证效果</span><br><span class="line">docker build -t centos7:v1.0 .</span><br><span class="line">docker run -it --name c1 centos7:v1.0 sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二步：制作Nginx镜像，nginx使用编译安装的方式，下面主要的问题是nginx的编译安装，以及把bash命令行的命令转换成Dockerfile语句，因此进行问题分解，先使用一个测试机做一遍nginx的编译安装，再去编写Dockerfile</p>
<p>第二步第一小步：编译安装Nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 1.安装必要的包</span><br><span class="line">yum -y install pcre pcre-devel openssl openssl-devel zlib-devel</span><br><span class="line"># 2.下载nginx的源码</span><br><span class="line">wget -P &#x2F;usr&#x2F;local&#x2F;src http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.18.0.tar.gz</span><br><span class="line"># 3.解压</span><br><span class="line">tar xf nginx-1.18.0.tar.gz</span><br><span class="line"># 4.开始预编译</span><br><span class="line">cd nginx-1.18.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx</span><br><span class="line"># 5.编译和编译安装</span><br><span class="line">make -j 4 &amp;&amp; make install</span><br><span class="line"># 6.修改一下配置文件</span><br><span class="line">vim &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">  1 daemon off;</span><br><span class="line">  2 user  nginx;</span><br><span class="line">  3 worker_processes  1;</span><br><span class="line"></span><br><span class="line">[root@localhost apps]$tree -L 2</span><br><span class="line">.</span><br><span class="line">└── nginx</span><br><span class="line">    ├── conf</span><br><span class="line">    ├── html</span><br><span class="line">    ├── logs</span><br><span class="line">    └── sbin</span><br><span class="line"># 7.把生成的配置文件拷贝到要制作nginx镜像的服务器上</span><br><span class="line">scp &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 10.0.0.55:&#x2F;data&#x2F;web&#x2F;nginx&#x2F;1.18</span><br></pre></td></tr></table></figure>

<p>第二步第二小步：编写nginx镜像的Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 1.编写之前把需要的东西准备好，包括nginx的源码包、nginx的自定义配置文件</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;web# tree</span><br><span class="line">.</span><br><span class="line">├── nginx</span><br><span class="line">│   └── 1.8</span><br><span class="line">│       ├── Dockerfile</span><br><span class="line">│       ├── nginx-1.18.0.tar.gz</span><br><span class="line">│       └── nginx.conf</span><br><span class="line"></span><br><span class="line">2.Dockerfile文件</span><br><span class="line"> FROM centos7:v1.0</span><br><span class="line"> ARG VERSION&#x3D;&quot;nginx-1.18.0&quot;</span><br><span class="line"> ADD $&#123;VERSION&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"> RUN cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; \</span><br><span class="line">     .&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx &amp;&amp; \</span><br><span class="line">     make &amp;&amp; make install &amp;&amp; \</span><br><span class="line">     rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx* &amp;&amp; \</span><br><span class="line">     rm -rf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf &amp;&amp; \</span><br><span class="line">     useradd -r nginx</span><br><span class="line"> COPY nginx.conf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;</span><br><span class="line"> EXPOSE 80</span><br><span class="line"> CMD [&quot;&#x2F;apps&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三步：生成镜像并允许成容器进行功能测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx-1.18.0:v1.0 .</span><br><span class="line">docker run --rm -d --name web1 -P nginx-1.18.0:v1.0</span><br><span class="line"># 查看当前宿主机的监听端口，可以看到一个随机的、32768后面的端口32769被监听</span><br><span class="line">LISTEN   0          128                         *:32769                    *:*</span><br><span class="line"># 访问宿主机的32769</span><br><span class="line">curl 10.0.0.55:32769</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像"><a href="#2-3-6-案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像" class="headerlink" title="2.3.6 案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像"></a>2.3.6 案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像</h4><p>这个案例可以结合前两个案例的Dockerfile文件，整合起来就好了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.准备一些基本文件</span></span><br><span class="line">root@ubuntu1804:/data/web/nginx<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">└── nginx-v1</span><br><span class="line">    ├── Base.repo</span><br><span class="line">    ├── Dockerfile</span><br><span class="line">    ├── epel.repo</span><br><span class="line">    ├── nginx-<span class="number">1.18</span>.<span class="number">0</span>.tar.gz</span><br><span class="line">    └── nginx.conf</span><br><span class="line"><span class="comment"># 2.编写Dockerfile</span></span><br><span class="line"> <span class="keyword">FROM</span> centos:centos7.<span class="number">8.2003</span></span><br><span class="line"> <span class="keyword">ARG</span> VERSION=<span class="string">&quot;nginx-1.18.0&quot;</span></span><br><span class="line"> <span class="keyword">LABEL</span><span class="bash"> mantainer=<span class="string">&quot;huihui&quot;</span></span></span><br><span class="line"> <span class="keyword">RUN</span><span class="bash"> rm -rf /etc/yum.repos.d/*</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="bash"> Base.repo epel.repo /etc/yum.repos.d/</span></span><br><span class="line"> <span class="keyword">ADD</span><span class="bash"> <span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/<span class="built_in">local</span>/src</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="bash"> yum install -y vim-enhanced tcpdump lrzsz tree telnet bash-completion psmisc \</span></span><br><span class="line"><span class="bash">     net-tools wget bzip2 lsof tmux man-pages zip unzip nfs-utils gcc make iproute \</span></span><br><span class="line"><span class="bash">     gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel zlib-devel &amp;&amp; \</span></span><br><span class="line"><span class="bash">     yum clean all &amp;&amp; \</span></span><br><span class="line"><span class="bash">     rm -f /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="bash">     ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="bash">     <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/<span class="variable">$&#123;VERSION&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">     ./configure --prefix=/apps/nginx &amp;&amp; \</span></span><br><span class="line"><span class="bash">     make &amp;&amp; make install &amp;&amp; \</span></span><br><span class="line"><span class="bash">     rm -rf /usr/<span class="built_in">local</span>/src/nginx* &amp;&amp; \</span></span><br><span class="line"><span class="bash">     rm -rf /apps/nginx/conf/nginx.conf &amp;&amp; \</span></span><br><span class="line"><span class="bash">     useradd -r nginx</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="bash"> nginx.conf /apps/nginx/conf/</span></span><br><span class="line"> <span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"> <span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/apps/nginx/sbin/nginx&quot;</span>]</span></span><br><span class="line"><span class="comment"># 3.制作镜像并且运行成容器</span></span><br><span class="line">docker build -t nginx-<span class="number">1.18</span>.<span class="number">0</span>:v2.<span class="number">0</span> .</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --rm --name web2 -d -p 8080:80 nginx-1.18.0:v2.0</span></span><br><span class="line"><span class="comment"># 4.测试</span></span><br><span class="line">查看当前宿主机的监听端口，发现<span class="number">8080</span>已经被监听</span><br><span class="line">LISTEN   <span class="number">0</span>          <span class="number">128</span>                         *:<span class="number">8080</span>                     *:*</span><br><span class="line">curl <span class="number">10.0</span>.<span class="number">0.55</span>:<span class="number">8080</span></span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-生产案例：制作自定义tomcat业务镜像"><a href="#2-4-生产案例：制作自定义tomcat业务镜像" class="headerlink" title="2.4 生产案例：制作自定义tomcat业务镜像"></a>2.4 生产案例：制作自定义tomcat业务镜像</h2><h2 id="2-5-生产案例：构建haproxy镜像"><a href="#2-5-生产案例：构建haproxy镜像" class="headerlink" title="2.5 生产案例：构建haproxy镜像"></a>2.5 生产案例：构建haproxy镜像</h2><h2 id="2-6-基于alpine基础镜像制作NGINX镜像"><a href="#2-6-基于alpine基础镜像制作NGINX镜像" class="headerlink" title="2.6 基于alpine基础镜像制作NGINX镜像"></a>2.6 基于alpine基础镜像制作NGINX镜像</h2><p>第一步：准备基础文件，包括alpine:3.12.1镜像，repositories文件，Nginx源码，nginx.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;alpine# ls</span><br><span class="line">nginx-1.18.0.tar.gz  nginx.conf  repositories</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;alpine# cat repositories</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.12&#x2F;main</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.12&#x2F;community</span><br><span class="line"></span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;alpine# docker images</span><br><span class="line">alpine              3.12.1              d6e46aa2470d        3 weeks ago         5.57MB</span><br><span class="line"></span><br><span class="line"># 准备编写Dockerfile文件，要想好一会要怎么替换apk下载源、一会要下载什么软件的问题</span><br><span class="line">apk update</span><br><span class="line">apk --no-cache add iotop gcc libgcc libc-dev libcurl libc-utils pcre-dev zlib-dev libnfs make pcre pcre2 zip unzip net-tools pstree wget libevent libevent libevent-dev iproute2</span><br></pre></td></tr></table></figure>

<p>第二步：编写Dockerfile文件，有两种方式，第一种方式是分层构建，即先构建一个安装了基本软件、改变了安装源的alpine基础镜像，再构建Nginx；第二种方式是一步到位，直接构建基于alpine的nginx镜像</p>
<p>我用第一种，这样层次分明，alpine基础镜像之后还可以继续使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 基础alpine镜像制作</span><br><span class="line"># Dockerfile</span><br><span class="line"> FROM alpine:3.12.1</span><br><span class="line"> LABEL Author&#x3D;&quot;huihui&quot;</span><br><span class="line"> COPY repositories &#x2F;etc&#x2F;apk&#x2F;repositories</span><br><span class="line"> RUN apk update &amp;&amp; apk --no-cache add iotop gcc libgcc libc-dev \</span><br><span class="line">     libcurl libc-utils pcre-dev zlib-dev libnfs make pcre pcre2 \</span><br><span class="line">     zip unzip net-tools pstree wget libevent libevent libevent-dev iproute2</span><br><span class="line"># 构建镜像并运行成容器</span><br><span class="line">docker build -t alpine-3.12.1:v1.0 .</span><br><span class="line">docker run --it --name a1 --rm alpine-3.12.1:v1.0</span><br><span class="line"></span><br><span class="line"># 基于基础alpine制作nginx</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;web&#x2F;nginx&#x2F;nginx-v2# ls</span><br><span class="line">Dockerfile  nginx-1.18.0.tar.gz  nginx.conf</span><br><span class="line"># Dockerfile</span><br><span class="line">FROM alpine-3.12.1:v1.0</span><br><span class="line"> ENV VERSION&#x3D;&quot;nginx-1.18.0&quot;</span><br><span class="line"> LABEL DATE&#x3D;&quot;2020.11.17&quot;</span><br><span class="line"> ADD $&#123;VERSION&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"> RUN cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx &amp;&amp; \</span><br><span class="line">     make &amp;&amp; make install &amp;&amp; rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; \</span><br><span class="line">     rm -rf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf &amp;&amp; \</span><br><span class="line">     addgroup -g 2020 -S nginx &amp;&amp; adduser -s &#x2F;sbin&#x2F;nologin -S -D -u 2020 \</span><br><span class="line">     -G nginx nginx &amp;&amp; chown -R nginx.nginx &#x2F;apps&#x2F;nginx</span><br><span class="line"> COPY nginx.conf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line"> EXPOSE 80</span><br><span class="line"> CMD [&quot;&#x2F;apps&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;]</span><br></pre></td></tr></table></figure>

<p>第三步：构建成镜像，并允许成容器，测试功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx-1.18.0:v3.0 .</span><br><span class="line">docker run --rm --name web3 -d -p 90:80 nginx-1.18.0:3.0</span><br><span class="line"></span><br><span class="line"># 查看当前宿主机端口是否监听了90端口</span><br><span class="line">ss -nlt</span><br><span class="line">LISTEN   0          128                         *:90                       *:*</span><br><span class="line"># 访问测试</span><br><span class="line">curl 10.0.0.55:90</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure>



<h2 id="2-7-基于Ubuntu基础镜像制作NGINX镜像"><a href="#2-7-基于Ubuntu基础镜像制作NGINX镜像" class="headerlink" title="2.7 基于Ubuntu基础镜像制作NGINX镜像"></a>2.7 基于Ubuntu基础镜像制作NGINX镜像</h2><p>第一步：准备文件，包括Ubuntu的sources.list文件，nginx源码，nginx配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 准备的文件</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;ubuntu# ls</span><br><span class="line">Dockerfile  sources.list</span><br><span class="line"># 想想一会要下载安装什么软件</span><br><span class="line">apt update</span><br><span class="line">apt install -y gcc openssh-server tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev unzip zip make</span><br></pre></td></tr></table></figure>

<p>第二步：制作Ubuntu的基础镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Docker</span><br><span class="line"> FROM ubuntu</span><br><span class="line"> LABEL manitainer&#x3D;&quot;huihui&quot;</span><br><span class="line"> COPY sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line"> RUN apt update &amp;&amp; apt install -y gcc openssh-server tree openssl \</span><br><span class="line">     libssl-dev libpcre3 libpcre3-dev zlib1g-dev unzip zip make</span><br><span class="line">     </span><br><span class="line"># 构建镜像</span><br><span class="line">docker build -t ubuntu-2004:v1.0 .</span><br></pre></td></tr></table></figure>

<p>第三步：制作nginx镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 准备的文件</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;web&#x2F;nginx&#x2F;nginx-v3# ls</span><br><span class="line">nginx-1.18.0.tar.gz  nginx.conf</span><br><span class="line"># Dockerfile</span><br><span class="line"> FROM ubuntu-2004:v1.0</span><br><span class="line"> ENV VERSION&#x3D;&quot;nginx-1.18.0&quot;</span><br><span class="line"> ADD $&#123;VERSION&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"> RUN cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx &amp;&amp;\</span><br><span class="line">     make &amp;&amp; make install &amp;&amp; rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx* &amp;&amp; \</span><br><span class="line">     groupadd -g 2020 -r nginx &amp;&amp; useradd -g nginx -s &#x2F;usr&#x2F;sbin&#x2F;nologin -u 2020 \</span><br><span class="line">     nginx &amp;&amp; chown -R nginx.nginx &#x2F;apps&#x2F;nginx</span><br><span class="line"> COPY nginx.conf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line"> EXPOSE 80</span><br><span class="line"> CMD [&quot;&#x2F;apps&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;]</span><br><span class="line"></span><br><span class="line"># 构建镜像并运行成容器</span><br><span class="line">docker build -t nginx-1.18.0:v4.0 .</span><br><span class="line">docker run --rm --name web4 -d -p 100:80 nginx-1.18.0:v4.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第四步：检验功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看宿主机监听的IP</span><br><span class="line">ss -nlt</span><br><span class="line">LISTEN   0          128                         *:100                      *:*</span><br><span class="line"># 访问宿主机100端口</span><br><span class="line">curl 10.0.0.55:100</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure>



<h1 id="3-Docker数据管理"><a href="#3-Docker数据管理" class="headerlink" title="3 Docker数据管理"></a>3 Docker数据管理</h1><p>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层</p>
<p>写时复制机制：</p>
<p>​        如果运行中的容器修改了现有的一个已经存在的文件，那么该文件会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，这就是“写时复制”机制，COW，Copy ON Write</p>
<p>​        如果正在运行的容器生成了新的数据，那么这个数据也会被复制到读写层，进行持久化保存，这个读写层是指容器的工作目录，这也是写时复制</p>
<p>​        COW机制节约空间，但是影响性能，而且随着容器的删除，数据也会被删除，无法保存，为了保存数据，需要使用数据卷技术</p>
<p>下面的图大概说明了，容器在写入数据的时候会把数据写入读写层和数据卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(容器)--&gt;|Write to|B[容器的文件系统]</span><br><span class="line">B--&gt;|Write to|C([读写层])</span><br><span class="line">B--&gt;|Write to|D([宿主机数据卷])</span><br></pre></td></tr></table></figure>



<h2 id="3-1-容器的数据管理介绍"><a href="#3-1-容器的数据管理介绍" class="headerlink" title="3.1 容器的数据管理介绍"></a>3.1 容器的数据管理介绍</h2><p>容器删除，读写层也被删除，数据无法保存</p>
<p>通过把容器的数据写入宿主机来保存数据</p>
<h3 id="3-1-1-容器的分层"><a href="#3-1-1-容器的分层" class="headerlink" title="3.1.1 容器的分层"></a>3.1.1 容器的分层</h3><p><strong>LowerDir：镜像层，镜像本身</strong></p>
<p><strong>UpperDir：容器的上层，可读写，容器变化的数据存放在此处</strong></p>
<p><strong>MergedDir：容器的文件系统，使用Union FS，将LowerDir和UpperDir合并起来呈现给用户</strong></p>
<p><strong>WorkDir：容器在宿主机的工作目录</strong></p>
<p>通过命令查看这几个分层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect container_name</span><br><span class="line">例如：</span><br><span class="line">docker container inspect busybox1</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb-init&#x2F;diff:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;932dede2b5e2dc14c70ff5f5f32f4ab29fd92c6d4d9f6c6667fa20bc143a010c&#x2F;diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb&#x2F;merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb&#x2F;diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb&#x2F;work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-1-2-什么数据应该持久化"><a href="#3-1-2-什么数据应该持久化" class="headerlink" title="3.1.2 什么数据应该持久化"></a>3.1.2 什么数据应该持久化</h3><p>1.数据库：包括关系型数据库Mysql、远程字典服务Redis等</p>
<p>2.需要保存状态的服务：Tomcat Memcached</p>
<h3 id="3-1-3-解决方案"><a href="#3-1-3-解决方案" class="headerlink" title="3.1.3 解决方案"></a>3.1.3 解决方案</h3><p>数据卷：宿主机上的目录或文件，挂载到容器内使用，分为三种使用方案</p>
<ul>
<li>直接使用宿主机的文件目录作为容器的一个文件目录，推荐使用，较为常用</li>
<li>匿名卷</li>
<li>命名卷</li>
</ul>
<p>数据卷容器：间接使用宿主机空间，需要增加一个专门的容器来当数据卷，</p>
<h2 id="3-2-数据卷"><a href="#3-2-数据卷" class="headerlink" title="3.2 数据卷"></a>3.2 数据卷</h2><p><strong>大概</strong></p>
<p>本质上是使用宿主机的文件或目录挂载到容器内部使用，容器删除时不会删除挂载文件，因此数据保存了下来</p>
<p>Dockerfile中的VOLUMES选项也是一种匿名卷，可以被-v选项所替代</p>
<p><strong>分类：</strong></p>
<ul>
<li>指定宿主机目录或文件，指定容器内部的挂载点</li>
<li>匿名卷：在删除容器的时候加上-v选项会删除掉，其他两种方式不会被删除</li>
<li>命名卷</li>
</ul>
<p>有一点，只有匿名卷在使用命令<code>docker container rm -fv</code>的时候会被删除，其他的卷需要其他方式删除，比如删除宿主机文件，命名卷可以使用<code>docker volume rm</code>删除</p>
<p>可以加只读选项：ro</p>
<p><strong>特点</strong></p>
<ul>
<li>数据卷可以在多个容器之间共同使用，实现容器之间文件共享</li>
<li>数据卷的变化不会影响到镜像</li>
<li>依赖于宿主机，不方便容器的迁移和数据的统一管理</li>
</ul>
<p><strong>三种数据卷的使用方法：</strong></p>
<p>首先，三种方法都是在容器运行时使用，因此都是在docker run命令后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -v [host-src:]container-dest[:options]</span><br><span class="line">options:</span><br><span class="line">rw，默认值，容器对数据卷拥有读写权限</span><br><span class="line">ro，只读，容器只能读取数据卷，不能写</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法一：明确指定宿主机文件或目录以及容器的文件或目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --rm -v &#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;centos -d mysql:8.0.22</span><br><span class="line"></span><br><span class="line">-v &#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">明确指明宿主机和容器的文件目录挂载关系</span><br><span class="line">如果宿主机上不存在这个目录，会被自动创建出来，容器没有这个目录不行</span><br><span class="line"></span><br><span class="line">测试，删除了容器，宿主机上数据卷目录中文件还在</span><br></pre></td></tr></table></figure>

<p>方法二：匿名卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --rm -v &#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;centos -d mysql:8.0.22</span><br><span class="line"></span><br><span class="line">-v &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">只写上容器中哪个目录要被挂载，不写宿主机上是谁挂载上去，docker程序会在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;下自动生成一个文件去挂载</span><br><span class="line"></span><br><span class="line">通过inspect命令查找是哪个数据卷</span><br><span class="line">docker container inspect 6f7acc6951dd</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;cac7ecd9607a82578d680defe350069c7d2119e33a36cee272684b1efe5ce03c&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;cac7ecd9607a82578d680defe350069c7d2119e33a36cee272684b1efe5ce03c&#x2F;_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;mysql&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">上面的Source文件就是，去查看，可以看到容器中数据库生成的文件</span><br></pre></td></tr></table></figure>

<p>方法三：命名卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有两种方法：</span><br><span class="line">方法一：提前创建一个数据卷</span><br><span class="line">方法二：在docker run 的时候顺便创建</span><br><span class="line"></span><br><span class="line">docker run --rm -p 3306:3306 -d -e MYSQL_ROOT_PASSWORD&#x3D;centos -v volume1:&#x2F;var&#x2F;lib&#x2F;mysql mysql:8.0.22</span><br><span class="line"></span><br><span class="line">-v volume1:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">写出明确的数据卷名称，docker程序会在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;下面生成</span><br><span class="line"></span><br><span class="line">root@ubuntu1804:~# ll &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;volume1&#x2F;</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 3 root root   4096 Nov 18 20:05 .&#x2F;</span><br><span class="line">drwx------ 9 root root   4096 Nov 18 20:05 ..&#x2F;</span><br><span class="line">drwxrwxrwt 6  999 docker 4096 Nov 18 20:06 _data&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>数据卷的管理命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker volume COMMAND</span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure>



<h2 id="3-3-数据卷容器"><a href="#3-3-数据卷容器" class="headerlink" title="3.3 数据卷容器"></a>3.3 数据卷容器</h2><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201118110004990.png" alt="image-20201118110004990"></p>
<p>–volumes-from &lt;数据卷容器&gt;</p>
<p>数据卷容器只在其他容器创建的时候被抄一下磁盘映射关系，其他时候没有用，它容器停了都没事，删除了对之前的容器也不影响</p>
<p>利用数据卷容器实现备份</p>
<h1 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4 网络管理"></a>4 网络管理</h1><h2 id="4-1-Docker的默认的网络通信"><a href="#4-1-Docker的默认的网络通信" class="headerlink" title="4.1 Docker的默认的网络通信"></a>4.1 Docker的默认的网络通信</h2><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201118114909203.png" alt="image-20201118114909203"></p>
<p>1.</p>
<p>在service文件中的execstart后面跟上这个选项：–icc false，表示禁止容器之间通信</p>
<p>2.</p>
<p>修改docker的默认网路配置</p>
<p>可以自行制定docker0的IP端</p>
<p>-b，–bip</p>
<h2 id="4-2-容器名称互联"><a href="#4-2-容器名称互联" class="headerlink" title="4.2 容器名称互联"></a>4.2 容器名称互联</h2><p>因为docker给容器分配IP是随机的，因此不能使用IP，所以使用一个固定的容器名称进行通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --link list # 写上其他容器的名称</span><br><span class="line"># 真正使用不是很多，因为太麻烦，不如DNS服务器来的爽</span><br></pre></td></tr></table></figure>



<p>因为害怕容器名称改变，引入了容器别名的问题</p>
<h2 id="4-3-Docker网络连接模式"><a href="#4-3-Docker网络连接模式" class="headerlink" title="4.3 Docker网络连接模式"></a>4.3 Docker网络连接模式</h2><p>一共5种模式：</p>
<ul>
<li>none：单机模式，只有lo网卡</li>
<li>bridge：默认网络模式</li>
<li>host：使用宿主机的网卡</li>
<li>container：一个容器使用另一个容器的网络，究极复制，连开启的端口都复制？？？</li>
<li>自定义网络</li>
</ul>
<p>使用方式<code>--network</code>后面跟模式</p>
<p>{}</p>
<p>$-</p>
<p>-B</p>
<p>docker network</p>
<p>docker network connect</p>
<h2 id="4-4-实现跨宿主机的容器之间网络互联"><a href="#4-4-实现跨宿主机的容器之间网络互联" class="headerlink" title="4.4 实现跨宿主机的容器之间网络互联"></a>4.4 实现跨宿主机的容器之间网络互联</h2><p>网桥就是一个交换机</p>
<p>Open vSwitch 开源的、虚拟交换机技术，包名是：apt install openvswitch-switch</p>
<h2 id="4-5-实战案例：利用docker结合负载实现网络架构高可用"><a href="#4-5-实战案例：利用docker结合负载实现网络架构高可用" class="headerlink" title="4.5 实战案例：利用docker结合负载实现网络架构高可用"></a>4.5 实战案例：利用docker结合负载实现网络架构高可用</h2><h1 id="5-Docker-仓库管理"><a href="#5-Docker-仓库管理" class="headerlink" title="5 Docker 仓库管理"></a>5 Docker 仓库管理</h1><h2 id="5-1-官方docker仓库"><a href="#5-1-官方docker仓库" class="headerlink" title="5.1 官方docker仓库"></a>5.1 官方docker仓库</h2><h2 id="5-2-阿里云Docker仓库"><a href="#5-2-阿里云Docker仓库" class="headerlink" title="5.2 阿里云Docker仓库"></a>5.2 阿里云Docker仓库</h2><h2 id="5-3-私有云单机仓库Docker-Registry"><a href="#5-3-私有云单机仓库Docker-Registry" class="headerlink" title="5.3 私有云单机仓库Docker Registry"></a>5.3 私有云单机仓库Docker Registry</h2><h2 id="5-4-Docker之分布式仓库Harbor"><a href="#5-4-Docker之分布式仓库Harbor" class="headerlink" title="5.4 Docker之分布式仓库Harbor"></a>5.4 Docker之分布式仓库Harbor</h2><h1 id="6-单机编排之Docker-Compose"><a href="#6-单机编排之Docker-Compose" class="headerlink" title="6 单机编排之Docker Compose"></a>6 单机编排之Docker Compose</h1><h2 id="6-1-Docker-Compose介绍"><a href="#6-1-Docker-Compose介绍" class="headerlink" title="6.1 Docker Compose介绍"></a>6.1 Docker Compose介绍</h2><h2 id="6-2-安装和准备"><a href="#6-2-安装和准备" class="headerlink" title="6.2 安装和准备"></a>6.2 安装和准备</h2><h2 id="6-3-从Docker-Compose启动单个容器"><a href="#6-3-从Docker-Compose启动单个容器" class="headerlink" title="6.3 从Docker Compose启动单个容器"></a>6.3 从Docker Compose启动单个容器</h2><h2 id="6-4-从-Docker-Compose启动多个容器"><a href="#6-4-从-Docker-Compose启动多个容器" class="headerlink" title="6.4 从 Docker Compose启动多个容器"></a>6.4 从 Docker Compose启动多个容器</h2><h2 id="6-5-实战案例：实现单机版的Haproxy-Nginx-Tomcat"><a href="#6-5-实战案例：实现单机版的Haproxy-Nginx-Tomcat" class="headerlink" title="6.5 实战案例：实现单机版的Haproxy+Nginx+Tomcat"></a>6.5 实战案例：实现单机版的Haproxy+Nginx+Tomcat</h2><h1 id="7-Docker的资源限制"><a href="#7-Docker的资源限制" class="headerlink" title="7 Docker的资源限制"></a>7 Docker的资源限制</h1><h2 id="7-1-Docker-资源限制"><a href="#7-1-Docker-资源限制" class="headerlink" title="7.1 Docker 资源限制"></a>7.1 Docker 资源限制</h2><h2 id="7-2-容器的内存限制"><a href="#7-2-容器的内存限制" class="headerlink" title="7.2 容器的内存限制"></a>7.2 容器的内存限制</h2><h2 id="7-3-容器的CPU限制"><a href="#7-3-容器的CPU限制" class="headerlink" title="7.3 容器的CPU限制"></a>7.3 容器的CPU限制</h2><h1 id="8-可视化图形工具Portainer"><a href="#8-可视化图形工具Portainer" class="headerlink" title="8 可视化图形工具Portainer"></a>8 可视化图形工具Portainer</h1>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/09/hexo%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="prev" title="hexo的环境搭建">
      <i class="fa fa-chevron-left"></i> hexo的环境搭建
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-Docker"><span class="nav-number">1.</span> <span class="nav-text">容器管理 Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Build-Ship-and-Run-Any-App-Anywhere"><span class="nav-number">1.1.</span> <span class="nav-text">Build,Ship and Run Any App,Anywhere</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Docker%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">1 Docker介绍和基础操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Docker-%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 Docker 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E5%AE%B9%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1.1 容器介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E5%AE%B9%E5%99%A8%E7%BB%84%E6%88%90"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.1.2 容器组成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Docker%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 Docker安装及基础命令介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E5%AE%89%E8%A3%85docker"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 安装docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F%E5%99%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2.2 docker配置国内加速器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">2.2.3.</span> <span class="nav-text">1.2.3 存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-docker%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.4.</span> <span class="nav-text">1.2.4 docker进程关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 镜像管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%86%E5%B1%82"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.3.1 镜像结构和分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">1.3.2 搜索镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">1.3.3 下载镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-%E9%95%9C%E5%83%8F%E6%9F%A5%E7%9C%8B%E3%80%81%E9%95%9C%E5%83%8F%E4%BF%9D%E5%AD%98%E3%80%81%E9%95%9C%E5%83%8F%E5%AF%BC%E5%85%A5"><span class="nav-number">2.3.4.</span> <span class="nav-text">1.3.4 镜像查看、镜像保存、镜像导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5-%E9%95%9C%E5%83%8F%E5%88%A0%E9%99%A4"><span class="nav-number">2.3.5.</span> <span class="nav-text">1.3.5 镜像删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-6-%E9%95%9C%E5%83%8F%E6%89%93%E6%A0%87%E7%AD%BE"><span class="nav-number">2.3.6.</span> <span class="nav-text">1.3.6 镜像打标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-7-alpine%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.3.7.</span> <span class="nav-text">1.3.7 alpine介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-8-%E5%BB%BA%E8%AE%AE%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85"><span class="nav-number">2.3.8.</span> <span class="nav-text">1.3.8 建议安装的包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 容器操作基础命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.4.1 启动容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">指定端口映射</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">2 Docker 镜像制作和管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Docker%E9%95%9C%E5%83%8F%E8%AF%B4%E6%98%8E"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 Docker镜像说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%B0%86%E7%8E%B0%E6%9C%89%E5%AE%B9%E5%99%A8%E9%80%9A%E8%BF%87-docker-commit-%E6%89%8B%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 将现有容器通过 docker commit 手动构建镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%88%A9%E7%94%A8DockerFile-%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C-docker-build-%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 利用DockerFile 文件执行 docker build 自动构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-Dockerfile-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.3.1.</span> <span class="nav-text">2.3.1 Dockerfile 使用详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-Dockerfile%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">2.3.2 Dockerfile文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dockerfile-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">Dockerfile 相关指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-FROM%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="nav-number">3.3.2.1.1.</span> <span class="nav-text">1.FROM：指定基础镜像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-LABEL%EF%BC%9A%E6%8C%87%E5%AE%9A%E9%95%9C%E5%83%8F%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.2.1.2.</span> <span class="nav-text">2.LABEL：指定镜像元数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-RUN%EF%BC%9A%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4"><span class="nav-number">3.3.2.1.3.</span> <span class="nav-text">3.RUN：执行shell命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-ENV%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.2.1.4.</span> <span class="nav-text">4.ENV：设置环境变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-COPY%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E5%88%B0%E5%AE%B9%E5%99%A8"><span class="nav-number">3.3.2.1.5.</span> <span class="nav-text">5.COPY：复制宿主机文件到容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-ADD%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%92%8C%E8%A7%A3%E5%8C%85%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.2.1.6.</span> <span class="nav-text">5.ADD：复制和解包文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-CMD%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">3.3.2.1.7.</span> <span class="nav-text">6.CMD：容器启动命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-ENTRYPOINT%EF%BC%9A%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="nav-number">3.3.2.1.8.</span> <span class="nav-text">7.ENTRYPOINT：入口点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-ARG%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><span class="nav-number">3.3.2.1.9.</span> <span class="nav-text">8.ARG：构建参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-VOLUME%EF%BC%9A%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="nav-number">3.3.2.1.10.</span> <span class="nav-text">9.VOLUME：挂载点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-EXPOSE%EF%BC%9A%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3"><span class="nav-number">3.3.2.1.11.</span> <span class="nav-text">10.EXPOSE：暴露端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-WORKDIR%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">3.3.2.1.12.</span> <span class="nav-text">11.WORKDIR：指定工作目录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-ONBUILD%EF%BC%9A%E5%AD%90%E9%95%9C%E5%83%8F%E5%BC%95%E7%94%A8%E7%88%B6%E9%95%9C%E5%83%8F%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="nav-number">3.3.2.1.13.</span> <span class="nav-text">12.ONBUILD：子镜像引用父镜像的指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-USER%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7"><span class="nav-number">3.3.2.1.14.</span> <span class="nav-text">13.USER：指定当前用户</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-HEALTHCHECK%EF%BC%9A%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="nav-number">3.3.2.1.15.</span> <span class="nav-text">14.HEALTHCHECK：健康检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15-STOPSIGNAL%EF%BC%9A%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">3.3.2.1.16.</span> <span class="nav-text">15.STOPSIGNAL：退出容器的信号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#16-SHELL%EF%BC%9A%E6%8C%87%E5%AE%9ASHELL"><span class="nav-number">3.3.2.1.17.</span> <span class="nav-text">16.SHELL：指定SHELL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#17-%E2%80%9C-dockerignore%E2%80%9D%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.2.1.18.</span> <span class="nav-text">17. “.dockerignore”文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-docker-build-%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">2.3.3 docker build 命令介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E4%BA%8Ecentos7%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8EYUM%E5%AE%89%E8%A3%85%E7%9A%84nginx%E9%95%9C%E5%83%8F"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">2.3.4 案例一：基于centos7镜像构建基于YUM安装的nginx镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%86%E5%B1%82%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%EF%BC%8C%E5%85%88%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Ecentos7%E7%9A%84%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E7%9A%84%E3%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%9A%84nginx%E9%95%9C%E5%83%8F"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">2.3.5 案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%88%B6%E4%BD%9C%E5%9F%BA%E4%BA%8ECentos%E5%AE%98%E6%96%B9%E7%89%88%E6%9C%AC%E7%9A%84%E3%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%9A%84Nginx%E9%95%9C%E5%83%8F"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">2.3.6 案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E7%94%9F%E4%BA%A7%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89tomcat%E4%B8%9A%E5%8A%A1%E9%95%9C%E5%83%8F"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 生产案例：制作自定义tomcat业务镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%94%9F%E4%BA%A7%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%9E%84%E5%BB%BAhaproxy%E9%95%9C%E5%83%8F"><span class="nav-number">3.5.</span> <span class="nav-text">2.5 生产案例：构建haproxy镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E5%9F%BA%E4%BA%8Ealpine%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9CNGINX%E9%95%9C%E5%83%8F"><span class="nav-number">3.6.</span> <span class="nav-text">2.6 基于alpine基础镜像制作NGINX镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E5%9F%BA%E4%BA%8EUbuntu%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9CNGINX%E9%95%9C%E5%83%8F"><span class="nav-number">3.7.</span> <span class="nav-text">2.7 基于Ubuntu基础镜像制作NGINX镜像</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">3 Docker数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 容器的数据管理介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%86%E5%B1%82"><span class="nav-number">4.1.1.</span> <span class="nav-text">3.1.1 容器的分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">4.1.2.</span> <span class="nav-text">3.1.2 什么数据应该持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.1.3 解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 数据卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 数据卷容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">4 网络管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Docker%E7%9A%84%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 Docker的默认的网络通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%AE%B9%E5%99%A8%E5%90%8D%E7%A7%B0%E4%BA%92%E8%81%94"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 容器名称互联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Docker%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 Docker网络连接模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 实现跨宿主机的容器之间网络互联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8docker%E7%BB%93%E5%90%88%E8%B4%9F%E8%BD%BD%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">5.5.</span> <span class="nav-text">4.5 实战案例：利用docker结合负载实现网络架构高可用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Docker-%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">5 Docker 仓库管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%AE%98%E6%96%B9docker%E4%BB%93%E5%BA%93"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 官方docker仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E9%98%BF%E9%87%8C%E4%BA%91Docker%E4%BB%93%E5%BA%93"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 阿里云Docker仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%A7%81%E6%9C%89%E4%BA%91%E5%8D%95%E6%9C%BA%E4%BB%93%E5%BA%93Docker-Registry"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 私有云单机仓库Docker Registry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-Docker%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%93%E5%BA%93Harbor"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 Docker之分布式仓库Harbor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%8D%95%E6%9C%BA%E7%BC%96%E6%8E%92%E4%B9%8BDocker-Compose"><span class="nav-number">7.</span> <span class="nav-text">6 单机编排之Docker Compose</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Docker-Compose%E4%BB%8B%E7%BB%8D"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 Docker Compose介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%86%E5%A4%87"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 安装和准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E4%BB%8EDocker-Compose%E5%90%AF%E5%8A%A8%E5%8D%95%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 从Docker Compose启动单个容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E4%BB%8E-Docker-Compose%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="nav-number">7.4.</span> <span class="nav-text">6.4 从 Docker Compose启动多个容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%8D%95%E6%9C%BA%E7%89%88%E7%9A%84Haproxy-Nginx-Tomcat"><span class="nav-number">7.5.</span> <span class="nav-text">6.5 实战案例：实现单机版的Haproxy+Nginx+Tomcat</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Docker%E7%9A%84%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-number">8.</span> <span class="nav-text">7 Docker的资源限制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Docker-%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 Docker 资源限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 容器的内存限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E5%AE%B9%E5%99%A8%E7%9A%84CPU%E9%99%90%E5%88%B6"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 容器的CPU限制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E5%BD%A2%E5%B7%A5%E5%85%B7Portainer"><span class="nav-number">9.</span> <span class="nav-text">8 可视化图形工具Portainer</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">huihui</p>
  <div class="site-description" itemprop="description">学习和看笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">huihui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
