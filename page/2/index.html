<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>辉辉的数据库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="学习和看笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="辉辉的数据库">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="辉辉的数据库">
<meta property="og:description" content="学习和看笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="huihui">
<meta property="article:tag" content="notes">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="辉辉的数据库" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">辉辉的数据库</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我们要丈量大地！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Linux防火墙" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/Linux%E9%98%B2%E7%81%AB%E5%A2%99/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T13:08:14.229Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Linux防火墙"><a href="#Linux防火墙" class="headerlink" title="Linux防火墙"></a>Linux防火墙</h2><p><strong>1.防火墙的概念</strong></p>
<p><strong>2.防火墙工具</strong></p>
<p><strong>3.iptables</strong></p>
<p><strong>4.firewalld</strong></p>
<p><strong>5.ntf</strong></p>
<h3 id="1-防火墙概念"><a href="#1-防火墙概念" class="headerlink" title="1.防火墙概念"></a>1.防火墙概念</h3><h4 id="1-安全技术："><a href="#1-安全技术：" class="headerlink" title="1.安全技术："></a>1.安全技术：</h4><ul>
<li>入侵检测系统</li>
<li>入侵防御系统</li>
<li>防火墙</li>
</ul>
<h4 id="2-防火墙分类"><a href="#2-防火墙分类" class="headerlink" title="2.防火墙分类"></a>2.防火墙分类</h4><p>按保护范围划分：</p>
<ul>
<li>主机防火墙：服务范围为当前一台主机</li>
<li>网络防火墙：服务范围为防火墙一侧的局域网</li>
</ul>
<p>按实现方式划分：</p>
<ul>
<li>硬件防火墙：在专用硬件级别实现部分功能的防火墙</li>
<li>软件防火墙：运行于通用硬件平台之上的防火墙的应用软件</li>
</ul>
<p>按网络协议划分：</p>
<ul>
<li>网络层防火墙：OSI模型下四层，又称为包过滤防火墙</li>
<li>应用层防火墙/代理服务器：代理网关，OSI模型七层</li>
</ul>
<p><strong>包过滤防火墙：</strong></p>
<p>网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL），通过检查数据流中每个数据的源地址，目的地址，所用端口号和协议状态等因素，或他们的组合来确定是否允许该数据包通过</p>
<p>优点：对用户来说透明，处理速度快且易于维护</p>
<p>缺点：无法检查应用层数据，如病毒等</p>
<p><strong>应用层防火墙/代理服务型防火墙，也称为代理服务器（Proxy Server）</strong></p>
<p>将所有跨越防火墙的网络通信链路分为两段</p>
<p>内外网用户的访问都是通过代理服务器上的”链接“来实现</p>
<p>优点：在应用层对数据进行检查，比较安全</p>
<p>缺点：增加防火墙的负载</p>
<p>现实生产环境中所使用的防火墙一般都是二者结合体，即先检查网络数据，通过之后再送到应用层去检查。</p>
<h4 id="3-Linux防火墙"><a href="#3-Linux防火墙" class="headerlink" title="3.Linux防火墙"></a>3.Linux防火墙</h4><h5 id="1-Netfilter"><a href="#1-Netfilter" class="headerlink" title="1.Netfilter"></a>1.Netfilter</h5><p>Linux防火墙是由Netfilter组件提供的，Netfilter工作在内核空间，集成在LINux内核中</p>
<h5 id="2-Netfilter的五个钩子函数和报文流向"><a href="#2-Netfilter的五个钩子函数和报文流向" class="headerlink" title="2.Netfilter的五个钩子函数和报文流向"></a>2.Netfilter的五个钩子函数和报文流向</h5><p>Netfilter在内核中选取五个位置放了五个钩子函数，这五个钩子函数向用户开放，用户可以通过一个命令工具向函数中写入规则，工具可以是：iptables firewalld ntfables</p>
<table>
<thead>
<tr>
<th>FUNCTION</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>INPUT</td>
<td></td>
</tr>
<tr>
<td>OUTPUT</td>
<td></td>
</tr>
<tr>
<td>FORWARD</td>
<td></td>
</tr>
<tr>
<td>PRE_ROUTING</td>
<td></td>
</tr>
<tr>
<td>POST_ROUTING</td>
<td></td>
</tr>
</tbody></table>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200915174710914.png" alt="image-20200915174710914"></p>
<p>三种数据流向：</p>
<ul>
<li>流入本机：PRE_ROUTING–&gt;INPUT–&gt;用户进程空间</li>
<li>流出本机：用户进程空间–&gt;OUTPUT–&gt;POST_ROUTING</li>
<li>转发：PRE_ROUTING–&gt;FORWARD–&gt;POST_ROUTING</li>
</ul>
<h5 id="3-iptables组成–-gt-五表五链"><a href="#3-iptables组成–-gt-五表五链" class="headerlink" title="3.iptables组成–&gt;五表五链"></a>3.iptables组成–&gt;五表五链</h5><p><strong>链 chain：</strong></p>
<ul>
<li>内置链：每个内置链对应一个钩子函数 INPUT、OUTPUT、FORWARD、PRE_ROUTING、POST_ROUTING</li>
<li>自定义链：用于对内置链进行扩展或补充，可实现更灵活地规则组织管理机制；只有钩子调用自定义链的时候才能生效。</li>
</ul>
<p><strong>表 table ：filter、nat、mangle、raw、security</strong></p>
<ul>
<li>filter：过滤规则表，根据定义的规则过滤符合条件的数据包，也是iptables的默认表</li>
<li>nat：network address translation 地址转换规则表</li>
<li>mangle：修改数据标记为规则表</li>
<li>raw：关闭启用的连接跟踪机制，加快封包穿越防火墙速度</li>
<li>security：用于强制访问控制（MAC）网络规则，有Linux安全模块实现</li>
</ul>
<p>表的优先级：从大到小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security&gt;raw&gt;mangle&gt;nat&gt;filter</span><br></pre></td></tr></table></figure>

<p>表和链的对应关系</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200915180126223.png" alt="image-20200915180126223"></p>
<p>内核中数据包的传输过程</p>
<ul>
<li>当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去</li>
<li>如果数据包是进入本机的，数据包就会沿着图向下移动，到达INPUT链。数据包到达INPUT链后，任何进程都会受到它。本机上运行的程序可以发送数据包，这些数据包经过OUTPUT链，然后到达POSTROUTING链输出</li>
<li>如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出</li>
</ul>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200915191228621.png" alt="image-20200915191228621"></p>
<h4 id="4-iptables"><a href="#4-iptables" class="headerlink" title="4.iptables"></a>4.iptables</h4><h5 id="1-iptables规则"><a href="#1-iptables规则" class="headerlink" title="1.iptables规则"></a>1.iptables规则</h5><p>规则rule：根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作做出处理，规则在链接上的次序即为其检查时的生效次序</p>
<p><strong>匹配条件</strong>：默认为与条件，同时满足</p>
<p><strong>基本匹配</strong>：IP、端口、TCP的Flags（SYN、ACK、FIN）</p>
<p><strong>扩展匹配</strong>：通过复杂高级功能匹配</p>
<p><strong>处理动作</strong>：称为target，跳转目标</p>
<ul>
<li>内建处理动作：ACCEPT、DROP、REJECT、SNAT、DNAT、MASQUERADE、MARK、LOG</li>
<li>自定义处理动作：自定义chain，利用分类管理复杂情形</li>
</ul>
<p>规则要添加在内置链上才能生效；添加在自定义链上不会生效，还需要把自定义链加到内置链上。</p>
<p>因为本质上这个规则就是利用了那5个钩子函数，也就是5个链。我们写的规则就是这5个函数的参数。</p>
<p>iptables规则添加时的考量点：</p>
<ul>
<li>要实现哪种功能：判断添加在哪张表上</li>
<li>报文流经的路径：判断添加在哪个链上</li>
<li>报文的流向：判断源和目的</li>
<li>匹配规则：业务需要</li>
</ul>
<p><strong>注意一点：Iptables等防火墙工具他们的服务开启和关闭都是在控制链和表，所以关闭了防火墙，其实是清空了防火墙规则，方便我们自己去定义规则</strong></p>
<p>2.iptables用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[root@localdns ~]#iptables --help</span><br><span class="line">iptables v1.4.21</span><br><span class="line"></span><br><span class="line">Usage: iptables -[ACD] chain rule-specification [options]</span><br><span class="line">       iptables -I chain [rulenum] rule-specification [options]</span><br><span class="line">       iptables -R chain rulenum rule-specification [options]</span><br><span class="line">       iptables -D chain rulenum [options]</span><br><span class="line">       iptables -[LS] [chain [rulenum]] [options]</span><br><span class="line">       iptables -[FZ] [chain] [options]</span><br><span class="line">       iptables -[NX] chain</span><br><span class="line">       iptables -E old-chain-name new-chain-name</span><br><span class="line">       iptables -P chain target [options]</span><br><span class="line">       iptables -h (print this help information)</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">Either long or short options are allowed.</span><br><span class="line">  --append  -A chain		Append to chain</span><br><span class="line">  --check   -C chain		Check for the existence of a rule</span><br><span class="line">  --delete  -D chain		Delete matching rule from chain</span><br><span class="line">  --delete  -D chain rulenum</span><br><span class="line">				Delete rule rulenum (1 &#x3D; first) from chain</span><br><span class="line">  --insert  -I chain [rulenum]</span><br><span class="line">				Insert in chain as rulenum (default 1&#x3D;first)</span><br><span class="line">  --replace -R chain rulenum</span><br><span class="line">				Replace rule rulenum (1 &#x3D; first) in chain</span><br><span class="line">  --list    -L [chain [rulenum]]</span><br><span class="line">				List the rules in a chain or all chains</span><br><span class="line">  --list-rules -S [chain [rulenum]]</span><br><span class="line">				Print the rules in a chain or all chains</span><br><span class="line">  --flush   -F [chain]		Delete all rules in  chain or all chains</span><br><span class="line">  --zero    -Z [chain [rulenum]]</span><br><span class="line">				Zero counters in chain or all chains</span><br><span class="line">  --new     -N chain		Create a new user-defined chain</span><br><span class="line">  --delete-chain</span><br><span class="line">            -X [chain]		Delete a user-defined chain</span><br><span class="line">  --policy  -P chain target</span><br><span class="line">				Change policy on chain to target</span><br><span class="line">  --rename-chain</span><br><span class="line">            -E old-chain new-chain</span><br><span class="line">				Change chain name, (moving any references)</span><br><span class="line">Options:</span><br><span class="line">    --ipv4	-4		Nothing (line is ignored by ip6tables-restore)</span><br><span class="line">    --ipv6	-6		Error (line is ignored by iptables-restore)</span><br><span class="line">[!] --protocol	-p proto	protocol: by number or name, eg. &#96;tcp&#39;</span><br><span class="line">[!] --source	-s address[&#x2F;mask][...]</span><br><span class="line">				source specification</span><br><span class="line">[!] --destination -d address[&#x2F;mask][...]</span><br><span class="line">				destination specification</span><br><span class="line">[!] --in-interface -i input name[+]</span><br><span class="line">				network interface name ([+] for wildcard)</span><br><span class="line"> --jump	-j target</span><br><span class="line">				target for rule (may load target extension)</span><br><span class="line">  --goto      -g chain</span><br><span class="line">                              jump to chain with no return</span><br><span class="line">  --match	-m match</span><br><span class="line">				extended match (may load extension)</span><br><span class="line">  --numeric	-n		numeric output of addresses and ports</span><br><span class="line">[!] --out-interface -o output name[+]</span><br><span class="line">				network interface name ([+] for wildcard)</span><br><span class="line">  --table	-t table	table to manipulate (default: &#96;filter&#39;)</span><br><span class="line">  --verbose	-v		verbose mode</span><br><span class="line">  --wait	-w [seconds]	maximum wait to acquire xtables lock before give up</span><br><span class="line">  --wait-interval -W [usecs]	wait time to try to acquire xtables lock</span><br><span class="line">				default is 1 second</span><br><span class="line">  --line-numbers		print line numbers when listing</span><br><span class="line">  --exact	-x		expand numbers (display exact values)</span><br><span class="line">[!] --fragment	-f		match second or further fragments only</span><br><span class="line">  --modprobe&#x3D;&lt;command&gt;		try to insert modules using this command</span><br><span class="line">  --set-counters PKTS BYTES	set the counter during insert&#x2F;append</span><br><span class="line">[!] --version	-V		print package version.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>iptables命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t table]  &#123;-A|-I|-R|-D|...&#125; chain    rule      -j targetname</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-t table 这个可以不写，默认是filter表</span><br><span class="line">-A append 追加一个规则，排在最后一条</span><br><span class="line">-I number 插入到第几行，可以自由选择规则顺序</span><br><span class="line">-R replace 代替哪个链的第几行</span><br><span class="line">-D 删除</span><br><span class="line">-N	new 新建一个链</span><br><span class="line">-E	重命名自定义链</span><br><span class="line">-X：delete，删除自定义的空的规则链 注意一定得是空链，里面不能有规则</span><br><span class="line">-P：policy，设置默认策略；filter表的默认策略是ACCEPT，可以改成DROP，只有这两种</span><br><span class="line">-F：flush 清空指定的规则链</span><br><span class="line">-Z：zero，置零</span><br><span class="line">	(1)匹配到的报文的个数</span><br><span class="line">	(2)匹配到的所有报文的大小之和</span><br></pre></td></tr></table></figure>

<p>例子：拒绝10.0.0.5访问本主机的TCP80端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns named]#iptables -A INPUT -s  10.0.0.5 -p tcp -m multiport --dports 80 -j REJECT</span><br><span class="line">[root@forwarddns named]#iptables -vnL</span><br><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination   </span><br><span class="line">    0     0 REJECT     tcp  --  *      *       10.0.0.5             0.0.0.0&#x2F;0     </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination   </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination   </span><br></pre></td></tr></table></figure>

<p>例子：新建web_chain控制网页访问的几个端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns named]#iptables -N web_chain </span><br><span class="line">[root@forwarddns named]#iptables -E web_chain WEB_CHAIN  #改了个大写名字</span><br><span class="line">[root@forwarddns named]#iptables -A WEB_CHAIN -p tcp -m multiport --dports 80,443,8080 -j REJECT  #此时规则时无法生效的，因为自定义链还没有插入到内置链中</span><br><span class="line">[root@forwarddns named]#iptables -A INPUT -j WEB_CHAIN   #插入链的操作是 —j</span><br><span class="line">[root@forwarddns named]#iptables -vnL</span><br><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">   28  1848 WEB_CHAIN  all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain WEB_CHAIN (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    0     0 REJECT     tcp  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            multiport dports 80,443,8080 reject-with icmp-port-unreachable</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子：删除自定义链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns named]#iptables -F WEB_CHAIN #先把链里的规则清空</span><br><span class="line">[root@forwarddns named]#iptables -D INPUT 1  #删除自定义链和内置链的关联关系</span><br><span class="line">[root@forwarddns named]#iptables -X WEB_CHAIN  #删除自定义链</span><br></pre></td></tr></table></figure>

<p><strong>2.匹配条件</strong></p>
<ul>
<li>基本匹配：通用的，PARAMENTERS</li>
<li>扩展：需加载模块，MATCH EXTENSIONS</li>
</ul>
<p><strong>3.处理动作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-j targetname</span><br><span class="line">ACCEPT </span><br><span class="line">DROP</span><br><span class="line">REJECT</span><br><span class="line">RETURN 返回调用链</span><br><span class="line">REDIRECT 端口重定向</span><br><span class="line">LOG 记录日志</span><br><span class="line">MARK 做防火墙标记</span><br><span class="line">DNAT 目标地址转换</span><br><span class="line">SNAT 源地址转换</span><br><span class="line">MASQUERADE 地址伪装</span><br><span class="line">自定义链  添加到内置链的时候是 ‘-j 自定义链’    </span><br></pre></td></tr></table></figure>

<h5 id="2-iptables的匹配条件"><a href="#2-iptables的匹配条件" class="headerlink" title="2.iptables的匹配条件"></a>2.iptables的匹配条件</h5><p>1.基本匹配条件：无需加载模块，由iptables/netfilter自行提供</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-s source address 源IP地址</span><br><span class="line">-d destination address目标IP地址</span><br><span class="line">-p protocol 协议，tcp,udp,icmp ...  查看&#x2F;etc&#x2F;protocols</span><br><span class="line">-i in-interface 报文流入的接口</span><br><span class="line">-o out-interface 报文流出的接口</span><br></pre></td></tr></table></figure>

<p>2.扩展匹配条件</p>
<p>扩展匹配条件需要加载扩展模块：/usr/lib64/xtables/*.so</p>
<p>扩展模块的查看帮助：man iptables-extensions</p>
<p>扩展匹配条件：</p>
<ul>
<li>隐式扩展</li>
<li>显式扩展</li>
</ul>
<p>3.隐式扩展</p>
<p>iptables在使用-p选项指明了特定的协议时，无需再用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块</p>
<p>tcp协议的扩展选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--sport port 匹配报文源端口</span><br><span class="line">--dport port 匹配报文目的端口</span><br><span class="line">--tcp-flags mask,comp</span><br><span class="line">	mask 需要检查的标示位，用“，”分隔，例如 SYN,FIN,ACK,RST</span><br><span class="line">	COMP 在mask需要检查的标示位中必须为1的那个标识位，比如 SYN,FIN,ACK SYN 这个意思是在这三个标示位里SYN必须是1</span><br></pre></td></tr></table></figure>

<p>udp协议的扩展选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--sport</span><br><span class="line">--dport</span><br></pre></td></tr></table></figure>

<p>icmp协议的扩展选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--icmp-type type&#x2F;code</span><br><span class="line">	0&#x2F;0 echo-reply ICMP应答</span><br><span class="line">	8&#x2F;0 echo-request ICMP请求</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns xtables]#iptables -A INPUT -s 10.0.0.5 -p tcp -m multiport --dport 22,23,24,25 -j REJECT </span><br><span class="line">这里用了显示扩展条件</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns xtables]#iptables -A INPUT -s 10.0.0.7 -p tcp --tcp-flags SYN,ACK,FIN SYN -j REJECT</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns xtables]#iptables -A INPUT -s 10.0.0.7 -p icmp --icmp-type 8 -j REJECT</span><br></pre></td></tr></table></figure>

<p>4.显式扩展及相关模块</p>
<p>显示扩展必须使用-m选项指明要调用的模块，需要手动加载扩展模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m matchname</span><br></pre></td></tr></table></figure>

<p>帮助文档：</p>
<p>centos7,8：man iptables-extensions</p>
<p>centos6：man iptables</p>
<p>4.1multiport扩展</p>
<p>以离散方式定义多端口匹配，最多指定15个端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--sports port</span><br><span class="line">--dports port</span><br><span class="line">--ports port</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns ~]#iptables -A INPUT -s 10.0.0.0&#x2F;24  -p tcp -m multiport --dports 20:22,80 -j ACCEPT </span><br></pre></td></tr></table></figure>

<p>4.2 iprange扩展</p>
<p>指明连续的IP地址范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--src-range from</span><br><span class="line">--dst-range from</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns ~]#iptables -A INPUT -m iprange --src-range 10.0.0.1-10.0.0.10 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>4.3 mac扩展</p>
<p>mac扩展用于指明MAC地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mac-source xx:xx:xx:xx:xx:xx</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns ~]#iptables -A INPUT -m mac --mac-source 00:0c:29:f4:f0:1c -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>4.4 string扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--algo &#123;bm|kmp&#125; 字符串匹配检测算法</span><br><span class="line">	bm:Boyer-Moore</span><br><span class="line">	kmp:Knuth-Pratt-Morris</span><br><span class="line">--from offset 开始偏移</span><br><span class="line">--to offset 结束偏移</span><br><span class="line">--string pattern 要检测的字符串</span><br><span class="line">--hex-string 要检测字符串模式，16进制</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns ~]#iptables -A OUTPUT -p tcp --sport 80 -m string --algo bm --from 62 --string &quot;google&quot; -j REJECT</span><br></pre></td></tr></table></figure>

<p>4.5 time扩展</p>
<p>将根据报文到达的时间与指定的时间范围进行匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--datestart 日期</span><br><span class="line">--datestop 日期</span><br><span class="line">--timestart 时间</span><br><span class="line">--timestop 时间</span><br><span class="line">--monthdays day 每个月的几号</span><br><span class="line">--weekdays day 星期几</span><br><span class="line">--kerneltz 内核时间</span><br></pre></td></tr></table></figure>

<p>4.6 connlimit扩展</p>
<p>根据客户端IP做并发连接数数量匹配</p>
<p>可防止Dos（Denial of service，拒绝服务）攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--connlimit-upto N   #连接的数量小于等于N时匹配</span><br><span class="line">--connlimit-above N  #连接的数量大于N时匹配</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns ~]#iptables -A INPUT -d 10.0.0.0&#x2F;24 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT</span><br></pre></td></tr></table></figure>

<p>4.7 limit扩展</p>
<p>基于收发报文的速率做匹配，令牌桶过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--limit-burst number #前多少个包不限制</span><br><span class="line">--limit #</span><br></pre></td></tr></table></figure>

<p>范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@forwarddns ~]#iptables -A INPUT  -p icmp --icmp-type 8 -m limit --limit 10&#x2F;minute --limit-burst 5 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>4.8 state扩展</p>
<p>state扩展模块，可以根据“连接追踪机制”去检查连接的状态，比较消耗资源</p>
<p>conntrack机制：连接追踪机制，追踪本机上的请求和响应之间的关系</p>
<p>-m state –state NEW/ESTABLISHED/….</p>
<p>NEW:新发出请求；连接追踪信息库中不存在此连接的相关信息条目，因此，将其识别为第一次发出的请求</p>
<p>ESTABLISHED</p>
<p>RELATED</p>
<p>第一个：已经追踪到的并记录下来的连接信息库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;net&#x2F;nf_contrack</span><br></pre></td></tr></table></figure>

<p>第二个：连接追踪功能所能容纳的最大连接数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;netfilter&#x2F;nf_conntrack_max</span><br><span class="line"></span><br><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;nf_conntrack_max</span><br></pre></td></tr></table></figure>

<p>第三个：查看连接追踪有多少条目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;netfilter&#x2F;nf_conntrack_count</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>连接追踪需要加载模块 modprobe nf_conntrack_ipv4</li>
<li>当服务器连接多于最大连接数时，dmesg可以观察到日志：kernel:ip_conntrack:table full,dropping packet错误，并且导致建立TCP连接很慢  tail -f /var/log/message</li>
<li>各种状态的超时后，链接会从表中删除</li>
</ul>
<h5 id="3-target"><a href="#3-target" class="headerlink" title="3.target"></a>3.target</h5><p>自定义链、ACCEPT、REJECT、DROP、RETURN、LOG、SNAT、DNAT、REDIRECT、MASQUERADE</p>
<h5 id="4-规则优化最佳实践："><a href="#4-规则优化最佳实践：" class="headerlink" title="4.规则优化最佳实践："></a>4.规则优化最佳实践：</h5><p>1.安全放行所有入站和出站的状态为ESTABLISHED状态连接，建议放在第一条，效率更高</p>
<p>2.谨慎放行入站的新请求</p>
<p>3.有特殊目的限制访问功能，要在放行规则之前加以拒绝</p>
<p>4.同类规则（访问同一应用，比如：http），匹配范围小的放前面，用于特殊处理</p>
<p>5.不同类的规则，匹配范围大的放在前面，效率更高，就是访问次数多的端口放前面，更加高效</p>
<h5 id="6-iptables规则保存"><a href="#6-iptables规则保存" class="headerlink" title="6.iptables规则保存"></a>6.iptables规则保存</h5><p>使用iptables命令定义的规则，手动删除之前，其生效期限为kernel存活期限</p>
<p>持久保存规则的方法：</p>
<p>防火墙的规则都是保存在文件里的，我们可以把自己配置好的防火墙规则保存成一个文件，然后通过开机自动加载这个文件的方式实现规则的永久保存</p>
<p><strong>centos7之后：</strong></p>
<p>iptables-save</p>
<p>iptables-restore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables-save &gt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br><span class="line">iptables-restore &lt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables #然后把这行命令放到&#x2F;etc&#x2F;rc.local 中，这样每次开机都会执行这行命令，从而达到防火墙规则的永久保存</span><br></pre></td></tr></table></figure>

<p><strong>centos6：</strong></p>
<p>/etc/sysconfig/iptables</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br><span class="line">service iptables restart #centos 6每次启动服务都会重新加载防火墙规则的，只要我们之前手动保存过就可以永久保存了</span><br></pre></td></tr></table></figure>

<h5 id="7-网络防火墙"><a href="#7-网络防火墙" class="headerlink" title="7.网络防火墙"></a>7.网络防火墙</h5><p>iptables/netfilter利用filter表的forward链，可以充当网络防火墙</p>
<p>注意的问题：</p>
<p>​    （1）请求-响应报文均会经由FORWARD链，要注意规则的方向性</p>
<p>​    （2）如果要启用conntrack机制，建议将双方向的状态为ESTABLISHED的报文直接放行</p>
<p>实验：防火墙利用forward链实现内外网的访问控制，同时对路由进行理解</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200917105248428.png" alt="image-20200917105248428"></p>
<p>1.通过标准模块实现内网访问外网，反之禁止</p>
<p>注意先开通转发功能：ip_forward = 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.con</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">iptables -t fliter -A FORWARD -j REJECT  禁止所有的转发</span><br><span class="line">iptables -t filter -A FORWARD -s 10.0.0.0&#x2F;24 -p tcp --dport 80  -j ACCEPT  允许内网向外网的数据传输</span><br><span class="line">iptables -I FORWARD -d 10.0.0.0&#x2F;24 -p tcp --dport 80 -j ACCEPT 允许外网的80端口的回复</span><br></pre></td></tr></table></figure>

<p>2.通过state模块实现内网访问外网所有资源，反之禁止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -j REJECT  禁止所有转发</span><br><span class="line">iptables -I FORWARD -s 10.0.0.0&#x2F;24 -m state --state NEW -j ACCEPT  允许内网向外网建立连接</span><br><span class="line">iptables -I FORWARD  -m state --state ESTABLISHED,RELATED -j ACCEPT  允许所有已经了建立连接的主机之间数据的传输</span><br></pre></td></tr></table></figure>

<p>3.允许内网指定主机被外网访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -j REJECT  禁止所有转发</span><br><span class="line">iptables -I FORWARD -s 10.0.0.0&#x2F;24 -m state --state NEW -j ACCEPT  允许内网向外网建立连接</span><br><span class="line">iptables -I FORWARD  -m state --state ESTABLISHED,RELATED -j ACCEPT  允许所有已经了建立连接的主机之间数据的传输</span><br><span class="line">[root@centos8 network-scripts]#iptables -I FORWARD -d 10.0.0.5&#x2F;32 -p tcp --dport 8080 -j ACCEPT 允许内网的10.0.0.5主机的8080端口被访问</span><br></pre></td></tr></table></figure>

<p>4.一句命令实现内部访问外部，外部禁止访问内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos8 network-scripts]#iptables -R FORWARD 1 -d 10.0.0.0&#x2F;24 -m state --state NEW -j REJECT  利用state模块，实现禁止外部主动与内部通讯</span><br></pre></td></tr></table></figure>

<h3 id="NAT表"><a href="#NAT表" class="headerlink" title="NAT表"></a>NAT表</h3><p>SNAT，DNAT都是TARGET，是跟在“-j”后面的参数</p>
<h4 id="1-SNAT：源地址转换，配合POSTROUTING链，将数据来源的IP地址转换成指定IP"><a href="#1-SNAT：源地址转换，配合POSTROUTING链，将数据来源的IP地址转换成指定IP" class="headerlink" title="1.SNAT：源地址转换，配合POSTROUTING链，将数据来源的IP地址转换成指定IP"></a>1.SNAT：源地址转换，配合POSTROUTING链，将数据来源的IP地址转换成指定IP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s IP -t tcp|udp --dport xxx -j SNAT --to-source extened IP</span><br></pre></td></tr></table></figure>

<h4 id="2-DNAT：目标地址转换，配合PERROUTING链，将数据目的IP地址转换成指定IP"><a href="#2-DNAT：目标地址转换，配合PERROUTING链，将数据目的IP地址转换成指定IP" class="headerlink" title="2.DNAT：目标地址转换，配合PERROUTING链，将数据目的IP地址转换成指定IP"></a>2.DNAT：目标地址转换，配合PERROUTING链，将数据目的IP地址转换成指定IP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d IP -t tcp|udp|icmp --dport xx  -j DNAT --to-destination IP:[port] </span><br></pre></td></tr></table></figure>

<p>PAT：端口IP都转换，可以实现端口的对应关系，比如防火墙上IP的80端口对应内网web服务器IP的8080端口</p>
<p>综合实验：互联网中防火墙的实际NAT使用，SNAT和DNAT配合使用，还有最后在目标主机上配置本地端口转发</p>
<p>配置内外网的访问限制</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200916193650280.png" alt="image-20200916193650280"></p>
<p>​                                                                                    架构图</p>
<p>准备阶段：</p>
<ul>
<li>3个网段：10.0.0.0/8    172.16.0.0/12     192.168.0.0/16        为什么是这三个网段呢？因为这三个网段是私网网段，公网上没有这三种IP。</li>
<li>4台主机</li>
</ul>
<h4 id="3-REDIRECT转发"><a href="#3-REDIRECT转发" class="headerlink" title="3.REDIRECT转发"></a>3.REDIRECT转发</h4><p>REDIRECT，是NAT表的target，通过改变目标IP和端口，将接受的包转发至同一个主机的不同端口，可用于PREROUTING OUTPUT链</p>
<p><strong>适用于本地主机使用，不是让防火墙来使用的！！</strong></p>
<p>REDIRECT选项：</p>
<ul>
<li>–to-ports xx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d ip -t tcp|udp --dport 80 -j REDIRECT --to-ports 80</span><br><span class="line">把原来发给IP：80端口的数据转发给了IP:8080端口</span><br></pre></td></tr></table></figure>



<h4 id="究极实验："><a href="#究极实验：" class="headerlink" title="究极实验："></a>究极实验：</h4><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200917154841708.png" alt="image-20200917154841708"></p>
<p>1.环境准备：包括三个网段、四台主机、开启路由转发功能、配置路由等操作</p>
<ul>
<li>路由转发功能：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward #查看当前主机是否开启路由转发功能，0是关闭，1是开启</span><br><span class="line">vim &#x2F;etc&#x2F;sysctl.conf </span><br><span class="line">添加一行</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">#保存退出</span><br><span class="line">sysctl -p #sysctl 是专门的内核参数命令，包括</span><br><span class="line">-a 显示所有内核参数 </span><br><span class="line">-p 读取 &#x2F;etc&#x2F;sysctl.conf文件中的配置</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置路由：本来只使用SNAT和DNAT的话可以不配置路由，但是为了体现FORWARD的功能，我专门配置了路由，使得 192.168.0.0/24 和 172.16.0.0/24 段能够互联互通。</p>
<ul>
<li>原本不通的原因：！！！ 原本192.168.0.0/24和10.0.0.3都不通，按理说不应该</li>
</ul>
<p>本来从192.168.0.0/24段通过防火墙的192.168.0.710.0.0.7这两个地址是可以找到10.0.0.3的，但是，10.0.0.3找不到192.168.0.0/24网段的路由！！！所以ping不通，所以需要写上去192.168.0.0/24网段的路由</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">配置10.0.0.7的路由：</span><br><span class="line">[root@localhost ~]#route -n  #显示当前路由</span><br><span class="line">Kernel IP routing table</span><br><span class="line">10.0.0.0        0.0.0.0         255.255.255.0   U     102    0        0 eth0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U     101    0        0 eth1</span><br><span class="line">通过实测发现，通过默认路由192.168.0.0&#x2F;24和172.16.0.0&#x2F;24是不能通信的，是因为10.0.0.7不知道怎么去172.16.0.0&#x2F;24网段，10.0.0.3不知道怎么去192.168.0.0&#x2F;24网段，所以要加上路由，告诉他们怎么去</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#ip route add default dev eth0 via 10.0.0.3 #添加默认路由</span><br><span class="line">[root@localhost ~]#route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.0.0.3        0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        0.0.0.0         255.255.255.0   U     102    0        0 eth0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U     101    0        0 eth1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同理配置10.0.0.3的路由</p>
<p>2.filter表的FORWARD链规则配置，目的是控制内外网之间的通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#iptables -t filter -A FORWARD -j REJECT #拒绝所有转发</span><br><span class="line">[root@localhost ~]#iptables -t filter -I FORWARD 1 -s 192.168.0.0&#x2F;24 -m state --state NEW -j ACCEPT #只允许内网向外网发起连接请求，也就是内网可以主动访问外网</span><br><span class="line">[root@localhost ~]#iptables -I FORWARD 1 -m state --state ESTABLISHED,RELATED -j ACCEPT #已经建立了的链接可以被转发</span><br><span class="line">[root@localhost ~]#iptables -I FORWARD 3 -d 192.168.0.100 -p tcp --dport 80 -j ACCEPT #开放内网的部分主机的部分服务给外网访问</span><br><span class="line">下面是配置好的filter的全部规则</span><br><span class="line">[root@localhost ~]#iptables -vnL</span><br><span class="line">Chain INPUT (policy ACCEPT 47 packets, 3128 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    9   896 ACCEPT     all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            state RELATED,ESTABLISHED</span><br><span class="line">    2   136 ACCEPT     all  --  *      *       192.168.0.0&#x2F;24       0.0.0.0&#x2F;0            state NEW</span><br><span class="line">    0     0 ACCEPT     tcp  --  *      *       0.0.0.0&#x2F;0            192.168.0.100        tcp dpt:80</span><br><span class="line">   18  1232 REJECT     all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            reject-with icmp-port-unreachable</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 25 packets, 2348 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination </span><br></pre></td></tr></table></figure>

<p>同理配置另一个公司的防火墙filter表的FORWARD链规则</p>
<p>3.NAT，利用NAT实现私网地址和公网地址的转换，涉及到nat表的PREROUTING和POSTROUTING链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#iptables -t nat -A POSTROUTING -s 192.168.0.0&#x2F;24 -p tcp -j  MASQUERADE</span><br><span class="line">[root@localhost ~]#iptables -t nat -A PREROUTING -d 10.0.0.7 -p tcp --dport 80 -j DNAT --to-destination 192.168.0.100:8080</span><br><span class="line">注意：这里除了设定了DNAT，还设定了端口转换，本来是发送给80端口的，但是转换成了8080端口，所以上面的FORWARD规则就要改一下，把允许外网通过的tcp端口改成8080</span><br></pre></td></tr></table></figure>

<p>4.测试，可以实现</p>
<p>5.防火墙规则保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysconfig]#iptables-save &gt; &#x2F;data&#x2F;iptables.conf</span><br><span class="line">[root@localhost data]#vim iptables.conf</span><br><span class="line">  1 # Generated by iptables-save v1.4.21 on Thu Sep 17 18:45:26 2020</span><br><span class="line">  2 *nat</span><br><span class="line">  3 :PREROUTING ACCEPT [21:2684]</span><br><span class="line">  4 :INPUT ACCEPT [4:916]</span><br><span class="line">  5 :OUTPUT ACCEPT [19:1420]</span><br><span class="line">  6 :POSTROUTING ACCEPT [31:2212]</span><br><span class="line">  7 -A PREROUTING -d 10.0.0.7&#x2F;32 -p tcp -m tcp --dport 80 -j DNAT --to-destination 192.168.0.100:8080</span><br><span class="line">  8 -A POSTROUTING -s 192.168.0.0&#x2F;24 -p tcp -j MASQUERADE</span><br><span class="line">  9 COMMIT</span><br><span class="line"> 10 # Completed on Thu Sep 17 18:45:26 2020</span><br><span class="line"> 11 # Generated by iptables-save v1.4.21 on Thu Sep 17 18:45:26 2020</span><br><span class="line"> 12 *filter</span><br><span class="line"> 13 :INPUT ACCEPT [561:40565]</span><br><span class="line"> 14 :FORWARD ACCEPT [0:0]</span><br><span class="line"> 15 :OUTPUT ACCEPT [363:66484]</span><br><span class="line"> 16 -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"> 17 -A FORWARD -s 192.168.0.0&#x2F;24 -m state --state NEW -j ACCEPT</span><br><span class="line"> 18 -A FORWARD -d 192.168.0.100&#x2F;32 -p tcp -m tcp --dport 8080 -j ACCEPT</span><br><span class="line"> 19 -A FORWARD -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line"> 20 COMMIT</span><br><span class="line"> 21 # Completed on Thu Sep 17 18:45:26 2020  </span><br><span class="line"> 设置为开机自动导入规则，配合开机自动启动防火墙服务，可以实现永久保存规则</span><br><span class="line"> [root@localhost data]#iptables-restore &lt; &#x2F;data&#x2F;iptables.conf</span><br><span class="line"> [root@localhost data]#vim &#x2F;etc&#x2F;rc.local</span><br><span class="line">  1 #!&#x2F;bin&#x2F;bash</span><br><span class="line">  2 # THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line">  3 #</span><br><span class="line">  4 # It is highly advisable to create own systemd services or udev rules</span><br><span class="line">  5 # to run scripts during boot instead of using this file.</span><br><span class="line">  6 #</span><br><span class="line">  7 # In contrast to previous versions due to parallel execution during boot</span><br><span class="line">  8 # this script will NOT be run after all other services.</span><br><span class="line">  9 #</span><br><span class="line"> 10 # Please note that you must run &#39;chmod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local&#39; to ensure</span><br><span class="line"> 11 # that this script will be executed during boot.</span><br><span class="line"> 12 </span><br><span class="line"> 13 touch &#x2F;var&#x2F;lock&#x2F;subsys&#x2F;local</span><br><span class="line"> 14 iptables-restore &lt; &#x2F;data&#x2F;iptables.conf </span><br></pre></td></tr></table></figure>



<p>firewalld</p>
<p>firewall-cmd</p>
<p>zone</p>
<p>nft netfiltertables</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/18/Linux%E9%98%B2%E7%81%AB%E5%A2%99/" data-id="ckhnf9heu000940ut53drhpo8" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LAMP架构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/LAMP%E6%9E%B6%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T13:08:14.221Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LAMP架构"><a href="#LAMP架构" class="headerlink" title="LAMP架构"></a>LAMP架构</h1><h2 id="LAMP介绍"><a href="#LAMP介绍" class="headerlink" title="LAMP介绍"></a>LAMP介绍</h2><p>静态资源和动态资源的区别：在服务器端和客户端看到的是否一样，不在于页面是否能动</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器端看到的页面是一个PHP的时间函数，而客户端看到的就是一个具体的时间</span><br></pre></td></tr></table></figure>

<p><strong>WEB相关语言：</strong></p>
<p>​    客户端技术：html,javascript,css</p>
<p>​    服务器端技术：java,php,javascript(Node.js),jsp,asp,Perl,Ruby</p>
<p>LAMP的工作流程：</p>
<p>主要的流程，动态资源的获取过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端浏览器--&gt;http协议--&gt;Apache&#x2F;Nginx--&gt;动态资源--&gt;PHP&#x2F;Perl&#x2F;Python--&gt;需要数据--&gt;mysql--返回的数据--&gt;PHP&#x2F;Perl&#x2F;Python--&gt;静态资源--&gt;Apache&#x2F;Nginx--&gt;http协议--&gt;客户端浏览器</span><br></pre></td></tr></table></figure>

<p>静态资源就简单些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端浏览器--&gt;http协议--&gt;Apache&#x2F;Nginx--&gt;静态资源--&gt;http协议--&gt;客户端浏览器</span><br></pre></td></tr></table></figure>



<h2 id="CGI和FastCGI"><a href="#CGI和FastCGI" class="headerlink" title="CGI和FastCGI"></a>CGI和FastCGI</h2><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>CGI：Common Gateway Interface，公共网关接口</p>
<p>Web服务在碰到一个动态请求时，会fork一个新的PHP或Perl或C程序进程来处理动态请求，进程完成后会把被处理过的数据发送给Web服务，然后Web服务再把数据发送给用户，进程在完成后结束。如果下次还有动态请求，那么Web服务还会fork新的进程去处理。</p>
<p>CGI可以让一个客户端，从网页浏览器上，通过http协议，向Web服务器上的程序传输数据；</p>
<p>CGI描述了客户端和服务器程序之间传输的标准；</p>
<p>工作流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client--&gt;http协议--&gt;Apache&#x2F;Nginx--&gt;CGI协议--&gt;Application program--&gt;mysql</span><br></pre></td></tr></table></figure>

<p>要想使用CGI，需要这几个部分：</p>
<p>1.定义目录权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">360 &lt;Directory &quot;&#x2F;apps&#x2F;httpd&#x2F;cgi-bin&quot;&gt;</span><br><span class="line">361     AllowOverride None</span><br><span class="line">362     Options None</span><br><span class="line">363     Require all granted</span><br><span class="line">364 &lt;&#x2F;Directory&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.定义httpd的执行脚本别名，只要在这个路径下，httpd就会认为是脚本，并且把执行的结果返回给浏览器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule alias_module&gt;</span><br><span class="line">	ScriptAlias &#x2F;cgi-bin&#x2F; &quot;&#x2F;apps&#x2F;httpd&#x2F;cgi-bin&#x2F;&quot;   </span><br><span class="line">	#ScriptAlias是命令名，是固定的，后面两个都可以改，第一个参数是访问的时候输入什么，第二是你的脚本放在哪个路径了，注意这个路径必须明确定义了可以访问权限，也就是目录权限</span><br><span class="line">&lt;&#x2F;IfModule alias_module&gt;</span><br></pre></td></tr></table></figure>

<p>3.加载了模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">147 &lt;IfModule !mpm_prefork_module&gt;</span><br><span class="line">148     #LoadModule cgid_module modules&#x2F;mod_cgid.so</span><br><span class="line">149 &lt;&#x2F;IfModule&gt;</span><br><span class="line">150 &lt;IfModule mpm_prefork_module&gt;</span><br><span class="line">151     LoadModule cgi_module modules&#x2F;mod_cgi.so</span><br><span class="line">152 &lt;&#x2F;IfModule&gt;</span><br><span class="line">#这里注意是两个判断，根据当前MPM来选择，去掉注释就是加载</span><br></pre></td></tr></table></figure>



<h3 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a><strong>FastCGI</strong></h3><p>fastcgi的方式是，自己就是一个进程，当web服务收到一个动态请求时，不会去fork一个进程，而是直接把内容发送给fastcgi，使用进程之间的通信，但是fastcgi使用了tcp方式，当这个进程处理完数据后 把数据发送给web服务，然后继续等待下一个请求的到来，不退出</p>
<p>工作流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client--&gt;http协议--&gt;Apache&#x2F;Nginx--&gt;fastcgi协议--&gt;fastcgi程序--&gt;mysql</span><br></pre></td></tr></table></figure>

<p>使用fastCGI的方式，如果配合PHP语言，那么使用PHP-FPM程序</p>
<p>我想其他的语言应该也有类似的程序，专门负责处理动态请求</p>
<p><strong>CGI和FASTCGI的区别：</strong></p>
<p>CGI：一次性</p>
<p>FASTCGI：专职，全周期的持续服务</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>PHP的解释器是Zend</p>
<p>PHP的Opcode；</p>
<h3 id="PHP的执行过程："><a href="#PHP的执行过程：" class="headerlink" title="PHP的执行过程："></a>PHP的执行过程：</h3><ul>
<li>Scanning 词法分析，将PHP语言转换为语言片段</li>
<li>Parsing 语义分析，将语言片段转换成简单有意义的表达式</li>
<li>Compilation 编译，把表达式解释成Opcode</li>
<li>Execution 执行，按顺序执行Opcode，实现PHP脚本的功能</li>
</ul>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo()</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="PHP的配置文件：-etc-php-int"><a href="#PHP的配置文件：-etc-php-int" class="headerlink" title="PHP的配置文件：/etc/php.int"></a>PHP的配置文件：<code>/etc/php.int</code></h3><p>让PHP配置文件生效的方式：</p>
<ul>
<li>重启Web服务</li>
<li>重启PHP-FPM</li>
</ul>
<p>配置文件格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[PHP]</span><br><span class="line">directive &#x3D; value</span><br><span class="line">注释是   ;</span><br></pre></td></tr></table></figure>

<p>官方网站中关于配置选项的页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;ini.list.php</span><br><span class="line">https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;ini.core.php #这个是核心选项</span><br></pre></td></tr></table></figure>

<p>PHP建议的设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">expose_php &#x3D; Off #禁止显示PHP版本信息</span><br><span class="line">max_execution #最长执行时间</span><br><span class="line">memory_limit &#x3D; 128M #内存限制使用大小，可以调大</span><br><span class="line">display_errors &#x3D; Off #除了调试，其他时候都应该关闭</span><br><span class="line">display_startup_errors &#x3D; Off #建议关闭</span><br><span class="line">post_max_size &#x3D; 8M #最大上传数据总大小</span><br><span class="line">upload_max_filesize &#x3D; 2M #最大上传文件大小</span><br><span class="line">max_file_uploads &#x3D; 20 #最多上传文件数量</span><br><span class="line">date.timezone &#x3D; Asia&#x2F;Shanghai</span><br><span class="line">short_open_tag &#x3D; On #开启短标签，比如:&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure>

<p>php-fpm</p>
<p>php-mysqlnd</p>
<p>PDO</p>
<p>setfacl</p>
<h2 id="LAMP环境搭建"><a href="#LAMP环境搭建" class="headerlink" title="LAMP环境搭建"></a>LAMP环境搭建</h2><p>两个问题：</p>
<ul>
<li>HTTPD服务和PHP的交互怎么实现？</li>
<li>PHP和MYSQL怎么交互？</li>
</ul>
<h3 id="第一个问题：使用CGI或者FASTCGI"><a href="#第一个问题：使用CGI或者FASTCGI" class="headerlink" title="第一个问题：使用CGI或者FASTCGI"></a>第一个问题：使用CGI或者FASTCGI</h3><p>安装总体上就两种：</p>
<ul>
<li>CGI方式，也就是使用httpd中自带的CGI模块实现动态资源的处理</li>
<li>FASTCGI方式，也就是使用PHP-FPM程序来处理动态资源</li>
</ul>
<p>如果使用CGI，那么就不需要下载PHP-FPM，否则就下载使用</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf -y install httpd php php-fpm mysql-server php-mysqlnd php-json</span><br></pre></td></tr></table></figure>

<h3 id="第二个问题：使用PDO（PHP-Data-Object）扩展连接数据库"><a href="#第二个问题：使用PDO（PHP-Data-Object）扩展连接数据库" class="headerlink" title="第二个问题：使用PDO（PHP Data Object）扩展连接数据库"></a>第二个问题：使用PDO（PHP Data Object）扩展连接数据库</h3><p>使用PDO扩展模块：pdo_mysql.so，这个模块在<code>php-mysqlnd</code>软件中，下载即可</p>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>应用程序出现问题，主要看几个日志去查找问题：</p>
<p>HTTPD的错误日志：<code>/var/log/httpd/error_log</code></p>
<p>PHP-FPM的错误日志：<code>/var/log/php-fpm/www-error.log</code></p>
<p>Linux的错误日志：<code>/var/log/message</code></p>
<p>Mysql的错误日志：<code>/var/log/mysql.log</code></p>
<h3 id="PhpMyAdmin"><a href="#PhpMyAdmin" class="headerlink" title="PhpMyAdmin"></a>PhpMyAdmin</h3><p>PHPMyAdmin是个网页管理数据库的工具</p>
<p>需要的环境：LAMP</p>
<p>依赖包：php-json</p>
<p>安装方法：下载PhpMyAdmin软件包，5.X，然后把解压出来的文件整个放到网站目录下，通过网页访问：<code>http://localhost/phpName/</code>，phpName是文件的名称</p>
<h3 id="PowerDNS-PowerAdmin"><a href="#PowerDNS-PowerAdmin" class="headerlink" title="PowerDNS+PowerAdmin"></a>PowerDNS+PowerAdmin</h3><p>PowerDNS是一个跨平台的DNS服务组件，可以提供网页端的DNS服务，端口也是53</p>
<p>PowerAdmin是一个从网页进行PowerDNS管理的PHP软件</p>
<p>测试DNS服务器的解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig 域名 @DNS服务器地址</span><br></pre></td></tr></table></figure>

<p>需要软件：pdns,pdns-backend-mysql,poweradmin</p>
<p>pdns相关软件之间yum安装即可；</p>
<p>poweradmin去github上下载，地址是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;poweradmin&#x2F;poweradmin.git</span><br></pre></td></tr></table></figure>

<p>依赖包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd php php-devel php-gd php-imap php-ldap php-mysql php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-mhash gettext</span><br><span class="line"></span><br><span class="line">yum -y install php-pear-DB php-pear-MDB2-Driver-mysql</span><br></pre></td></tr></table></figure>

<p>把poweradmin的包之间放到<code>/var/www/html</code>下面</p>
<p>LAMP环境搭好，包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CentOS 7</span><br><span class="line">Apache 2.4.46</span><br><span class="line">Mariadb 5.5.65</span><br><span class="line">PHP 5.4.16</span><br></pre></td></tr></table></figure>

<p>需要在数据库中新建一个用户和数据库给PowerDNS，比如pdns</p>
<p>需要在PowerDNS的配置文件<code>/etc/pdns/pdns.conf</code>中修改和添加内容：launch那行是修改，其他行是添加，一个配置文件中只能有一个launch，user,password,dbname就是在数据库中设定的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">250 launch&#x3D;gmysql</span><br><span class="line">251 gmysql-host&#x3D;127.0.0.1</span><br><span class="line">252 gmysql-user&#x3D;pdns</span><br><span class="line">253 gmysql-password&#x3D;centos</span><br><span class="line">254 gmysql-dbname&#x3D;pdns </span><br></pre></td></tr></table></figure>

<p>然后需要新建一些表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">use pdns;</span><br><span class="line">CREATE TABLE domains (</span><br><span class="line">  id                    INT AUTO_INCREMENT,</span><br><span class="line">  name                  VARCHAR(255) NOT NULL,</span><br><span class="line">  master                VARCHAR(128) DEFAULT NULL,</span><br><span class="line">  last_check            INT DEFAULT NULL,</span><br><span class="line">  type                  VARCHAR(6) NOT NULL,</span><br><span class="line">  notified_serial       INT UNSIGNED DEFAULT NULL,</span><br><span class="line">  account               VARCHAR(40) CHARACTER SET &#39;utf8&#39; DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) Engine&#x3D;InnoDB CHARACTER SET &#39;latin1&#39;;</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX name_index ON domains(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE records (</span><br><span class="line">  id                    BIGINT AUTO_INCREMENT,</span><br><span class="line">  domain_id             INT DEFAULT NULL,</span><br><span class="line">  name                  VARCHAR(255) DEFAULT NULL,</span><br><span class="line">  type                  VARCHAR(10) DEFAULT NULL,</span><br><span class="line">  content               VARCHAR(64000) DEFAULT NULL,</span><br><span class="line">  ttl                   INT DEFAULT NULL,</span><br><span class="line">  change_date           INT DEFAULT NULL,</span><br><span class="line">  prio                  INT DEFAULT NULL,</span><br><span class="line">  disabled              TINYINT(1) DEFAULT 0,</span><br><span class="line">  ordername             VARCHAR(255) BINARY DEFAULT NULL,</span><br><span class="line">  auth                  TINYINT(1) DEFAULT 1,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) Engine&#x3D;InnoDB CHARACTER SET &#39;latin1&#39;;</span><br><span class="line"></span><br><span class="line">CREATE INDEX nametype_index ON records(name,type);</span><br><span class="line">CREATE INDEX domain_id ON records(domain_id);</span><br><span class="line">CREATE INDEX ordername ON records (ordername);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE supermasters (</span><br><span class="line">  ip                    VARCHAR(64) NOT NULL,</span><br><span class="line">  nameserver            VARCHAR(255) NOT NULL,</span><br><span class="line">  account               VARCHAR(40) CHARACTER SET &#39;utf8&#39; NOT NULL,</span><br><span class="line">  PRIMARY KEY (ip, nameserver)</span><br><span class="line">) Engine&#x3D;InnoDB CHARACTER SET &#39;latin1&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE comments (</span><br><span class="line">  id                    INT AUTO_INCREMENT,</span><br><span class="line">  domain_id             INT NOT NULL,</span><br><span class="line">  name                  VARCHAR(255) NOT NULL,</span><br><span class="line">  type                  VARCHAR(10) NOT NULL,</span><br><span class="line">  modified_at           INT NOT NULL,</span><br><span class="line">  account               VARCHAR(40) CHARACTER SET &#39;utf8&#39; DEFAULT NULL,</span><br><span class="line">  comment               TEXT CHARACTER SET &#39;utf8&#39; NOT NULL,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) Engine&#x3D;InnoDB CHARACTER SET &#39;latin1&#39;;</span><br><span class="line"></span><br><span class="line">CREATE INDEX comments_name_type_idx ON comments (name, type);</span><br><span class="line">CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE domainmetadata (</span><br><span class="line">  id                    INT AUTO_INCREMENT,</span><br><span class="line">  domain_id             INT NOT NULL,</span><br><span class="line">  kind                  VARCHAR(32),</span><br><span class="line">  content               TEXT,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) Engine&#x3D;InnoDB CHARACTER SET &#39;latin1&#39;;</span><br><span class="line"></span><br><span class="line">CREATE INDEX domainmetadata_idx ON domainmetadata (domain_id, kind);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE cryptokeys (</span><br><span class="line">  id                    INT AUTO_INCREMENT,</span><br><span class="line">  domain_id             INT NOT NULL,</span><br><span class="line">  flags                 INT NOT NULL,</span><br><span class="line">  active                BOOL,</span><br><span class="line">  published             BOOL DEFAULT 1,</span><br><span class="line">  content               TEXT,</span><br><span class="line">  PRIMARY KEY(id)</span><br><span class="line">) Engine&#x3D;InnoDB CHARACTER SET &#39;latin1&#39;;</span><br><span class="line"></span><br><span class="line">CREATE INDEX domainidindex ON cryptokeys(domain_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE tsigkeys (</span><br><span class="line">  id                    INT AUTO_INCREMENT,</span><br><span class="line">  name                  VARCHAR(255),</span><br><span class="line">  algorithm             VARCHAR(50),</span><br><span class="line">  secret                VARCHAR(255),</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) Engine&#x3D;InnoDB CHARACTER SET &#39;latin1&#39;;</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">Using this SQL causes Mysql to create foreign keys on your database. This will</span><br><span class="line">make sure that no records, comments or keys exists for domains that you already</span><br><span class="line">removed. This is not enabled by default, because we&#39;re not sure what the</span><br><span class="line">consequences are from a performance point of view. If you do have feedback,</span><br><span class="line">please let us know how this affects your setup.</span><br><span class="line"></span><br><span class="line">Please note that it&#39;s not possible to apply this, before you cleaned up your</span><br><span class="line">database, as the foreign keys do not exist.</span><br><span class="line">*&#x2F;</span><br><span class="line">ALTER TABLE records ADD CONSTRAINT &#96;records_domain_id_ibfk&#96; FOREIGN KEY (&#96;domain_id&#96;) REFERENCES &#96;domains&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE;</span><br><span class="line">ALTER TABLE comments ADD CONSTRAINT &#96;comments_domain_id_ibfk&#96; FOREIGN KEY (&#96;domain_id&#96;) REFERENCES &#96;domains&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE;</span><br><span class="line">ALTER TABLE domainmetadata ADD CONSTRAINT &#96;domainmetadata_domain_id_ibfk&#96; FOREIGN KEY (&#96;domain_id&#96;) REFERENCES &#96;domains&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE;</span><br><span class="line">ALTER TABLE cryptokeys ADD CONSTRAINT &#96;cryptokeys_domain_id_ibfk&#96; FOREIGN KEY (&#96;domain_id&#96;) REFERENCES &#96;domains&#96; (&#96;id&#96;) ON DELETE CASCADE ON UPDATE CASCADE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在看看LAMP的几个程序都正常不正常，正常了就都重启一遍，然后从网页访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;poweradmin&#x2F;</span><br></pre></td></tr></table></figure>

<p>一路配置就完事了，这里面的DNS的配置知识有些遗忘了，但大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SOA 记录  </span><br><span class="line">NS  记录</span><br><span class="line">A  记录</span><br><span class="line">完事</span><br><span class="line">		</span><br><span class="line">lv.dota		SOA		ns1.lv.dota 2020102904 28800 7200 604800 86400</span><br><span class="line">lv.dota 	NS		10.0.0.11	</span><br><span class="line">www.lv.dota  A		10.0.0.119</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">SOA：起始授权机构记录 </span><br><span class="line">ns1.lv.dota 域名服务器</span><br><span class="line">2020102904 编号，这个值很重要，他的改变才真正意味着DNS进行了改变</span><br><span class="line">28800 刷新间隔</span><br><span class="line">7200 重新尝试时间</span><br><span class="line">604800 过期时间</span><br><span class="line">86400 negative TTL</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201029161829297.png" alt="image-20201029161829297"></p>
<h3 id="Discuz"><a href="#Discuz" class="headerlink" title="Discuz!"></a>Discuz!</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="PHP加速器"><a href="#PHP加速器" class="headerlink" title="PHP加速器"></a>PHP加速器</h2><p>不是每次进行完整的解释过程，而是保存Opcode，这样能快点</p>
<p>Opcache通过将PHP脚本中预编译的字节码存储到共享内存中来提升PHP的性能，存储预编译字节码的好处就是省去了每次加载和解析PHP脚本的开销，PHP5.5之后默认绑定Opcache扩展。</p>
<p>安装方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dnf -y install php-opcache</span><br><span class="line">然后重启一下php-fpm就行了，因为它下载下来的包里面有一个php的子配置文件</span><br><span class="line">&#x2F;etc&#x2F;php.d&#x2F;10-opcache.ini</span><br><span class="line">里面默认启用了opcache</span><br><span class="line">opcache.enable&#x3D;1</span><br></pre></td></tr></table></figure>



<h2 id="处理动态资源的独立软件：PHP-FPM"><a href="#处理动态资源的独立软件：PHP-FPM" class="headerlink" title="处理动态资源的独立软件：PHP-FPM"></a>处理动态资源的独立软件：PHP-FPM</h2><p>协议：fastcgi</p>
<p>在Centos8上，直接安装php就行，跟安装php-fpm是一样的 </p>
<p>php-fpm的套接字方式，对httpd服务的版本有要求，要2.4.7以上才行！</p>
<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;php-fpm.conf</span><br><span class="line">&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf</span><br></pre></td></tr></table></figure>



<p>sock文件的权限问题</p>
<p>写出一个脚本，LAMP加一个WordPress</p>
<p>编译安装PHP，APACHE</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/18/LAMP%E6%9E%B6%E6%9E%84/" data-id="ckhnf9he9000040uth2dmenoi" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/Docker/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T13:08:14.205Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="容器管理-Docker"><a href="#容器管理-Docker" class="headerlink" title="容器管理 Docker"></a>容器管理 Docker</h1><h2 id="Build-Ship-and-Run-Any-App-Anywhere"><a href="#Build-Ship-and-Run-Any-App-Anywhere" class="headerlink" title="Build,Ship and Run Any App,Anywhere"></a>Build,Ship and Run Any App,Anywhere</h2><p>重点：</p>
<ul>
<li>容器镜像制作和管理，超级重点！！！</li>
<li>镜像仓库管理，超级重点！！！</li>
<li>docker基本操作</li>
<li>数据卷管理</li>
<li>网络管理</li>
<li>容器编排管理工具 docker compose</li>
<li>容器资源限制</li>
<li>可视化容器管理工具Portainer</li>
</ul>
<h1 id="1-Docker介绍和基础操作"><a href="#1-Docker介绍和基础操作" class="headerlink" title="1 Docker介绍和基础操作"></a>1 Docker介绍和基础操作</h1><h2 id="1-1-Docker-介绍"><a href="#1-1-Docker-介绍" class="headerlink" title="1.1 Docker 介绍"></a>1.1 Docker 介绍</h2><h3 id="1-1-1-容器介绍"><a href="#1-1-1-容器介绍" class="headerlink" title="1.1.1 容器介绍"></a>1.1.1 容器介绍</h3><p>Docker是一个可以将应用程序及其依赖打包到几乎可以在任何服务器上运行的容器的工具</p>
<p>KVM中每个虚拟机有自己的内核，而所有容器使用内核</p>
<p>容器：共用一个内核，同时可以在容器之间保持较好的隔离性</p>
<p>每个容器间是互相隔离的，每个容器内都有一个属于自己的独立的文件系统、独立的进程、独立的用户和用户组、独立的网络空间等，这是容器之间彼此不相互影响的原因</p>
<p>Docker、虚拟机、物理主机的关系</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201112211529434.png" alt="image-20201112211529434"></p>
<p>相比虚拟机，容器的好处是：</p>
<ul>
<li>资源利用率高，因为减少了每个个体中内核的资源消耗。一台物理机能开十几个虚拟机的话，跑容器能跑上百个</li>
<li>启动速度快，可以在几秒内完成</li>
<li>占用空间小，一般以MB计算，而虚拟机得以GB计算大小</li>
<li>集成性好，和CI/CD（持续集成/持续部署）相关技术结合性好，实现打包镜像发布测试一键运行</li>
</ul>
<h3 id="1-1-2-容器组成"><a href="#1-1-2-容器组成" class="headerlink" title="1.1.2 容器组成"></a>1.1.2 容器组成</h3><ul>
<li>docker主机，物理机或虚拟机，一般称为宿主机</li>
<li>docker服务端，Docker守护进程，运行docker容器</li>
<li>docker客户端，使用docker命令和其他工具调用dockerAPI</li>
<li>docker镜像，实例的模板，本质上是一些文件的集合</li>
<li>docker仓库，保存镜像的仓库，有官方仓库，也可以建立私有仓库</li>
<li>docker容器，容器就是对镜像进行复制，然后运行里面的程序后生成的进程</li>
</ul>
<p>namespace：实现隔离的技术</p>
<p>namespace在内核层实现；一些不同类型的命名空间被部署在内核内，各个Docker容器运行在同一个Docker主进程并且共用一个宿主机系统内核；</p>
<p>MNT Namespace：Mount</p>
<p>让每个容器都有自己的根目录</p>
<p>宿主机使用chroot技术把容器锁定到一个制定的运行目录里面，容器在这个目录里面有自己的根目录，但是不能访问宿主机的目录</p>
<p>IPC Namespace：Inter-Process Communication</p>
<p>让每个容器内的进程之间可以通信</p>
<p>UTS Namespace：UNIX Timesharing System</p>
<p>UTS namespace包含了运行内核的名称、版本、底层体系结构类型等信息，用于系统标识，其中包括了主机名hostname和域名domainname，它让每个容器有自己的主机标识，包括主机名和域名</p>
<p>PID Namespace：Process Identification</p>
<p>Linux系统中，有一个PID为1的进程(init/systemd)是其他所有进程的父进程，那么在每个容器内也要有一个父进程来管理其下属的子进程，那么多个容器的进程通过PID namespace进程隔离。比如PID编号重复、容器内的主进程生成与回收子进程等。让每个容器内都有自己的进程、子进程</p>
<p>NET Namespace：Network             </p>
<p>问题：docker0就一个吗？是的 </p>
<p>是不是所有容器桥接到docker0？是的</p>
<p>Docker使用network namespace启动一个vethX接口，这样容器将拥有自己的桥接IP地址，通常是docker0，而docker0实质就是Linux的虚拟网桥，网桥在OSI七层模型的数据链路层的网络设备，通过MAC地址对网络进行划分，并且在不同网络直接传递数据</p>
<p>每个容器有自己的网卡、监听端口、TCP/IP协议栈</p>
<p>User Namespace：User</p>
<p>User Namespace运行在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户UID和GID，只是会把用户的作用范围限制在每个容器内。</p>
<p>让每个容器内有自己的用户和用户组</p>
<p>对内核要求高，因此使用Ubuntu更多了，Ubuntu内核版本高</p>
<table>
<thead>
<tr>
<th>隔离类型</th>
<th>功能</th>
<th>系统调用参数</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>MNT Namespace</td>
<td>提供磁盘挂载点和文件系统的隔离能力</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>提供进程间通信的隔离能力，包括信号量，消息队列和共享内存</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>提供内核，主机名和域名隔离能力</td>
<td>CLONE_NEWTUS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>提供进程隔离能力</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Net Namespace</td>
<td>提供网络隔离能力，包括网络设备，网络栈，端口等</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>提供用户隔离能力，包括用户和组</td>
<td>CLONE_NEWUSER</td>
<td>3.8</td>
</tr>
</tbody></table>
<p><strong>进程：</strong></p>
<p>每当运行一个容器，体现在宿主机上就是containerd进程又开启了一个containerd-shim子进程和一些线程</p>
<p>容器内的进程体现在宿主机上就是containerd进程的子进程containerd-shim的一个线程</p>
<p>容器内进程号和宿主机是相互独立的</p>
<p>每当运行一个需要进行主机间网络通信的容器（提供服务，需要开端口的容器），那么体现在宿主机上就是containerd又开启一个containerd-shim子进程，并且，docker守护进程dockerd也开启了一个子进程docker-proxy和一些线程</p>
<p><strong>文件系统：</strong></p>
<p>镜像文件本身存放在宿主机上</p>
<p>运行容器实际上就是从镜像文件拷贝一份，然后运行这些文件中的程序</p>
<p>容器内有自己的文件系统，与宿主机相对独立，比如容器有自己的根目录</p>
<p>但是容器内的文件本质上还是存储在宿主机上，文件一般在<code>/var/lib/docker/overlay2/</code>下，需要根据容器ID号去寻找对应的文件夹</p>
<p><strong>网络：</strong></p>
<p>docker的网络是这样的：</p>
<p>开启dockerd（docker守护进程）后，宿主机会多一个网卡，docker0，这个网卡一般的网段是<code>172.17.0.0/16</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:f3:33:fc:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1&#x2F;16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:f3ff:fe33:fc01&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>这是一个提供给容器的桥接网卡</p>
<p>每当运行一个容器，宿主机上就会看到多了一个网卡，这个网卡代表容器的网卡，它桥接与docker0网卡上，然后通过docker0网卡与宿主机通信</p>
<p>docker0网卡与宿主机之间还有宿主机的防火墙（内核Netfilter模块提供的五个钩子函数），通过防火墙上配置NAT表的SNAT规则，可以实现让容器处于NAT网络下对外界网络主机进行访问；通过设置DNAT规则（容器和宿主机之间的端口映射）实现让外界网络主机访问容器服务的功能</p>
<p>docker0网桥的观察，此时运行着两个容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242f333fc01       no              veth224b0e8</span><br><span class="line">                                                        veth64218fc</span><br><span class="line">root@ubuntu1804:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1&#x2F;128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 00:0c:29:4c:15:a7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.55&#x2F;24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe4c:15a7&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:f3:33:fc:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1&#x2F;16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:f3ff:fe33:fc01&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">11: veth64218fc@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link&#x2F;ether 7e:7a:14:d9:84:96 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::7c7a:14ff:fed9:8496&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">13: veth224b0e8@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link&#x2F;ether d6:59:58:b7:e6:1a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::d459:58ff:feb7:e61a&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>正好，两个容器，两个新增网卡，网桥上也看到两个桥接网卡</p>
<p>大概的连接图</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113202046662.png" alt="image-20201113202046662"></p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113202145345.png" alt="image-20201113202145345"></p>
<p>宿主机的nat表规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# iptables -t nat -vnL</span><br><span class="line">Chain PREROUTING (policy ACCEPT 41 packets, 8332 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">   30  1505 DOCKER     all  --  *      *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 41 packets, 8332 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 117 packets, 8872 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">    0     0 DOCKER     all  --  *      *       0.0.0.0&#x2F;0           !127.0.0.0&#x2F;8          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 136 packets, 9860 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">    0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0&#x2F;16        0.0.0.0&#x2F;0     </span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.2           172.17.0.2           tcp dpt:80</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       172.17.0.3           172.17.0.3           tcp dpt:4000</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination      </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0       </span><br><span class="line">    2   104 DNAT       tcp  --  !docker0 *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:32768 to:172.17.0.2:80</span><br><span class="line">   19   988 DNAT       tcp  --  !docker0 *       0.0.0.0&#x2F;0            0.0.0.0&#x2F;0            tcp dpt:4000 to:172.17.0.3:4000</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Control groups：</strong></p>
<p>对容器使用资源的限制，包括CPU、内存、磁盘、网络带宽等</p>
<p>Linux Control Groups，Linux内核功能</p>
<p>通过查看/boot/config-xxx文件来看</p>
<p><strong>容器管理技术</strong></p>
<p>LXC，Linux Container，最初使用，现在不怎么使用了</p>
<p>docker，增强版的LXC</p>
<p>pouch，阿里巴巴研究的容器技术</p>
<p>podman，centos8集成的功能，pod manager tool，与Kubernetes关系紧密</p>
<p><strong>docker与镜像</strong></p>
<p>docker的镜像是分层的，镜像底层为库文件，只能读，叫做只读层，镜像被运行为容器后，多了一个读写层，其写入的数据会复制到宿主机上对应容器的目录，但是容器被删除后目录也会被删除；</p>
<p>docker的启动需要一个外部模板，也称为镜像；</p>
<p>镜像可以被修改后再次保存成另外一个镜像；</p>
<p>一个镜像可以被启动为多个容器；</p>
<p><strong>docker的优点和不足</strong></p>
<p>优点：</p>
<p>一次打包，到处执行；</p>
<p>资源利用率高；</p>
<p>快速部署；</p>
<p>快速迁移；</p>
<p>高内聚、低耦合；</p>
<p>不足：</p>
<p>各个容器公用一个内核，隔离的不如虚拟机彻底；</p>
<p>进入容器、查看容器进程比较困难；</p>
<p>容器为了节省空间，很多工具都不装，但是如果要进入容器内进行操作还需要安装工具；</p>
<p><strong>容器的核心技术</strong></p>
<p>OCI：Open Container Initiative</p>
<p>容器规范：runtime spec和image format spec</p>
<p>遵守上面的两个规范就可以保证容器的可移植性和相互可操作性</p>
<p>runtime：runtime是真正运行容器的地方，docker容器技术的一个模块</p>
<p>runtime的类型有几个，但是目前docker使用的是runc</p>
<p><strong>容器管理工具</strong></p>
<p>管理runc的工具是docker engine，docker engine包括daemon和cli两部分，docker就是指docker engine</p>
<p><strong>容器定义工具</strong></p>
<p>docker image，docker容器的模板，runtime依据docker image创建容器</p>
<p>dockerfile，包含N个命令的文本文件，通过dockerfile创建出docker image</p>
<p>ACI，APP Container Image，与docker image类似</p>
<p><strong>镜像仓库 Registry</strong></p>
<p>docker hub，docker官方仓库</p>
<p>Harbor，VMware提供的自带web界面、自带认证功能的镜像私有仓库，有不少公司在用</p>
<p><strong>容器编排工具</strong></p>
<p>当多个容器在多个主机运行的时候，单独管理容器是相当复杂而且很容易出错，而且也无法实现某一台主机宕机后容器自动迁移到其他主机从而实现高可用的目的，而且也无法实现动态伸缩的功能，因此需要一种工具可以实现统一管理、动态伸缩、故障自愈、批量执行等功能，实现这种功能的工具就是容器编排工具</p>
<p>容器编排通常包括容器管理、调度、集群定义和服务发现等功能</p>
<p>有这么几种容器编排工具</p>
<ul>
<li>Docker compose，docker官方实现单机容器编排的工具</li>
<li>Docker swarm，docker官方开发的容器编排引擎</li>
<li>Kubernetes，Google开发的容器编排工具，事实上的标准</li>
</ul>
<p><strong>容器依赖的技术</strong></p>
<p>容器网络：</p>
<p>docker自带的网络docker network仅支持管理单机的容器网络，当多个主机运行时需要使用第三方开源网络，例如：calico、flannel等</p>
<p>服务发现：</p>
<p>容器的动态扩容特性决定了容器IP也会随之变化，因此需要有一种机制开源自动识别并将用户请求动态转发到新创建的容器上，kubernetes自带服务发现功能，需要结合kube-dns服务解析内部域名</p>
<p>容器监控：</p>
<p>可以通过原生的命令docker ps/top/stats查看容器运行状态，另外也可以使用Prometheus、heapster等监控工具</p>
<p>数据管理：</p>
<p>容器的动态迁移会导致其在不同的Host之间迁移，因此如何保证与容器相关的数据也能随之迁移或随时访问，可以使用逻辑卷/存储挂载等方式解决</p>
<p>日志收集：</p>
<p>docker原生的docker logs，但是容器内部的日志需要通过ELK等专门的日志收集分析和展示工具进行处理</p>
<p>docker是一种容器的管理工具</p>
<p>docker是使用GO语言开发</p>
<p>docker存储引擎：overlay</p>
<p>联合挂载文件系统：aufs</p>
<p>ABI：可执行应用程序接口，Application Binary Interface，也就是执行程序的统一接口</p>
<p>API：可编程应用程序接口，Application Program Interface，也即是编写程序的统一接口</p>
<h2 id="1-2-Docker安装及基础命令介绍"><a href="#1-2-Docker安装及基础命令介绍" class="headerlink" title="1.2 Docker安装及基础命令介绍"></a>1.2 Docker安装及基础命令介绍</h2><h3 id="1-2-1-安装docker"><a href="#1-2-1-安装docker" class="headerlink" title="1.2.1 安装docker"></a>1.2.1 安装docker</h3><p>基本上所有系统都要自己去网上找资源下载安装，docker版本要跟k8s配合</p>
<p>kubernetes的github</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://github.com/kubernetes/kubernetes/blob/v1.17.2/CHANGELOG-1.17.md</span></span><br></pre></td></tr></table></figure>

<p>docker的文档：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://docs.docker.com/</span></span><br></pre></td></tr></table></figure>

<p>docker的版本是一个季度更新一次，例如17.09表示2017年9月份发布</p>
<p>docker的github名字是moby</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://github.com/moby/moby</span></span><br></pre></td></tr></table></figure>

<p>docker两个包：docker-ce,docker-ce-cli，一个服务，一个客户端工具</p>
<p>docker command 就是客户端命令</p>
<p>可以通过网络资源下载或者二进制安装</p>
<p>阿里云的docker安装文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;developer.aliyun.com&#x2F;mirror&#x2F;docker-ce?spm&#x3D;a2c6h.13651102.0.0.3e221b11guHCWE</span><br></pre></td></tr></table></figure>



<p>Ubuntu</p>
<p>阿里云上在ubuntu上安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># step 2: 安装GPG证书</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><span class="line"><span class="comment"># Step 4: 更新并安装Docker-CE</span></span><br><span class="line">sudo apt-get -y update</span><br><span class="line"><span class="comment"># Step 5: 选择docker-ce的版本并安装</span></span><br><span class="line">apt list docker-ce -a</span><br><span class="line">apt install docker-ce=5:19.03.13~3-0~ubuntu-bionic</span><br></pre></td></tr></table></figure>

<p>docker删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt purge docker-ce</span><br><span class="line">rm -f &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>



<p>Centos</p>
<p>Centos6不建议安装docker</p>
<p>Centos7下载docker要从官方源或者镜像源站点下载安装</p>
<p>Centos8上有新技术podman代替docker，如果要安装docker，那么需要把阿里云centos8的docker连接写到/etc/yum.repos.d/下面</p>
<p>综合来看，docker更适合在Ubuntu上跑，centos系列的话，使用centos7来跑docker</p>
<p>centos7安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># Step 2: 添加软件源信息</span></span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># Step 3: 更新并安装Docker-CE</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"><span class="comment"># 如果要选择不同版本的软件，那么加上--showduplicates选项</span></span><br><span class="line">yum install docker-ce --showduplicates</span><br><span class="line"></span><br><span class="line">中间centos7需要额外安装一个软件</span><br><span class="line">wget http://mirror.centos.org/centos/7/extras/x86_64/Packages/container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm</span><br><span class="line">yum install container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: 开启Docker服务</span></span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

<p>centos8下载安装docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo</span><br><span class="line">  1 [docker]</span><br><span class="line">  2 name&#x3D;docker</span><br><span class="line">  3 baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;8&#x2F;x86_64&#x2F;stable&#x2F;</span><br><span class="line">  4 gpgcheck&#x3D;0</span><br><span class="line">  5 enable&#x3D;1</span><br><span class="line">dnf repolist</span><br><span class="line">dnf install docker-ce -y</span><br></pre></td></tr></table></figure>



<p>当上网下载不合适的时候，使用docker的二进制包进行安装，下面的二进制包的下载地址</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是官方提供的二进制安装文档，docker官方文档也有镜像，可以下载下来跑成容器，然后本地浏览文档</span><br><span class="line">docker run -it -d -p 4000:4000 docs/docker.github.io:latest</span><br><span class="line"></span><br><span class="line">官方文档</span><br><span class="line">https://docs.docker.com/engine/install/binaries/</span><br></pre></td></tr></table></figure>



<p>二进制安装的要求：</p>
<p>Before attempting to install Docker from binaries, be sure your host machine meets the prerequisites:</p>
<ul>
<li>A 64-bit installation</li>
<li>Version 3.10 or higher of the Linux kernel. The latest version of the kernel available for your platform is recommended.</li>
<li><code>iptables</code> version 1.4 or higher</li>
<li><code>git</code> version 1.7 or higher</li>
<li>A <code>ps</code> executable, usually provided by <code>procps</code> or a similar package.</li>
<li><a target="_blank" rel="noopener" href="http://tukaani.org/xz/">XZ Utils</a> 4.9 or higher</li>
<li>A <a target="_blank" rel="noopener" href="https://github.com/tianon/cgroupfs-mount/blob/master/cgroupfs-mount">properly mounted</a> <code>cgroupfs</code> hierarchy; a single, all-encompassing <code>cgroup</code> mount point is not sufficient. See Github issues <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/2683">#2683</a>, <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/3485">#3485</a>, <a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/4568">#4568</a>).</li>
</ul>
<p>安装步骤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载二进制包</span></span><br><span class="line">[root@centos8 src]<span class="variable">$wget</span> https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64/docker-19.03.13.tgz</span><br><span class="line"><span class="comment"># 解压，注意.tgz的包需要先gzip -d 解压，然后使用tar解包</span></span><br><span class="line">gzip -d docker-19.03.13.tgz</span><br><span class="line">tar xf docker-19.03.13.tar</span><br><span class="line"><span class="comment"># 把解压解包出来的docker文件夹下的可执行文件放到PATH变量中某一个目录下</span></span><br><span class="line">cp docker/* /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"><span class="comment"># 执行dockerd就可以开启docker守护进程了</span></span><br><span class="line">docker &amp;</span><br><span class="line"><span class="comment"># 关闭的时候杀只能杀进程关闭</span></span><br><span class="line"><span class="built_in">kill</span> `pidof dockerd`</span><br><span class="line"><span class="comment"># 编写service文件，注意一共有三个</span></span><br><span class="line">第一个，docker.service</span><br><span class="line">[root@centos8 system]<span class="variable">$grep</span> -Ev <span class="string">&quot;^#|^$&quot;</span> docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">BindsTo=containerd.service</span><br><span class="line">After=network-online.target firewalld.service containerd.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=docker.socket</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">TasksMax=infinity</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[root@centos8 system]<span class="variable">$grep</span> -Ev <span class="string">&quot;^#|^$&quot;</span> docker.socket</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Socket <span class="keyword">for</span> the API</span><br><span class="line">PartOf=docker.service</span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=/var/run/docker.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">SocketUser=root</span><br><span class="line">SocketGroup=docker</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br><span class="line"></span><br><span class="line">[root@centos8 system]<span class="variable">$grep</span> -Ev <span class="string">&quot;^#|^$&quot;</span> containerd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=containerd container runtime</span><br><span class="line">Documentation=https://containerd.io</span><br><span class="line">After=network.target local-fs.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe overlay</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/containerd</span><br><span class="line">Type=notify</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=always</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">TasksMax=infinity</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">然后重新加载一下systemd，启动服务就可以了</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-docker配置国内加速器"><a href="#1-2-2-docker配置国内加速器" class="headerlink" title="1.2.2 docker配置国内加速器"></a>1.2.2 docker配置国内加速器</h3><p>去阿里云注册一个账号，然后获得一个阿里云的docker镜像加速地址，之后把这个内容写到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line"> &#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>docker默认服务使用socket文件，但是可以修改为监听端口，修改的方法有两种</p>
<p>1.修改/etc/docker/daemon.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;, &quot;tcp:&#x2F;&#x2F;127.0.0.1:2375&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.修改/lib/systemd/syste/docker.service文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F; -H tcp:&#x2F;&#x2F;127.0.0.1:2375</span><br></pre></td></tr></table></figure>

<p>脚本：</p>
<p>centos7一键安装docker脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Centos7一键安装docker同时配置阿里云的镜像加速器脚本</span><br><span class="line"># 采用的方法是使用阿里云的Yum源</span><br><span class="line"></span><br><span class="line"># 调用Linux系统自带函数action</span><br><span class="line">source &#x2F;etc&#x2F;init.d&#x2F;functions</span><br><span class="line"></span><br><span class="line"># 定义变量</span><br><span class="line">DOWNLOAD_DIR&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;src&quot;</span><br><span class="line">VERSION&#x3D;&quot;19.03.13-3.el7&quot;</span><br><span class="line"></span><br><span class="line"># 定义函数</span><br><span class="line">function install_docker() &#123;</span><br><span class="line">    echo &quot;开始安装docker，请稍等&quot;</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">    yum install -y yum-utils device-mapper-persistent-data lvm2 &amp;&gt;&#x2F;dev&#x2F;null || &#123; action &quot;必要工具下载失败，请检查yum源&quot; false;exit 9; &#125;</span><br><span class="line">    # Step 2: 添加软件源信息</span><br><span class="line">    yum-config-manager --add-repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    # Step 3: 更新并安装Docker-CE</span><br><span class="line">    yum makecache fast &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    # 中间centos7需要额外安装一个包</span><br><span class="line">    cd $&#123;DOWNLOAD_DIR&#125;</span><br><span class="line">    wget -q http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;7&#x2F;extras&#x2F;x86_64&#x2F;Packages&#x2F;container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm</span><br><span class="line">    yum -y install container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    yum -y install docker-ce-$&#123;VERSION&#125; &amp;&gt;&#x2F;dev&#x2F;null &amp;&amp; action &quot;docker-ce-$&#123;VERSION&#125;安装成功！&quot; || &#123; action &quot;安装docker-ce-$&#123;VERSION&#125;失败&quot; false;exit 9; &#125;</span><br><span class="line">    # 如果要选择不同版本的软件，那么加上--showduplicates选项</span><br><span class="line">    # yum list docker-ce --showduplicates</span><br><span class="line">    # Step 4: 开启Docker服务</span><br><span class="line">    systemctl enable --now docker &amp;&amp; action &quot;Docker守护进程已开启！&quot; || &#123; action &quot;Docker守护进程启动失败&quot; false;exit 9; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function speedUp() &#123;</span><br><span class="line">    tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"># 调用函数</span><br><span class="line">install_docker</span><br><span class="line">speedUp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Ubuntu一键安装docker脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Ubuntu一键安装docker并且配置阿里云加速的脚本</span><br><span class="line"></span><br><span class="line"># 定义变量</span><br><span class="line">VERSION&#x3D;&quot;5:19.03.13~3-0~ubuntu-&quot;</span><br><span class="line">CLASS&#x3D;&#96;lsb_release -cs&#96;</span><br><span class="line"></span><br><span class="line"># 定义函数</span><br><span class="line">function install_docker() &#123;</span><br><span class="line">	echo &quot;开始安装docker&quot;</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">    apt update &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    apt -y install apt-transport-https ca-certificates curl software-properties-common &amp;&gt;&#x2F;dev&#x2F;null || &#123; echo &quot;安装基础包失败，请检查apt源&quot;;exit 9; &#125;</span><br><span class="line">    # step 2: 安装GPG证书</span><br><span class="line">    curl -fsSL https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br><span class="line">    # Step 3: 写入软件源信息</span><br><span class="line">    add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot; </span><br><span class="line">    # Step 4: 更新并安装Docker-CE</span><br><span class="line">    apt -y update &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    # Step 5: 选择docker-ce的版本并安装</span><br><span class="line">    # apt list docker-ce -a 通过这个命令可以查看软件包版本</span><br><span class="line">    apt -y install docker-ce&#x3D;$&#123;VERSION&#125;$&#123;CLASS&#125; &amp;&gt;&#x2F;dev&#x2F;null &amp;&amp; echo &quot;docker-ce $&#123;VERSION&#125;安装完成！&quot; || &#123; echo &quot;docker-ce $&#123;VERSION&#125;安装失败&quot;;exit 9; &#125;</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function speedUp() &#123;</span><br><span class="line">    tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">install_docker</span><br><span class="line">speedUp</span><br></pre></td></tr></table></figure>

<p>centos8一键安装docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Centos8一键安装docker同时配置阿里云的镜像加速器脚本</span><br><span class="line"># 采用的方法是使用阿里云的Yum源</span><br><span class="line"></span><br><span class="line"># 调用Linux系统自带函数action</span><br><span class="line">source &#x2F;etc&#x2F;init.d&#x2F;functions</span><br><span class="line"></span><br><span class="line"># 定义变量</span><br><span class="line">DOWNLOAD_DIR&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;src&quot;</span><br><span class="line">VERSION&#x3D;&quot;19.03.13-3.el8&quot;</span><br><span class="line"></span><br><span class="line"># 定义函数</span><br><span class="line">function install_docker() &#123;</span><br><span class="line">    echo &quot;开始安装docker，请稍等&quot;</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">    yum install -y yum-utils device-mapper-persistent-data lvm2 &amp;&gt;&#x2F;dev&#x2F;null || &#123; action &quot;必要工具下载失败，请检查yum源&quot; false;exit 9; &#125;</span><br><span class="line">    # 生成docker.repo仓库配置文件</span><br><span class="line">    tee &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;EOF</span><br><span class="line">[docker]</span><br><span class="line">name&#x3D;docker</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;8&#x2F;x86_64&#x2F;stable&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enable&#x3D;1</span><br><span class="line">EOF</span><br><span class="line">    dnf repolist &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">    dnf -y install docker-ce-$&#123;VERSION&#125; &amp;&gt;&#x2F;dev&#x2F;null &amp;&amp; action &quot;docker-ce-$&#123;VERSION&#125;已安装完成！&quot; || &#123; action &quot;docker-ce-$&#123;VERSION&#125;安装失败&quot; false;exit 9; &#125;</span><br><span class="line">    systemctl enable --now docker &amp;&amp; action &quot;Docker守护进程已开启！&quot; || &#123; action &quot;Docker守护进程启动失败&quot; false;exit 9; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function speedUp() &#123;</span><br><span class="line">    tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;6kqxd7ws.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    systemctl restart docker</span><br><span class="line">&#125;</span><br><span class="line"># 调用函数</span><br><span class="line">install_docker</span><br><span class="line">speedUp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>通信流程</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113103103493.png" alt="image-20201113103103493"></p>
<h3 id="1-2-3-存储引擎"><a href="#1-2-3-存储引擎" class="headerlink" title="1.2.3 存储引擎"></a>1.2.3 存储引擎</h3><p>联合文件系统：Union FS</p>
<p>把不同的物理位置的目录合并mount到同一个目录中，简单来说就是支持将不同目录挂载到一个虚拟文件系统想，这样可以层层叠加修改文件，无论底下有多少层，都是只读层，只有最上层才是可以写的</p>
<p>只读层就是复制的镜像，可写层就是容器</p>
<p>docker目前使用的UnionFS是overlay2</p>
<h3 id="1-2-4-docker进程关系"><a href="#1-2-4-docker进程关系" class="headerlink" title="1.2.4 docker进程关系"></a>1.2.4 docker进程关系</h3><p>dockerd启动–&gt;containerd启动，同时启动grpc，grpc监听dockerd请求</p>
<p>grpc接收到dockerd请求后，发送给containerd，containerd根据请求作出操作</p>
<h2 id="1-3-镜像管理"><a href="#1-3-镜像管理" class="headerlink" title="1.3 镜像管理"></a>1.3 镜像管理</h2><h3 id="1-3-1-镜像结构和分层"><a href="#1-3-1-镜像结构和分层" class="headerlink" title="1.3.1 镜像结构和分层"></a>1.3.1 镜像结构和分层</h3><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114154956782.png" alt="image-20201114154956782"></p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114155433028.png" alt="image-20201114155433028"></p>
<p>镜像即创建容器的模板，含有启动容器所需要的文件系统及所需要的内容，因此镜像主要用于方便和快速的创建并启动容器</p>
<p>docker的镜像是一层一层搭出来的，docker分层的好处就是可以复用，节省空间</p>
<p>分层是需要文件系统支持的，这个文件系统是Union FS，联合文件系统</p>
<p>一个典型的Linux文件系统由bootfs和rootfs组成</p>
<p>bootfs主要包括bootloader和kernel，BootLoader主要用于引导加载kernel，Linux刚启动时会加载bootfs文件系统，当boot加载完成后，kernel会被加载到内存中然后接管系统的控制权，bootfs会被umount，而容器使用宿主机的bootfs，因此不需要bootfs了</p>
<p>rootfs，根文件系统，包含的就是典型的Linux系统中的/dev,/proc,/bin,etc等标准目录和文件，不同的Linux发行版如Ubuntu和Centos主要在rootfs这一层有区别</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114163854325.png" alt="image-20201114163854325"></p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201114163906945.png" alt="image-20201114163906945"></p>
<p>容器是最顶层，一个可以进行写操作的层，容器的下面是镜像层，镜像是不可写的</p>
<p>查看一个镜像中的层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# docker image history nginx:latest</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">c39a868aad02        8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  STOPSIGNAL SIGTERM           0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  EXPOSE 80                    0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENTRYPOINT [&quot;&#x2F;docker-entr…   0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop) COPY file:13577a83b18ff90a…   1.96kB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop) COPY file:e7e183879c35719c…   1.2kB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c set -x     &amp;&amp; addgroup --system -…   63.6MB</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENV PKG_RELEASE&#x3D;1~buster     0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENV NJS_VERSION&#x3D;0.4.4        0B</span><br><span class="line">&lt;missing&gt;           8 days ago          &#x2F;bin&#x2F;sh -c #(nop)  ENV NGINX_VERSION&#x3D;1.19.4     0B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         &#x2F;bin&#x2F;sh -c #(nop)  LABEL maintainer&#x3D;NGINX Do…   0B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line">&lt;missing&gt;           4 weeks ago         &#x2F;bin&#x2F;sh -c #(nop) ADD file:0dc53e7886c35bc21…   69.2MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<p>docker image inspect image_name</p>
<p>保存一个镜像文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save  image_name -o xxx.tar</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-搜索镜像"><a href="#1-3-2-搜索镜像" class="headerlink" title="1.3.2 搜索镜像"></a>1.3.2 搜索镜像</h3><p>docker的官网：dockerhub</p>
<p>docker search image_name</p>
<p>docker search可以支持选择性的搜索</p>
<p>alpine是个面向安全的Linux发行版，包管理器是apk</p>
<h3 id="1-3-3-下载镜像"><a href="#1-3-3-下载镜像" class="headerlink" title="1.3.3 下载镜像"></a>1.3.3 下载镜像</h3><p>从docker仓库下载到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [options] name[:tags]</span><br></pre></td></tr></table></figure>

<p>下载的时候不要使用默认的latest镜像，而要使用具体版本号的镜像</p>
<p>docker存储引擎：overlay2，覆盖，包裹住</p>
<h3 id="1-3-4-镜像查看、镜像保存、镜像导入"><a href="#1-3-4-镜像查看、镜像保存、镜像导入" class="headerlink" title="1.3.4 镜像查看、镜像保存、镜像导入"></a>1.3.4 镜像查看、镜像保存、镜像导入</h3><p>镜像保存</p>
<p>docker save busybox -o busybox.tar</p>
<p>镜像导入</p>
<p>docker load &lt; busybox.tar</p>
<p>或者</p>
<p>docker load -i busybox.tar</p>
<h3 id="1-3-5-镜像删除"><a href="#1-3-5-镜像删除" class="headerlink" title="1.3.5 镜像删除"></a>1.3.5 镜像删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image remove busybox:latest</span><br><span class="line">或者</span><br><span class="line">docker rmi busybox:latest</span><br></pre></td></tr></table></figure>

<p>镜像文件存储在</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/overlay2</span><br></pre></td></tr></table></figure>

<p>镜像就是模板，运行容器时就是把镜像复制一份然后去使用</p>
<p>可以使用docker image -q列出全部镜像的ID，然后</p>
<p>删除镜像之前要把使用这个镜像的容器先删除</p>
<p>删除容器的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container remove container_id</span><br><span class="line">或者</span><br><span class="line">docker rm container_id</span><br></pre></td></tr></table></figure>

<p>老师设置的别名：</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201113150551644.png" alt="image-20201113150551644"></p>
<h3 id="1-3-6-镜像打标签"><a href="#1-3-6-镜像打标签" class="headerlink" title="1.3.6 镜像打标签"></a>1.3.6 镜像打标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure>



<h3 id="1-3-7-alpine介绍"><a href="#1-3-7-alpine介绍" class="headerlink" title="1.3.7 alpine介绍"></a>1.3.7 alpine介绍</h3><p>Alpine是一个面向安全的轻型Linux发行版，采用musl libc和busy box，包管理工具是apk</p>
<p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;apk&#x2F;repositories</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;</span><br><span class="line">apk update</span><br><span class="line">apk add vim</span><br><span class="line">apk del vim</span><br></pre></td></tr></table></figure>

<h3 id="1-3-8-建议安装的包"><a href="#1-3-8-建议安装的包" class="headerlink" title="1.3.8 建议安装的包"></a>1.3.8 建议安装的包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install procps</span><br><span class="line">apt install psmisc</span><br><span class="line">apt install iputils-ping</span><br><span class="line">apt install net-tools</span><br></pre></td></tr></table></figure>



<h2 id="1-4-容器操作基础命令"><a href="#1-4-容器操作基础命令" class="headerlink" title="1.4 容器操作基础命令"></a>1.4 容器操作基础命令</h2><h3 id="1-4-1-启动容器"><a href="#1-4-1-启动容器" class="headerlink" title="1.4.1 启动容器"></a>1.4.1 启动容器</h3><p>docker run 会自动搜索本地和官方仓库</p>
<p>步骤：</p>
<ul>
<li>创建容器</li>
<li>启动容器</li>
</ul>
<p>两个步骤可以合并起来，使用run命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:~# docker run --help</span><br><span class="line"></span><br><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line">-i,--interactive 交互模式</span><br><span class="line">-t,--tty  分配pseudo-tty，通常和-i一起使用，注意对应的容器必须运行shell才支持</span><br><span class="line">-d，--detach  后台运行容器，并打印容器ID</span><br><span class="line">--name 设定容器名称</span><br><span class="line">--h，hostname，设定容器主机名</span><br><span class="line">--rm，Automatically remove the container when it exits</span><br><span class="line">-p，--publish list Publish a container&#39;s port(s) to the host</span><br><span class="line">-P，--publish-all  Publish all exposed ports to random ports</span><br><span class="line">--dns list                       Set custom DNS servers</span><br><span class="line">--entrypoint string              Overwrite the default ENTRYPOINT of the image</span><br><span class="line">--restart string                 Restart policy to apply when a container exits (default &quot;no&quot;)</span><br><span class="line">重启容器的规则，默认是不重启，可以跟always，只要容器退出就重启</span><br><span class="line">还有on-failure</span><br><span class="line">unless-stopped</span><br><span class="line"></span><br><span class="line">--privileged Give extended privileges to this container</span><br><span class="line">-e,--env&#x3D;[]		Set environment variables，设定容器的环境变量</span><br><span class="line">--env-file&#x3D;[]		Read in a line delimited file of environment variables</span><br></pre></td></tr></table></figure>

<p>宿主机开启，自动开启容器的方法：</p>
<p><code>docker run  --restart always</code></p>
<p>启动容器时执行命令，适合一次性的命令：</p>
<p><code>docker run xxxx cat /etc/issues</code></p>
<p>给容器定义名称</p>
<p><code>docker run --name centos8-1 centos8:latest</code></p>
<p>在启动容器时进入交互式命令</p>
<p><code>docker run --name centos8-2 -it centos8 sh </code></p>
<p>容器内的文件在宿主机的<code>/var/lib/docker/overlay2/xxxxx</code>下面</p>
<p>退出容器的交互式命令，但是不关闭容器</p>
<p><code>ctrl + p + q</code></p>
<p>设置容器的主机名</p>
<p><code>docker run -it -h we1.dota.org centos8:latest bash</code></p>
<p>停止容器并删除容器</p>
<p><code>docker run --rm  centos8:latest</code></p>
<p>查看容器映射到宿主机的端口</p>
<p><code>docker port container_id</code></p>
<p>暴露容器端口的方法</p>
<p><code>docker run -P httpd</code></p>
<p>使用wget冒充curl</p>
<p><code>wget -qO - IP</code></p>
<p>系统级的容器如果想要后台运行，需要分配一个终端</p>
<p><code>docker run -td centos8</code></p>
<p>运行容器时，给容器某些权限</p>
<p><code>--privileged</code></p>
<p>官方文档</p>
<p><code>https://docs.docker.com/</code></p>
<p>查看当前正在运行的容器</p>
<p><code>docker container ps </code>，还可以加<code>-a</code>显示全部的(包括停止的)镜像，<code>-q</code>显示容器ID，<code>-l</code>表示最近的容器，<code>-s</code>显示容器的空间大小，<code>-f</code>可以指定是什么状态的容器</p>
<p>运行一个docker文档的镜像</p>
<p><code> docker run -it -d -p 4000:4000 docs/docker.github.io:latest</code></p>
<p>查看容器内运行的程序</p>
<p><code>docker top container_id</code></p>
<p>一些我们常用的、但是镜像内一般没有的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psmisc --&gt; pstree</span><br><span class="line">procps --&gt; ps</span><br></pre></td></tr></table></figure>

<p>查看容器资源使用情况</p>
<p><code>docker stats container_id</code></p>
<p>对容器资源的使用限制，暂时没有记录</p>
<p>查看容器或者镜像的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container_id </span><br><span class="line">docker inspect image_name</span><br><span class="line">加-f选项后面跟具体的配置</span><br></pre></td></tr></table></figure>

<p>删除容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm container_id</span><br><span class="line">可以加-f选项，强制删除，哪怕容器正在运行</span><br><span class="line">根据容器状态进行筛选后删除，status&#x3D;exitd</span><br></pre></td></tr></table></figure>

<p>暂停容器和停止容器是不一样的，暂停容器，宿主机上可以看到容器进程了，停止容器，宿主机上就看不到容器进程了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pause  #暂停</span><br><span class="line">docker unpause #取消暂停</span><br><span class="line">docker stop #停止</span><br><span class="line">docker start #开启</span><br></pre></td></tr></table></figure>

<p>进入正在运行的容器</p>
<p><code>docker attach container_id</code></p>
<p>使用exec命令进入容器执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container exec container_id &#x3D;it COMMAND</span><br><span class="line">这里的COMMAND一定是容器中包含的命令，一般用sh</span><br></pre></td></tr></table></figure>

<p>暴露容器端口，本质上是在宿主机的防火墙上配置了DNAT规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rum -P </span><br><span class="line">这个是随机分配一个端口给容器</span><br></pre></td></tr></table></figure>

<h4 id="指定端口映射"><a href="#指定端口映射" class="headerlink" title="指定端口映射"></a>指定端口映射</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80</span><br><span class="line">表示把容器的80端口映射出去，宿主机端口随机，效果与-P相同</span><br><span class="line"></span><br><span class="line">docker run -p 81:80</span><br><span class="line">表示把容器的80端口映射出去，宿主机端口是81</span><br><span class="line">前面的端口是宿主机端口，后面的端口是容器端口</span><br><span class="line"></span><br><span class="line">docker run -p 10.0.0.100:81:80 </span><br><span class="line">表示必须是本地的10.0.0.100的81端口被映射成容器的80端口</span><br></pre></td></tr></table></figure>

<p>容器间的端口冲突也要提防！容器使用什么端口都要记录和分配好</p>
<p>案例：修改一个已经设定好端口映射的、正在运行的容器的端口映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通过docker container list找到当前容器的ID，如</span><br><span class="line">docker container list</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">c383f8ce793d        nginx               &quot;&#x2F;docker-entrypoint.…&quot;   5 minutes ago       Up About a minute   0.0.0.0:80-&gt;80&#x2F;tcp   web1</span><br><span class="line">然后进入这个目录，&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;</span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers</span><br><span class="line">找到与容器ID匹配的文件夹，进入</span><br><span class="line">然后就能看到hostconfig.json文件了</span><br><span class="line">vim hostconfig.json</span><br><span class="line"></span><br><span class="line">可以看到</span><br><span class="line">PortBindings&quot;:&#123;&quot;80&#x2F;tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;80&quot;&#125;]&#125;</span><br><span class="line">后面的HostPort跟着的就是宿主机的映射端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>查看容器日志 –&gt; 叫做日志，其实是容器的输出</p>
<p>docker logs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs [options] container_name</span><br><span class="line">或者</span><br><span class="line">docker container logs [OPTIONS] CONTAINER</span><br><span class="line">-f，--follow Follow log output</span><br><span class="line">--tail string 从下往上看日志</span><br><span class="line">-t，--timestamps</span><br></pre></td></tr></table></figure>



<p>传递运行命令</p>
<p>一个容器如果没有默认前台执行的进程，那么开启后就会立即退出，但是我们可以人为给这样的容器增加一个前台运行的命令，比如tail -f /etc/hosts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm alpine -d &#x2F;bin&#x2F;sh tail -f &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>



<p>容器内部自己的hosts文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker container run --add-host 域名:IP         Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">例如：</span><br><span class="line">docker run -d --name web1 -p 8080:80 --add-host shicheng:6.6.6.6 nginx</span><br><span class="line"></span><br><span class="line">docker container list</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">88505c96e232        nginx               &quot;&#x2F;docker-entrypoint.…&quot;   10 seconds ago      Up 8 seconds        0.0.0.0:8080-&gt;80&#x2F;tcp   web1</span><br><span class="line"></span><br><span class="line">docker exec -it web1 sh</span><br><span class="line"># cat &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">6.6.6.6 shicheng</span><br><span class="line">172.17.0.2      88505c96e232</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>指定容器的DNS</p>
<p>容器DNS默认使用宿主机DNS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker container run --dns list  Set custom DNS servers</span><br><span class="line">或者通过设置宿主机的&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">docker run -d --name web1 -p 8080:80 --dns&#x3D;8.8.8.8 nginx</span><br><span class="line">docker exec -it web1 sh</span><br><span class="line"># cat &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>实现容器和宿主机之间复制文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">        docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line"></span><br><span class="line">Copy files&#x2F;folders between a container and the local filesystem</span><br><span class="line"></span><br><span class="line">Use &#39;-&#39; as the source to read a tar archive from stdin</span><br><span class="line">and extract it to a directory destination in a container.</span><br><span class="line">Use &#39;-&#39; as the destination to stream a tar archive of a</span><br><span class="line">container source to stdout.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --archive       Archive mode (copy all uid&#x2F;gid information)</span><br><span class="line">  -L, --follow-link   Always follow symbol link in SRC_PATH</span><br></pre></td></tr></table></figure>

<p>例如：从宿主机复制文件到容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前有个web1容器在运行</span><br><span class="line">docker cp test web1:&#x2F;root&#x2F;</span><br></pre></td></tr></table></figure>

<p>例如：从容器复制文件到宿主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp web1:&#x2F;root&#x2F;test .</span><br></pre></td></tr></table></figure>



<p>使用宿主机的systemd控制容器运行</p>
<p>这种方法很少用，会使用k8s进行编排调度</p>
<p>方法：编写一个.service文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"> Description&#x3D;Hello</span><br><span class="line"> After&#x3D;docker.service</span><br><span class="line"> Requires&#x3D;docker.service</span><br><span class="line"> [Service]</span><br><span class="line"> TimeoutStartSec&#x3D;0 </span><br><span class="line"> ExecStartPre&#x3D;-&#x2F;usr&#x2F;bin&#x2F;docker kill busybox-hello  #注意这里的-，如果不加，那么当目前没有一个叫busybox-hello的容器在运行时，服务无法启动</span><br><span class="line"> ExecStartPre&#x3D;-&#x2F;usr&#x2F;bin&#x2F;docker rm busybox-hello</span><br><span class="line"> ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;docker run --name busybox-hello busybox &#x2F;bin&#x2F;sh -c &quot;while true;   do echo Hello World;sleep 1;done&quot;</span><br><span class="line"> ExecStop&#x3D;&#x2F;usr&#x2F;bin&#x2F;docker kill busybox-hello</span><br><span class="line"> [Install]</span><br><span class="line"> WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>传递环境变量</p>
<p>有些容器运行时，需要传递变量，可以使用-e选项或–env-file实现</p>
<p>如何知道要传什么变量呢？去看dockerhub中该容器的介绍，或者自己编写的Dockerfile心里应该有数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意，一个环境变量一个-e选项</span><br><span class="line">-e password&#x3D;xxx -e user&#x3D;xxx</span><br></pre></td></tr></table></figure>

<p>–env-file如何写：每行一个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim env.list</span><br><span class="line">MYSQL_ROOT_PASSWORD&#x3D;123456</span><br><span class="line">MYSQL_DATABASE&#x3D;xxxx</span><br><span class="line">MYSQL_USER&#x3D;wp</span><br><span class="line">MYSQL_PASSWORD&#x3D;xxx</span><br></pre></td></tr></table></figure>



<p>podman管理容器</p>
<p>podman命令与docker基本一致，但是结构不一样，docker是c/s架构的，需要启动服务，后台运行的，podman不是，podman是用的时候启动，不用的时候关闭</p>
<p>podman进程数比较少，conmon一个进程，容器都是conmon的子进程</p>
<h1 id="2-Docker-镜像制作和管理"><a href="#2-Docker-镜像制作和管理" class="headerlink" title="2 Docker 镜像制作和管理"></a>2 Docker 镜像制作和管理</h1><h2 id="2-1-Docker镜像说明"><a href="#2-1-Docker镜像说明" class="headerlink" title="2.1 Docker镜像说明"></a>2.1 Docker镜像说明</h2><p><strong>1.镜像中有没有内核？</strong></p>
<p>没有，容器使用宿主机内核，而镜像本身则只提供相应的rootfs</p>
<p><strong>2.容器中的程序后台运行会导致容器启动后退出，因此需要将容器中的服务进程以前台方式运行，或者使用一些类似tail，top的前台运行的程序也行，常用的保持前台运行方法是：<code>tail -f /etc/hosts</code></strong></p>
<p><strong>3.docker镜像生命周期</strong></p>
<p>dockerfile–&gt;bulid命令–&gt;生成镜像–&gt;push–&gt;镜像仓库–&gt;被pull到主机–&gt;跑成容器</p>
<p>dockerfile可以理解为脚本文件，它有自己的编写格式和要求</p>
<p><strong>4.制作镜像</strong></p>
<p>Docker镜像制作类似于虚拟机的镜像制作，即按照实际业务需求将需要安装的软件、相关配置等基础环境配置完成，然后将其做成镜像，最后再批量从镜像生成容器实例，这样可以极大的简化相同环境的部署工作</p>
<p>镜像制作有两种方式：基于容器的手动制作；基于Dockerfile的自动制作；通常使用Dockerfile制作镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit # 通过修改现有容器，将之手动构建为镜像</span><br><span class="line">docker build  # 通过Dockerfile文件，批量构建为镜像</span><br></pre></td></tr></table></figure>



<h2 id="2-2-将现有容器通过-docker-commit-手动构建镜像"><a href="#2-2-将现有容器通过-docker-commit-手动构建镜像" class="headerlink" title="2.2 将现有容器通过 docker commit 手动构建镜像"></a>2.2 将现有容器通过 docker commit 手动构建镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit [options] container [repository[:tag]]</span><br><span class="line">Create a new image from a container&#39;s changes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --author string    Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)</span><br><span class="line">  -c, --change list      Apply Dockerfile instruction to the created image</span><br><span class="line">  -m, --message string   Commit message</span><br><span class="line">  -p, --pause            Pause container during commit (default true)</span><br></pre></td></tr></table></figure>

<p><strong>手动制作镜像流程：</strong></p>
<p>1.下载一个系统的官方基础镜像</p>
<p>2.基于基础镜像启动一个容器，并进入到容器</p>
<p>3.在容器里面做配置操作</p>
<ul>
<li>安装基础命令</li>
<li>配置运行环境</li>
<li>安装服务和配置服务</li>
<li>放业务代码</li>
</ul>
<p>4.提交为一个新镜像，docker commit</p>
<p>5.基于自己的镜像创建容器并检验功能</p>
<p>实验：基于 busybox 制作 httpd 镜像</p>
<p>实验：使用docker commit基于Tomcat官方镜像制作一个自定义的tomcat镜像</p>
<p>实验：使用docker commit基于Ubuntu官方镜像制作一个自定义的Ubuntu+Nginx镜像</p>
<p>实验：使用docker commit基于Centos的基础镜像利用yum安装手动制作nginx镜像</p>
<p>端口暴露的几种写法，去回顾一下：<a href="#%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84">指定端口映射</a></p>
<p>docker run -p 80</p>
<p>docker run -p 8080:80</p>
<p>docker run -P</p>
<p>docker run -p 10.0.0.55:8080:80</p>
<p>docker run -p 10.0.0.55:8080:80/tcp</p>
<p>docker run -p 10.0.0.55:8080:80/tcp -p 10.0.0.55:90:90/udp</p>
<p>docker run -p 10.0.0.55::80 </p>
<h2 id="2-3-利用DockerFile-文件执行-docker-build-自动构建镜像"><a href="#2-3-利用DockerFile-文件执行-docker-build-自动构建镜像" class="headerlink" title="2.3 利用DockerFile 文件执行 docker build 自动构建镜像"></a>2.3 利用DockerFile 文件执行 docker build 自动构建镜像</h2><h3 id="2-3-1-Dockerfile-使用详解"><a href="#2-3-1-Dockerfile-使用详解" class="headerlink" title="2.3.1 Dockerfile 使用详解"></a>2.3.1 Dockerfile 使用详解</h3><p><strong>1.Dockerfile概念</strong></p>
<p>​    Dockerfile是一种被Docker程序解释执行的脚本，由一条条的命令组成的，每条命令对应Linux下面的一条命令，Docker程序将这些Dockerfile指令再翻译成真正的Linux命令，Dockerfile有自己的书写方式和支持的命令，Docker程序读取Dockerfile并根据指令生成Docker镜像，相比手动制作镜像的方式，Dockerfile更能直观的展示镜像是怎么产生的，有了Dockerfile，当后期有额外的需求时，只需要在之前的Dockerfile添加或者修改响应的命令即可重新生成新的Docker镜像，避免了重复手动制作镜像的麻烦，类似shell脚本一样，可以方便高效的制作镜像</p>
<p><strong>注意：每条指令都是独立运行的，每条指令之间没有关系，每条指令都会生成一个镜像层</strong></p>
<p>比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;tmp</span><br><span class="line">RUN echo &quot;nihao&quot; &gt; nihao.txt</span><br><span class="line"># 这个时候，nihao.txt并不存放在&#x2F;tmp中，因为两条命令之间没有关系</span><br></pre></td></tr></table></figure>

<p><strong>注意：Docker经尽可能重用中间映像，也就是缓存，用来加速 docker build 命令的执行过程，这由Using cache控制台输出中的消息指示</strong></p>
<p><strong>2.Dockerfile镜像制作和使用流程</strong></p>
<p>dockerfile–&gt;bulid命令–&gt;生成镜像–&gt;push–&gt;镜像仓库–&gt;被pull到主机–&gt;跑成容器</p>
<p><strong>3.Dockerfile文件制作镜像的分层结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[Centos&#x2F;Ubuntu] --&gt;B(安装常用命令和初始化配置)</span><br><span class="line">    B --&gt; C(保存成镜像)</span><br><span class="line">    C --&gt; D(添加业务代码,提供服务)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以生成类似的目录来存放镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/&#123;system/&#123;alpine,centos,ubuntu&#125;,web/&#123;apache,nginx,tomcat&#125;&#125;</span><br><span class="line">root@ubuntu1804:/data# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── system</span><br><span class="line">│   ├── alpine</span><br><span class="line">│   ├── centos</span><br><span class="line">│   └── ubuntu</span><br><span class="line">└── web</span><br><span class="line">    ├── apache</span><br><span class="line">    ├── nginx</span><br><span class="line">    └── tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-Dockerfile文件格式"><a href="#2-3-2-Dockerfile文件格式" class="headerlink" title="2.3.2 Dockerfile文件格式"></a>2.3.2 Dockerfile文件格式</h3><p>官方文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;builder&#x2F;</span><br><span class="line">or</span><br><span class="line">man 5 dockerfile</span><br></pre></td></tr></table></figure>

<p><strong>Dockerfile 文件说明：</strong></p>
<ul>
<li>每一行以Dockerfile的指令开头，指令不区分大小写，但是惯例使用大写</li>
<li>使用<code>#</code>开始作为注释</li>
<li>每一行只支持一条指令，每条指令可以携带多个参数</li>
<li>指令按照文件的顺序从上到下依次执行</li>
<li>每个指令的执行都会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令</li>
<li>制作镜像一般可能需要反复多次，每次执行Dockerfile都按顺序执行，从头开始，已经执行过的指令已经被缓存，不需要执行，如果有一行新的指令没有被执行过，其往后的指令将会重新执行，所以为了加速镜像执行，将最长变化的内容放到Dockerfile文件的下面</li>
</ul>
<h4 id="Dockerfile-相关指令"><a href="#Dockerfile-相关指令" class="headerlink" title="Dockerfile 相关指令"></a>Dockerfile 相关指令</h4><p>常用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM</span><br><span class="line">LABEL</span><br><span class="line">ADD</span><br><span class="line">COPY</span><br><span class="line">RUN</span><br><span class="line">CMD</span><br><span class="line">ENTRYPOINT</span><br><span class="line">EXPOSE</span><br><span class="line">VOLUME</span><br><span class="line">WORKDIR</span><br><span class="line">USER</span><br><span class="line">STOPSIGNAL</span><br></pre></td></tr></table></figure>



<h5 id="1-FROM：指定基础镜像"><a href="#1-FROM：指定基础镜像" class="headerlink" title="1.FROM：指定基础镜像"></a>1.FROM：指定基础镜像</h5><p>定制镜像，需要先有一个基础镜像，在这个基础镜像上进行定制</p>
<p>scratch：空镜像，所有镜像的原始镜像，Dockerfile中必须有一个FROM，因此需要这么一个空镜像</p>
<p>FROM的工作流程：</p>
<blockquote>
<p>FROM通常放在Dockerfile文件的第一个、非注释行，后续的指令运行在这个FROM指定的基础镜像的环境中，基础镜像可以是任意可以使用的镜像，docker程序默认先从本地找，如果本地有就用本地的，如果本地没有，就去dockerhub上拉取镜像</p>
<p>建议使用各个开源软件官方提供的镜像，安全可靠</p>
</blockquote>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p>例子：如果要指定版本号，就需要提前调查，调查的方式是dockerhub上查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">FROM ubuntu</span><br><span class="line">FROM centos</span><br></pre></td></tr></table></figure>



<h5 id="2-LABEL：指定镜像元数据"><a href="#2-LABEL：指定镜像元数据" class="headerlink" title="2.LABEL：指定镜像元数据"></a>2.LABEL：指定镜像元数据</h5><p>给镜像添加元数据，也就是作者、联系方式等信息</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt;...</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL Author&#x3D;&quot;huihui&quot; Version&#x3D;&quot;1.0&quot; Telephone&#x3D;&quot;123&quot;</span><br><span class="line"># 还可以写多行</span><br><span class="line">LABEL XXX&#x3D;12</span><br><span class="line">LABEL XXX&#x3D;JJJ</span><br></pre></td></tr></table></figure>

<h5 id="3-RUN：执行shell命令"><a href="#3-RUN：执行shell命令" class="headerlink" title="3.RUN：执行shell命令"></a>3.RUN：执行shell命令</h5><p>RUN指令用来在构建镜像阶段需要执行FROM指定镜像所支持的Shell命令</p>
<p>尽量把命令写在一个RUN里面，减少分层</p>
<p>每个RUN都是独立运行的，命令和命令之间互不相关</p>
<p>格式说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 有两种格式，一种是shell格式，另一种是exec格式，建议用exec的格式，我感觉这个比较全面</span><br><span class="line"># exec格式</span><br><span class="line">RUN [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</span><br><span class="line"># shell格式</span><br><span class="line">RUN echo hello   # 相当于 RUN &#x2F;bin&#x2F;sh -c echo hello</span><br><span class="line"></span><br><span class="line">这两种格式的区别在于shell命令不是容器中pid为1的进程，它前面一定有sh了，而exec会顶替掉当前进程，自己变成当前进程，继承它的进程号，exec执行的命令可以成为Pid为1的进程</span><br><span class="line">exec格式不支持环境变量，shell支持</span><br></pre></td></tr></table></figure>

<p>/bin/bash -c 命令的意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把一个字符串当成一个命令执行，第一个参数是$0，后面的参数是$1，$2...</span><br></pre></td></tr></table></figure>



<h5 id="4-ENV：设置环境变量"><a href="#4-ENV：设置环境变量" class="headerlink" title="4.ENV：设置环境变量"></a>4.ENV：设置环境变量</h5><p><strong>ENV的作用范围：制作镜像的时候以及运行成容器的时候，全部时间都生效</strong></p>
<p><strong>ENV可以定义环境变量和值，会被后续指令比如RUN、ENV、ADD、COPY等通过${VALUE}或者$VALUE的方式调用</strong></p>
<p>相关的几个环境变量的优先级，前提是，下面这两个加参数的选项他们影响的只是运行容器时的变量，构建容器时的变量他们改不了：</p>
<p>Dockerfile中的ENV：优先级低</p>
<p>docker run 的时候参数–env-file：优先级第二高</p>
<p>docker run 的时候参数-e：优先级最高</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENV key1&#x3D;value1 key2&#x3D;value2 \</span><br><span class="line">	key3&#x3D;value3 \</span><br><span class="line">	xxx</span><br><span class="line"># 支持高级变量赋值</span><br><span class="line">A&#x3D;$&#123;key:-word&#125;	意思是，当key没有被定义或赋值的时候，A的值是$word，否则A的值是$key</span><br><span class="line">A&#x3D;$&#123;key:+word&#125;	意思是，当key没有被定义或赋值的时候，A的值是空，否则A的值是$word</span><br></pre></td></tr></table></figure>



<h5 id="5-COPY：复制宿主机文件到容器"><a href="#5-COPY：复制宿主机文件到容器" class="headerlink" title="5.COPY：复制宿主机文件到容器"></a>5.COPY：复制宿主机文件到容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown&#x3D;user:group] src dest</span><br><span class="line">OR</span><br><span class="line">COPY [--chown&#x3D;user:group] [&quot;src&quot;,&quot;dest&quot;]</span><br></pre></td></tr></table></figure>

<p>几个注意的点：</p>
<p>可以是多个，可以使用通配符，通配符满足go语言规范，go语言规范在：<a target="_blank" rel="noopener" href="https://golang.org/pkg/path/filepath/#Match">https://golang.org/pkg/path/filepath/#Match</a></p>
<p>只复制目录数据，不复制目录本身</p>
<p>复制文件的时候，如果目标文件夹不存在，会递归创建出来</p>
<p>如果写相对路径，那么必须在Dockerfile所在目录；可以写绝对路径</p>
<p>源文件的元数据会被保留，比如所属组、用户、权限等</p>
<p>可以覆盖文件，如果要复制的地方已经有了文件的话</p>
<h5 id="5-ADD：复制和解包文件"><a href="#5-ADD：复制和解包文件" class="headerlink" title="5.ADD：复制和解包文件"></a>5.ADD：复制和解包文件</h5><p>增强版的COPY，复制完还能解压缩</p>
<p>zip包不能解压</p>
<p>可以是一个URL，URL下载完的文件不会被解压，权限会被设置成600</p>
<p>tar.gz,tar.bz2,tar.xz等文件会被解压，前提是由gzip,bzip2等软件</p>
<h5 id="6-CMD：容器启动命令"><a href="#6-CMD：容器启动命令" class="headerlink" title="6.CMD：容器启动命令"></a>6.CMD：容器启动命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Image1--&gt;|docker build| Image2</span><br><span class="line">Image1--&gt;|RUN| Image2</span><br><span class="line">Image2 --&gt;|docker run| Container</span><br><span class="line">Image2 --&gt;|CMD| Container</span><br></pre></td></tr></table></figure>

<p><strong>如上图，CMD命令是在镜像已经被打好，需要被运行成一个容器时才执行的</strong></p>
<p>容器中必须有一个运行在前台的、持续的命令</p>
<p>一个容器中需要持续运行的进程一般只有一个，CMD用来指定启动容器时默认执行的一个命令，且命令停止后，容器也会停止，所以CMD指定的命令为持续运行的且为前台的命令</p>
<p><strong>注意：一个Dockerfile只能有一个CMD命令，如果有多个CMD，那么只运行最后一条</strong></p>
<p><strong>注意：如果用户启动容器的时候指定了运行命令，那么CMD命令会被覆盖</strong></p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">or</span><br><span class="line">CMD command param1 param2</span><br><span class="line">or</span><br><span class="line">如果Dockerfile文件中有ENTRYPOINT，那么CMD的命令将成为ENTRYPOINT命令的参数，这时候这么写</span><br><span class="line">CMD [&quot;param1&quot;，&quot;param2&quot;] # 直接写参数，不用写&#x2F;bin&#x2F;bash这种执行文件了，比如</span><br><span class="line">CMD[&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off&quot;]</span><br></pre></td></tr></table></figure>



<h5 id="7-ENTRYPOINT：入口点"><a href="#7-ENTRYPOINT：入口点" class="headerlink" title="7.ENTRYPOINT：入口点"></a>7.ENTRYPOINT：入口点</h5><p>在运行一个容器的时候才会执行</p>
<p><strong>ENTRYPOINT命令不会被docker run提供的命令替换掉</strong></p>
<p>如有Dockerfile中有ENTRYPOINT，那么docker run 后面跟的命令会变成ENTRYPOINT命令的参数</p>
<p>entrypoint的高级用法</p>
<p>-e选项和entrypoint的关系，大家都是在docker run 的时候生效，所以-e选项带来的环境变量可以影响到ENTRYPOINT命令中的变量</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable_file&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">or</span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure>

<p>注意：可以通过docker run –entrypoint string参数在运行时替换</p>
<h5 id="8-ARG：构建参数"><a href="#8-ARG：构建参数" class="headerlink" title="8.ARG：构建参数"></a>8.ARG：构建参数</h5><p>ARG指令在build阶段生效，在docker run阶段就无效了</p>
<p>ENV优先级高于ARG，如果参数名和ENV重复，那么ENV生效</p>
<p>ARG可以比FROM还早的使用</p>
<h5 id="9-VOLUME：挂载点"><a href="#9-VOLUME：挂载点" class="headerlink" title="9.VOLUME：挂载点"></a>9.VOLUME：挂载点</h5><p>在容器中创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保存的数据</p>
<p>在删除容器的时候，加上-v选项才能把挂载点文件也删除</p>
<p><code>docker container rm -fv container_name</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data1&quot;,&quot;&#x2F;data2&quot;]</span><br></pre></td></tr></table></figure>

<p>在宿主机的位置：</p>
<p><code>/var/lib/docker/volumes/&lt;volume_id&gt;/_data</code></p>
<h5 id="10-EXPOSE：暴露端口"><a href="#10-EXPOSE：暴露端口" class="headerlink" title="10.EXPOSE：暴露端口"></a>10.EXPOSE：暴露端口</h5><p>指定默认暴露的端口，但只是指定，并不会主动暴露，还是需要在docker run阶段使用-p,-P来进行暴露</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt;[&#x2F; &lt;protocol&gt;]</span><br><span class="line">protocol是udp或tcp</span><br><span class="line">例如：</span><br><span class="line">EXPOSE 80 443</span><br></pre></td></tr></table></figure>



<h5 id="11-WORKDIR：指定工作目录"><a href="#11-WORKDIR：指定工作目录" class="headerlink" title="11.WORKDIR：指定工作目录"></a>11.WORKDIR：指定工作目录</h5><p>可以指定一个目录，影响Dockerfile文件中位于它后面的命令的工作目录</p>
<p>如果指定的目录不存在，那么就会被创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span><br><span class="line">如果出现多个WORKDIR，并且使用相对路径，那么都是基于前面的WORKDIR路径</span><br></pre></td></tr></table></figure>



<h5 id="12-ONBUILD：子镜像引用父镜像的指令"><a href="#12-ONBUILD：子镜像引用父镜像的指令" class="headerlink" title="12.ONBUILD：子镜像引用父镜像的指令"></a>12.ONBUILD：子镜像引用父镜像的指令</h5><p>自己不执行，让引用它镜像的子镜像执行的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br><span class="line">例如：</span><br><span class="line">ONBUILD RUN rm -rf &#x2F;*</span><br></pre></td></tr></table></figure>



<h5 id="13-USER：指定当前用户"><a href="#13-USER：指定当前用户" class="headerlink" title="13.USER：指定当前用户"></a>13.USER：指定当前用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER mysql:mysql</span><br></pre></td></tr></table></figure>



<h5 id="14-HEALTHCHECK：健康检查"><a href="#14-HEALTHCHECK：健康检查" class="headerlink" title="14.HEALTHCHECK：健康检查"></a>14.HEALTHCHECK：健康检查</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [OPTIONS] CMD &lt;COMMANDS&gt;</span><br></pre></td></tr></table></figure>



<h5 id="15-STOPSIGNAL：退出容器的信号"><a href="#15-STOPSIGNAL：退出容器的信号" class="headerlink" title="15.STOPSIGNAL：退出容器的信号"></a>15.STOPSIGNAL：退出容器的信号</h5><p>设置被发送到容器退出的系统调用信号，默认信号是9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>

<h5 id="16-SHELL：指定SHELL"><a href="#16-SHELL：指定SHELL" class="headerlink" title="16.SHELL：指定SHELL"></a>16.SHELL：指定SHELL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable_file&quot;,&quot;parameters&quot;]</span><br></pre></td></tr></table></figure>



<h5 id="17-“-dockerignore”文件"><a href="#17-“-dockerignore”文件" class="headerlink" title="17. “.dockerignore”文件"></a>17. “.dockerignore”文件</h5><p>生成构建上下文时Docker应该忽略的文件和文件夹格式</p>
<p>官方文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;builder&#x2F;#dockerignore-file</span><br></pre></td></tr></table></figure>



<p>.dockerignore文件使用GO语言的文件路径规则filepath.Match</p>
<p>18.按照作用范围对Dockerfile的指令进行分类</p>
<table>
<thead>
<tr>
<th>BUILD</th>
<th>RUN</th>
<th>BOTH</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>CMD</td>
<td>ENV</td>
</tr>
<tr>
<td>RUN</td>
<td>ENTRYPOINT</td>
<td>WORKDIR</td>
</tr>
<tr>
<td>LABEL</td>
<td>VOLUME</td>
<td>USER</td>
</tr>
<tr>
<td>ADD</td>
<td>EXPOSE</td>
<td></td>
</tr>
<tr>
<td>COPY</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ONBUILD</td>
<td></td>
<td></td>
</tr>
<tr>
<td>.dockerignore</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-3-3-docker-build-命令介绍"><a href="#2-3-3-docker-build-命令介绍" class="headerlink" title="2.3.3 docker build 命令介绍"></a>2.3.3 docker build 命令介绍</h4><p>在写完了Dockerfile后，使用docker build命令利用Dockerfile来创建镜像</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker build [options] path | url | -</span><br><span class="line">path：指定路径，一般就是使用.，表示当前目录</span><br><span class="line">url：指定一个URL</span><br><span class="line">-：表示从标准输入获得Dockerfile</span><br><span class="line">options：</span><br><span class="line">-f,--file string #指定Dockerfile的文件名，默认就是Dockerfile</span><br><span class="line">--no-cache  #不使用缓存</span><br><span class="line">--force-rm	#总是删除中间层容器，创建容器失败时，删除临时容器</span><br><span class="line">-q	#不显示docker build的过程</span><br><span class="line">--rm&#x3D;true  #创建镜像成功时，删除临时容器</span><br><span class="line">-t，--tag list #设置镜像的名称、标签，格式为：&lt;注册中心&gt;&#x2F;&lt;镜像名称&gt;:&lt;标签&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-3-4-案例一：基于centos7镜像构建基于YUM安装的nginx镜像"><a href="#2-3-4-案例一：基于centos7镜像构建基于YUM安装的nginx镜像" class="headerlink" title="2.3.4 案例一：基于centos7镜像构建基于YUM安装的nginx镜像"></a>2.3.4 案例一：基于centos7镜像构建基于YUM安装的nginx镜像</h4><p>Dockerfile文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:centos7.8.2003</span><br><span class="line">LABEL mantainer&#x3D;&quot;huihui&quot;</span><br><span class="line">RUN rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*</span><br><span class="line">COPY Base.repo epel.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">RUN yum install -y nginx \</span><br><span class="line">    &amp;&amp; rm -f &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html \</span><br><span class="line">    &amp;&amp; echo Good afternoon! My friends! &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line"># 构建、运行</span><br><span class="line">docker build -t centos7:v1.0 .</span><br><span class="line">docker run -d --name c1 -P centos7:v1.0</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像"><a href="#2-3-5-案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像" class="headerlink" title="2.3.5 案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像"></a>2.3.5 案例二：分层制作镜像，先制作一个基于centos7的基础镜像，然后再制作一个基于基础镜像的、编译安装的nginx镜像</h4><p>第一步：制作基础镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 首先需要按照功能，把镜像分类管理，就按照文件夹来进行分类</span><br><span class="line">root@ubuntu1804:&#x2F;data# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── system</span><br><span class="line">│   ├── alpine</span><br><span class="line">│   ├── centos</span><br><span class="line">│   └── ubuntu</span><br><span class="line">└── web</span><br><span class="line">    ├── apache</span><br><span class="line">    ├── nginx</span><br><span class="line">    └── tomcat</span><br><span class="line">#然后编写Dockerfile，下面的Dockerfile文件需要提前在当前文件夹下准备repo文件</span><br><span class="line"> FROM centos:centos7.8.2003</span><br><span class="line"> LABEL mantainer&#x3D;&quot;huihui&quot;</span><br><span class="line"> RUN rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*</span><br><span class="line"> COPY Base.repo epel.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"> RUN yum install -y vim-enhanced tcpdump lrzsz tree telnet bash-completion psmisc \</span><br><span class="line">     net-tools wget bzip2 lsof tmux man-pages zip unzip nfs-utils gcc make iproute \</span><br><span class="line">     gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel zlib-devel &amp;&amp; \</span><br><span class="line">     yum clean all &amp;&amp; \</span><br><span class="line">     rm -f &#x2F;etc&#x2F;localtime &amp;&amp; \</span><br><span class="line">     ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br><span class="line"># 构建新镜像，然后运行成容器验证效果</span><br><span class="line">docker build -t centos7:v1.0 .</span><br><span class="line">docker run -it --name c1 centos7:v1.0 sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二步：制作Nginx镜像，nginx使用编译安装的方式，下面主要的问题是nginx的编译安装，以及把bash命令行的命令转换成Dockerfile语句，因此进行问题分解，先使用一个测试机做一遍nginx的编译安装，再去编写Dockerfile</p>
<p>第二步第一小步：编译安装Nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 1.安装必要的包</span><br><span class="line">yum -y install pcre pcre-devel openssl openssl-devel zlib-devel</span><br><span class="line"># 2.下载nginx的源码</span><br><span class="line">wget -P &#x2F;usr&#x2F;local&#x2F;src http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.18.0.tar.gz</span><br><span class="line"># 3.解压</span><br><span class="line">tar xf nginx-1.18.0.tar.gz</span><br><span class="line"># 4.开始预编译</span><br><span class="line">cd nginx-1.18.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx</span><br><span class="line"># 5.编译和编译安装</span><br><span class="line">make -j 4 &amp;&amp; make install</span><br><span class="line"># 6.修改一下配置文件</span><br><span class="line">vim &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">  1 daemon off;</span><br><span class="line">  2 user  nginx;</span><br><span class="line">  3 worker_processes  1;</span><br><span class="line"></span><br><span class="line">[root@localhost apps]$tree -L 2</span><br><span class="line">.</span><br><span class="line">└── nginx</span><br><span class="line">    ├── conf</span><br><span class="line">    ├── html</span><br><span class="line">    ├── logs</span><br><span class="line">    └── sbin</span><br><span class="line"># 7.把生成的配置文件拷贝到要制作nginx镜像的服务器上</span><br><span class="line">scp &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 10.0.0.55:&#x2F;data&#x2F;web&#x2F;nginx&#x2F;1.18</span><br></pre></td></tr></table></figure>

<p>第二步第二小步：编写nginx镜像的Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 1.编写之前把需要的东西准备好，包括nginx的源码包、nginx的自定义配置文件</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;web# tree</span><br><span class="line">.</span><br><span class="line">├── nginx</span><br><span class="line">│   └── 1.8</span><br><span class="line">│       ├── Dockerfile</span><br><span class="line">│       ├── nginx-1.18.0.tar.gz</span><br><span class="line">│       └── nginx.conf</span><br><span class="line"></span><br><span class="line">2.Dockerfile文件</span><br><span class="line"> FROM centos7:v1.0</span><br><span class="line"> ARG VERSION&#x3D;&quot;nginx-1.18.0&quot;</span><br><span class="line"> ADD $&#123;VERSION&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"> RUN cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; \</span><br><span class="line">     .&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx &amp;&amp; \</span><br><span class="line">     make &amp;&amp; make install &amp;&amp; \</span><br><span class="line">     rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx* &amp;&amp; \</span><br><span class="line">     rm -rf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf &amp;&amp; \</span><br><span class="line">     useradd -r nginx</span><br><span class="line"> COPY nginx.conf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;</span><br><span class="line"> EXPOSE 80</span><br><span class="line"> CMD [&quot;&#x2F;apps&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三步：生成镜像并允许成容器进行功能测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx-1.18.0:v1.0 .</span><br><span class="line">docker run --rm -d --name web1 -P nginx-1.18.0:v1.0</span><br><span class="line"># 查看当前宿主机的监听端口，可以看到一个随机的、32768后面的端口32769被监听</span><br><span class="line">LISTEN   0          128                         *:32769                    *:*</span><br><span class="line"># 访问宿主机的32769</span><br><span class="line">curl 10.0.0.55:32769</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像"><a href="#2-3-6-案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像" class="headerlink" title="2.3.6 案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像"></a>2.3.6 案例三：直接制作基于Centos官方版本的、编译安装的Nginx镜像</h4><p>这个案例可以结合前两个案例的Dockerfile文件，整合起来就好了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.准备一些基本文件</span></span><br><span class="line">root@ubuntu1804:/data/web/nginx<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">└── nginx-v1</span><br><span class="line">    ├── Base.repo</span><br><span class="line">    ├── Dockerfile</span><br><span class="line">    ├── epel.repo</span><br><span class="line">    ├── nginx-<span class="number">1.18</span>.<span class="number">0</span>.tar.gz</span><br><span class="line">    └── nginx.conf</span><br><span class="line"><span class="comment"># 2.编写Dockerfile</span></span><br><span class="line"> <span class="keyword">FROM</span> centos:centos7.<span class="number">8.2003</span></span><br><span class="line"> <span class="keyword">ARG</span> VERSION=<span class="string">&quot;nginx-1.18.0&quot;</span></span><br><span class="line"> <span class="keyword">LABEL</span><span class="bash"> mantainer=<span class="string">&quot;huihui&quot;</span></span></span><br><span class="line"> <span class="keyword">RUN</span><span class="bash"> rm -rf /etc/yum.repos.d/*</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="bash"> Base.repo epel.repo /etc/yum.repos.d/</span></span><br><span class="line"> <span class="keyword">ADD</span><span class="bash"> <span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/<span class="built_in">local</span>/src</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="bash"> yum install -y vim-enhanced tcpdump lrzsz tree telnet bash-completion psmisc \</span></span><br><span class="line"><span class="bash">     net-tools wget bzip2 lsof tmux man-pages zip unzip nfs-utils gcc make iproute \</span></span><br><span class="line"><span class="bash">     gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel zlib-devel &amp;&amp; \</span></span><br><span class="line"><span class="bash">     yum clean all &amp;&amp; \</span></span><br><span class="line"><span class="bash">     rm -f /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="bash">     ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="bash">     <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/<span class="variable">$&#123;VERSION&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">     ./configure --prefix=/apps/nginx &amp;&amp; \</span></span><br><span class="line"><span class="bash">     make &amp;&amp; make install &amp;&amp; \</span></span><br><span class="line"><span class="bash">     rm -rf /usr/<span class="built_in">local</span>/src/nginx* &amp;&amp; \</span></span><br><span class="line"><span class="bash">     rm -rf /apps/nginx/conf/nginx.conf &amp;&amp; \</span></span><br><span class="line"><span class="bash">     useradd -r nginx</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="bash"> nginx.conf /apps/nginx/conf/</span></span><br><span class="line"> <span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"> <span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/apps/nginx/sbin/nginx&quot;</span>]</span></span><br><span class="line"><span class="comment"># 3.制作镜像并且运行成容器</span></span><br><span class="line">docker build -t nginx-<span class="number">1.18</span>.<span class="number">0</span>:v2.<span class="number">0</span> .</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --rm --name web2 -d -p 8080:80 nginx-1.18.0:v2.0</span></span><br><span class="line"><span class="comment"># 4.测试</span></span><br><span class="line">查看当前宿主机的监听端口，发现<span class="number">8080</span>已经被监听</span><br><span class="line">LISTEN   <span class="number">0</span>          <span class="number">128</span>                         *:<span class="number">8080</span>                     *:*</span><br><span class="line">curl <span class="number">10.0</span>.<span class="number">0.55</span>:<span class="number">8080</span></span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-生产案例：制作自定义tomcat业务镜像"><a href="#2-4-生产案例：制作自定义tomcat业务镜像" class="headerlink" title="2.4 生产案例：制作自定义tomcat业务镜像"></a>2.4 生产案例：制作自定义tomcat业务镜像</h2><h2 id="2-5-生产案例：构建haproxy镜像"><a href="#2-5-生产案例：构建haproxy镜像" class="headerlink" title="2.5 生产案例：构建haproxy镜像"></a>2.5 生产案例：构建haproxy镜像</h2><h2 id="2-6-基于alpine基础镜像制作NGINX镜像"><a href="#2-6-基于alpine基础镜像制作NGINX镜像" class="headerlink" title="2.6 基于alpine基础镜像制作NGINX镜像"></a>2.6 基于alpine基础镜像制作NGINX镜像</h2><p>第一步：准备基础文件，包括alpine:3.12.1镜像，repositories文件，Nginx源码，nginx.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;alpine# ls</span><br><span class="line">nginx-1.18.0.tar.gz  nginx.conf  repositories</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;alpine# cat repositories</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.12&#x2F;main</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.12&#x2F;community</span><br><span class="line"></span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;alpine# docker images</span><br><span class="line">alpine              3.12.1              d6e46aa2470d        3 weeks ago         5.57MB</span><br><span class="line"></span><br><span class="line"># 准备编写Dockerfile文件，要想好一会要怎么替换apk下载源、一会要下载什么软件的问题</span><br><span class="line">apk update</span><br><span class="line">apk --no-cache add iotop gcc libgcc libc-dev libcurl libc-utils pcre-dev zlib-dev libnfs make pcre pcre2 zip unzip net-tools pstree wget libevent libevent libevent-dev iproute2</span><br></pre></td></tr></table></figure>

<p>第二步：编写Dockerfile文件，有两种方式，第一种方式是分层构建，即先构建一个安装了基本软件、改变了安装源的alpine基础镜像，再构建Nginx；第二种方式是一步到位，直接构建基于alpine的nginx镜像</p>
<p>我用第一种，这样层次分明，alpine基础镜像之后还可以继续使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 基础alpine镜像制作</span><br><span class="line"># Dockerfile</span><br><span class="line"> FROM alpine:3.12.1</span><br><span class="line"> LABEL Author&#x3D;&quot;huihui&quot;</span><br><span class="line"> COPY repositories &#x2F;etc&#x2F;apk&#x2F;repositories</span><br><span class="line"> RUN apk update &amp;&amp; apk --no-cache add iotop gcc libgcc libc-dev \</span><br><span class="line">     libcurl libc-utils pcre-dev zlib-dev libnfs make pcre pcre2 \</span><br><span class="line">     zip unzip net-tools pstree wget libevent libevent libevent-dev iproute2</span><br><span class="line"># 构建镜像并运行成容器</span><br><span class="line">docker build -t alpine-3.12.1:v1.0 .</span><br><span class="line">docker run --it --name a1 --rm alpine-3.12.1:v1.0</span><br><span class="line"></span><br><span class="line"># 基于基础alpine制作nginx</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;web&#x2F;nginx&#x2F;nginx-v2# ls</span><br><span class="line">Dockerfile  nginx-1.18.0.tar.gz  nginx.conf</span><br><span class="line"># Dockerfile</span><br><span class="line">FROM alpine-3.12.1:v1.0</span><br><span class="line"> ENV VERSION&#x3D;&quot;nginx-1.18.0&quot;</span><br><span class="line"> LABEL DATE&#x3D;&quot;2020.11.17&quot;</span><br><span class="line"> ADD $&#123;VERSION&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"> RUN cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx &amp;&amp; \</span><br><span class="line">     make &amp;&amp; make install &amp;&amp; rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; \</span><br><span class="line">     rm -rf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf &amp;&amp; \</span><br><span class="line">     addgroup -g 2020 -S nginx &amp;&amp; adduser -s &#x2F;sbin&#x2F;nologin -S -D -u 2020 \</span><br><span class="line">     -G nginx nginx &amp;&amp; chown -R nginx.nginx &#x2F;apps&#x2F;nginx</span><br><span class="line"> COPY nginx.conf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line"> EXPOSE 80</span><br><span class="line"> CMD [&quot;&#x2F;apps&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;]</span><br></pre></td></tr></table></figure>

<p>第三步：构建成镜像，并允许成容器，测试功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx-1.18.0:v3.0 .</span><br><span class="line">docker run --rm --name web3 -d -p 90:80 nginx-1.18.0:3.0</span><br><span class="line"></span><br><span class="line"># 查看当前宿主机端口是否监听了90端口</span><br><span class="line">ss -nlt</span><br><span class="line">LISTEN   0          128                         *:90                       *:*</span><br><span class="line"># 访问测试</span><br><span class="line">curl 10.0.0.55:90</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure>



<h2 id="2-7-基于Ubuntu基础镜像制作NGINX镜像"><a href="#2-7-基于Ubuntu基础镜像制作NGINX镜像" class="headerlink" title="2.7 基于Ubuntu基础镜像制作NGINX镜像"></a>2.7 基于Ubuntu基础镜像制作NGINX镜像</h2><p>第一步：准备文件，包括Ubuntu的sources.list文件，nginx源码，nginx配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 准备的文件</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;system&#x2F;ubuntu# ls</span><br><span class="line">Dockerfile  sources.list</span><br><span class="line"># 想想一会要下载安装什么软件</span><br><span class="line">apt update</span><br><span class="line">apt install -y gcc openssh-server tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev unzip zip make</span><br></pre></td></tr></table></figure>

<p>第二步：制作Ubuntu的基础镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Docker</span><br><span class="line"> FROM ubuntu</span><br><span class="line"> LABEL manitainer&#x3D;&quot;huihui&quot;</span><br><span class="line"> COPY sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line"> RUN apt update &amp;&amp; apt install -y gcc openssh-server tree openssl \</span><br><span class="line">     libssl-dev libpcre3 libpcre3-dev zlib1g-dev unzip zip make</span><br><span class="line">     </span><br><span class="line"># 构建镜像</span><br><span class="line">docker build -t ubuntu-2004:v1.0 .</span><br></pre></td></tr></table></figure>

<p>第三步：制作nginx镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 准备的文件</span><br><span class="line">root@ubuntu1804:&#x2F;data&#x2F;web&#x2F;nginx&#x2F;nginx-v3# ls</span><br><span class="line">nginx-1.18.0.tar.gz  nginx.conf</span><br><span class="line"># Dockerfile</span><br><span class="line"> FROM ubuntu-2004:v1.0</span><br><span class="line"> ENV VERSION&#x3D;&quot;nginx-1.18.0&quot;</span><br><span class="line"> ADD $&#123;VERSION&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"> RUN cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;$&#123;VERSION&#125; &amp;&amp; .&#x2F;configure --prefix&#x3D;&#x2F;apps&#x2F;nginx &amp;&amp;\</span><br><span class="line">     make &amp;&amp; make install &amp;&amp; rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx* &amp;&amp; \</span><br><span class="line">     groupadd -g 2020 -r nginx &amp;&amp; useradd -g nginx -s &#x2F;usr&#x2F;sbin&#x2F;nologin -u 2020 \</span><br><span class="line">     nginx &amp;&amp; chown -R nginx.nginx &#x2F;apps&#x2F;nginx</span><br><span class="line"> COPY nginx.conf &#x2F;apps&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line"> EXPOSE 80</span><br><span class="line"> CMD [&quot;&#x2F;apps&#x2F;nginx&#x2F;sbin&#x2F;nginx&quot;]</span><br><span class="line"></span><br><span class="line"># 构建镜像并运行成容器</span><br><span class="line">docker build -t nginx-1.18.0:v4.0 .</span><br><span class="line">docker run --rm --name web4 -d -p 100:80 nginx-1.18.0:v4.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第四步：检验功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看宿主机监听的IP</span><br><span class="line">ss -nlt</span><br><span class="line">LISTEN   0          128                         *:100                      *:*</span><br><span class="line"># 访问宿主机100端口</span><br><span class="line">curl 10.0.0.55:100</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure>



<h1 id="3-Docker数据管理"><a href="#3-Docker数据管理" class="headerlink" title="3 Docker数据管理"></a>3 Docker数据管理</h1><p>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层</p>
<p>写时复制机制：</p>
<p>​        如果运行中的容器修改了现有的一个已经存在的文件，那么该文件会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，这就是“写时复制”机制，COW，Copy ON Write</p>
<p>​        如果正在运行的容器生成了新的数据，那么这个数据也会被复制到读写层，进行持久化保存，这个读写层是指容器的工作目录，这也是写时复制</p>
<p>​        COW机制节约空间，但是影响性能，而且随着容器的删除，数据也会被删除，无法保存，为了保存数据，需要使用数据卷技术</p>
<p>下面的图大概说明了，容器在写入数据的时候会把数据写入读写层和数据卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(容器)--&gt;|Write to|B[容器的文件系统]</span><br><span class="line">B--&gt;|Write to|C([读写层])</span><br><span class="line">B--&gt;|Write to|D([宿主机数据卷])</span><br></pre></td></tr></table></figure>



<h2 id="3-1-容器的数据管理介绍"><a href="#3-1-容器的数据管理介绍" class="headerlink" title="3.1 容器的数据管理介绍"></a>3.1 容器的数据管理介绍</h2><p>容器删除，读写层也被删除，数据无法保存</p>
<p>通过把容器的数据写入宿主机来保存数据</p>
<h3 id="3-1-1-容器的分层"><a href="#3-1-1-容器的分层" class="headerlink" title="3.1.1 容器的分层"></a>3.1.1 容器的分层</h3><p><strong>LowerDir：镜像层，镜像本身</strong></p>
<p><strong>UpperDir：容器的上层，可读写，容器变化的数据存放在此处</strong></p>
<p><strong>MergedDir：容器的文件系统，使用Union FS，将LowerDir和UpperDir合并起来呈现给用户</strong></p>
<p><strong>WorkDir：容器在宿主机的工作目录</strong></p>
<p>通过命令查看这几个分层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect container_name</span><br><span class="line">例如：</span><br><span class="line">docker container inspect busybox1</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb-init&#x2F;diff:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;932dede2b5e2dc14c70ff5f5f32f4ab29fd92c6d4d9f6c6667fa20bc143a010c&#x2F;diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb&#x2F;merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb&#x2F;diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;0b7dfef51bd9a247e28a746fc2730e7e2c2799059cec0435d7138d2b05fdb7eb&#x2F;work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-1-2-什么数据应该持久化"><a href="#3-1-2-什么数据应该持久化" class="headerlink" title="3.1.2 什么数据应该持久化"></a>3.1.2 什么数据应该持久化</h3><p>1.数据库：包括关系型数据库Mysql、远程字典服务Redis等</p>
<p>2.需要保存状态的服务：Tomcat Memcached</p>
<h3 id="3-1-3-解决方案"><a href="#3-1-3-解决方案" class="headerlink" title="3.1.3 解决方案"></a>3.1.3 解决方案</h3><p>数据卷：宿主机上的目录或文件，挂载到容器内使用，分为三种使用方案</p>
<ul>
<li>直接使用宿主机的文件目录作为容器的一个文件目录，推荐使用，较为常用</li>
<li>匿名卷</li>
<li>命名卷</li>
</ul>
<p>数据卷容器：间接使用宿主机空间，需要增加一个专门的容器来当数据卷，</p>
<h2 id="3-2-数据卷"><a href="#3-2-数据卷" class="headerlink" title="3.2 数据卷"></a>3.2 数据卷</h2><p><strong>大概</strong></p>
<p>本质上是使用宿主机的文件或目录挂载到容器内部使用，容器删除时不会删除挂载文件，因此数据保存了下来</p>
<p>Dockerfile中的VOLUMES选项也是一种匿名卷，可以被-v选项所替代</p>
<p><strong>分类：</strong></p>
<ul>
<li>指定宿主机目录或文件，指定容器内部的挂载点</li>
<li>匿名卷：在删除容器的时候加上-v选项会删除掉，其他两种方式不会被删除</li>
<li>命名卷</li>
</ul>
<p>有一点，只有匿名卷在使用命令<code>docker container rm -fv</code>的时候会被删除，其他的卷需要其他方式删除，比如删除宿主机文件，命名卷可以使用<code>docker volume rm</code>删除</p>
<p>可以加只读选项：ro</p>
<p><strong>特点</strong></p>
<ul>
<li>数据卷可以在多个容器之间共同使用，实现容器之间文件共享</li>
<li>数据卷的变化不会影响到镜像</li>
<li>依赖于宿主机，不方便容器的迁移和数据的统一管理</li>
</ul>
<p><strong>三种数据卷的使用方法：</strong></p>
<p>首先，三种方法都是在容器运行时使用，因此都是在docker run命令后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -v [host-src:]container-dest[:options]</span><br><span class="line">options:</span><br><span class="line">rw，默认值，容器对数据卷拥有读写权限</span><br><span class="line">ro，只读，容器只能读取数据卷，不能写</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法一：明确指定宿主机文件或目录以及容器的文件或目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --rm -v &#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;centos -d mysql:8.0.22</span><br><span class="line"></span><br><span class="line">-v &#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">明确指明宿主机和容器的文件目录挂载关系</span><br><span class="line">如果宿主机上不存在这个目录，会被自动创建出来，容器没有这个目录不行</span><br><span class="line"></span><br><span class="line">测试，删除了容器，宿主机上数据卷目录中文件还在</span><br></pre></td></tr></table></figure>

<p>方法二：匿名卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --rm -v &#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;centos -d mysql:8.0.22</span><br><span class="line"></span><br><span class="line">-v &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">只写上容器中哪个目录要被挂载，不写宿主机上是谁挂载上去，docker程序会在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;下自动生成一个文件去挂载</span><br><span class="line"></span><br><span class="line">通过inspect命令查找是哪个数据卷</span><br><span class="line">docker container inspect 6f7acc6951dd</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;cac7ecd9607a82578d680defe350069c7d2119e33a36cee272684b1efe5ce03c&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;cac7ecd9607a82578d680defe350069c7d2119e33a36cee272684b1efe5ce03c&#x2F;_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;mysql&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">上面的Source文件就是，去查看，可以看到容器中数据库生成的文件</span><br></pre></td></tr></table></figure>

<p>方法三：命名卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有两种方法：</span><br><span class="line">方法一：提前创建一个数据卷</span><br><span class="line">方法二：在docker run 的时候顺便创建</span><br><span class="line"></span><br><span class="line">docker run --rm -p 3306:3306 -d -e MYSQL_ROOT_PASSWORD&#x3D;centos -v volume1:&#x2F;var&#x2F;lib&#x2F;mysql mysql:8.0.22</span><br><span class="line"></span><br><span class="line">-v volume1:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">写出明确的数据卷名称，docker程序会在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;下面生成</span><br><span class="line"></span><br><span class="line">root@ubuntu1804:~# ll &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;volume1&#x2F;</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 3 root root   4096 Nov 18 20:05 .&#x2F;</span><br><span class="line">drwx------ 9 root root   4096 Nov 18 20:05 ..&#x2F;</span><br><span class="line">drwxrwxrwt 6  999 docker 4096 Nov 18 20:06 _data&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>数据卷的管理命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker volume COMMAND</span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure>



<h2 id="3-3-数据卷容器"><a href="#3-3-数据卷容器" class="headerlink" title="3.3 数据卷容器"></a>3.3 数据卷容器</h2><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201118110004990.png" alt="image-20201118110004990"></p>
<p>–volumes-from &lt;数据卷容器&gt;</p>
<p>数据卷容器只在其他容器创建的时候被抄一下磁盘映射关系，其他时候没有用，它容器停了都没事，删除了对之前的容器也不影响</p>
<p>利用数据卷容器实现备份</p>
<h1 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4 网络管理"></a>4 网络管理</h1><h2 id="4-1-Docker的默认的网络通信"><a href="#4-1-Docker的默认的网络通信" class="headerlink" title="4.1 Docker的默认的网络通信"></a>4.1 Docker的默认的网络通信</h2><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201118114909203.png" alt="image-20201118114909203"></p>
<p>1.</p>
<p>在service文件中的execstart后面跟上这个选项：–icc false，表示禁止容器之间通信</p>
<p>2.</p>
<p>修改docker的默认网路配置</p>
<p>可以自行制定docker0的IP端</p>
<p>-b，–bip</p>
<h2 id="4-2-容器名称互联"><a href="#4-2-容器名称互联" class="headerlink" title="4.2 容器名称互联"></a>4.2 容器名称互联</h2><p>因为docker给容器分配IP是随机的，因此不能使用IP，所以使用一个固定的容器名称进行通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --link list # 写上其他容器的名称</span><br><span class="line"># 真正使用不是很多，因为太麻烦，不如DNS服务器来的爽</span><br></pre></td></tr></table></figure>



<p>因为害怕容器名称改变，引入了容器别名的问题</p>
<h2 id="4-3-Docker网络连接模式"><a href="#4-3-Docker网络连接模式" class="headerlink" title="4.3 Docker网络连接模式"></a>4.3 Docker网络连接模式</h2><p>一共5种模式：</p>
<ul>
<li>none：单机模式，只有lo网卡</li>
<li>bridge：默认网络模式</li>
<li>host：使用宿主机的网卡</li>
<li>container：一个容器使用另一个容器的网络，究极复制，连开启的端口都复制？？？</li>
<li>自定义网络</li>
</ul>
<p>使用方式<code>--network</code>后面跟模式</p>
<p>{}</p>
<p>$-</p>
<p>-B</p>
<p>docker network</p>
<p>docker network connect</p>
<h2 id="4-4-实现跨宿主机的容器之间网络互联"><a href="#4-4-实现跨宿主机的容器之间网络互联" class="headerlink" title="4.4 实现跨宿主机的容器之间网络互联"></a>4.4 实现跨宿主机的容器之间网络互联</h2><p>网桥就是一个交换机</p>
<p>Open vSwitch 开源的、虚拟交换机技术，包名是：apt install openvswitch-switch</p>
<h2 id="4-5-实战案例：利用docker结合负载实现网络架构高可用"><a href="#4-5-实战案例：利用docker结合负载实现网络架构高可用" class="headerlink" title="4.5 实战案例：利用docker结合负载实现网络架构高可用"></a>4.5 实战案例：利用docker结合负载实现网络架构高可用</h2><h1 id="5-Docker-仓库管理"><a href="#5-Docker-仓库管理" class="headerlink" title="5 Docker 仓库管理"></a>5 Docker 仓库管理</h1><h2 id="5-1-官方docker仓库"><a href="#5-1-官方docker仓库" class="headerlink" title="5.1 官方docker仓库"></a>5.1 官方docker仓库</h2><h2 id="5-2-阿里云Docker仓库"><a href="#5-2-阿里云Docker仓库" class="headerlink" title="5.2 阿里云Docker仓库"></a>5.2 阿里云Docker仓库</h2><h2 id="5-3-私有云单机仓库Docker-Registry"><a href="#5-3-私有云单机仓库Docker-Registry" class="headerlink" title="5.3 私有云单机仓库Docker Registry"></a>5.3 私有云单机仓库Docker Registry</h2><h2 id="5-4-Docker之分布式仓库Harbor"><a href="#5-4-Docker之分布式仓库Harbor" class="headerlink" title="5.4 Docker之分布式仓库Harbor"></a>5.4 Docker之分布式仓库Harbor</h2><h1 id="6-单机编排之Docker-Compose"><a href="#6-单机编排之Docker-Compose" class="headerlink" title="6 单机编排之Docker Compose"></a>6 单机编排之Docker Compose</h1><h2 id="6-1-Docker-Compose介绍"><a href="#6-1-Docker-Compose介绍" class="headerlink" title="6.1 Docker Compose介绍"></a>6.1 Docker Compose介绍</h2><h2 id="6-2-安装和准备"><a href="#6-2-安装和准备" class="headerlink" title="6.2 安装和准备"></a>6.2 安装和准备</h2><h2 id="6-3-从Docker-Compose启动单个容器"><a href="#6-3-从Docker-Compose启动单个容器" class="headerlink" title="6.3 从Docker Compose启动单个容器"></a>6.3 从Docker Compose启动单个容器</h2><h2 id="6-4-从-Docker-Compose启动多个容器"><a href="#6-4-从-Docker-Compose启动多个容器" class="headerlink" title="6.4 从 Docker Compose启动多个容器"></a>6.4 从 Docker Compose启动多个容器</h2><h2 id="6-5-实战案例：实现单机版的Haproxy-Nginx-Tomcat"><a href="#6-5-实战案例：实现单机版的Haproxy-Nginx-Tomcat" class="headerlink" title="6.5 实战案例：实现单机版的Haproxy+Nginx+Tomcat"></a>6.5 实战案例：实现单机版的Haproxy+Nginx+Tomcat</h2><h1 id="7-Docker的资源限制"><a href="#7-Docker的资源限制" class="headerlink" title="7 Docker的资源限制"></a>7 Docker的资源限制</h1><h2 id="7-1-Docker-资源限制"><a href="#7-1-Docker-资源限制" class="headerlink" title="7.1 Docker 资源限制"></a>7.1 Docker 资源限制</h2><h2 id="7-2-容器的内存限制"><a href="#7-2-容器的内存限制" class="headerlink" title="7.2 容器的内存限制"></a>7.2 容器的内存限制</h2><h2 id="7-3-容器的CPU限制"><a href="#7-3-容器的CPU限制" class="headerlink" title="7.3 容器的CPU限制"></a>7.3 容器的CPU限制</h2><h1 id="8-可视化图形工具Portainer"><a href="#8-可视化图形工具Portainer" class="headerlink" title="8 可视化图形工具Portainer"></a>8 可视化图形工具Portainer</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/18/Docker/" data-id="ckhnf9hf5000b40ut4gn08wos" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-DNS服务和BIND软件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/18/DNS%E6%9C%8D%E5%8A%A1%E5%92%8CBIND%E8%BD%AF%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2020-11-18T13:08:14.202Z" itemprop="datePublished">2020-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="DNS服务和BIND软件"><a href="#DNS服务和BIND软件" class="headerlink" title="DNS服务和BIND软件"></a>DNS服务和BIND软件</h2><p>2.DNS实现主服务器</p>
<p>3.DNS实现从服务器</p>
<p>4.DNS实现子域</p>
<p>5.DNS实现域名转发</p>
<p>6.DNS实现反向区域解析</p>
<h3 id="1-名字解析介绍"><a href="#1-名字解析介绍" class="headerlink" title="1.名字解析介绍"></a>1.名字解析介绍</h3><p>TCP/IP协议–&gt;IP地址是访问的开始–&gt;IP地址难记–&gt;用一种好记的名字代替IP，域名出现</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.222  www.dawang.org</span><br><span class="line">203.23.44.222  www.xiaowang.org</span><br></pre></td></tr></table></figure>

<p>DNS domain name system 域名系统，应用层协议，是互联网的一项服务。</p>
<p>C/S架构</p>
<p>53/udp：同步和查询</p>
<p>53/tcp：同步</p>
<p>DNS级别：</p>
<ul>
<li>根域</li>
<li>一级域名<ul>
<li>三类：组织域、国家域、反向域</li>
</ul>
</li>
<li>二级域名：xxxxxx.com</li>
<li>三级域名：aaa.xxxx.com</li>
<li>最多127级域名</li>
</ul>
<h3 id="2-DNS服务工作原理"><a href="#2-DNS服务工作原理" class="headerlink" title="2.DNS服务工作原理"></a>2.DNS服务工作原理</h3><p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200912170407556.png" alt="image-20200912170407556"></p>
<p>DNS的查询类型：</p>
<ul>
<li>递归查询：一般客户端和本地DNS服务端之间属于递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到最终的肯定或者否定的结构后转交给客户机。此查询的源和目标保持不变，为了查询结果只需要发起一次查询。</li>
<li>迭代查询：一般情况下本地的DNS服务器向其他DNS服务器的查询属于迭代查询，如：若对方不能返回权威的结果，则它会向下一个DNS服务器再次发起查询，直到返回查询的结果为止。此查询的源不变，但查询的目标不断变化，为查询结果一般需要发起多次查询。</li>
</ul>
<p>小工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whois xxxxx.com</span><br><span class="line">可以查出域名信息</span><br></pre></td></tr></table></figure>

<p>FQDN:Fully Qualified Domain Name 全限定域名，同时带有主机名和域名的名称。</p>
<p>比如：主机名是big，域名是hhh.com，FQDN就是 big.hhh.com</p>
<p>解析的类型：</p>
<ul>
<li>FQDN –&gt; IP正向解析</li>
<li>IP –&gt; FQDN反向解析</li>
</ul>
<p>一个完整的查询请求经过的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client --&gt; hosts文件 --&gt; Client DNS Service Local Cache --&gt; DNS Server（recursion） --&gt; DNS Server Cache --&gt; DNS iteration（迭代） --&gt; 根 --&gt; 顶级域名DNS --&gt; 二级域名DNS</span><br></pre></td></tr></table></figure>

<p>DNS服务器的类型：</p>
<ul>
<li>主DNS服务器：管理和维护所负责解析的域内解析库的服务器</li>
<li>从DNS服务器：从主服务器或从服务器复制解析库副本<ul>
<li>序列号：主服务器的DNS数据库版本号</li>
<li>刷新时间间隔：从主服务器请求同步解析的时间间隔</li>
<li>重试时间间隔：从服务器请求同步失败时，再次尝试的时间间隔</li>
<li>过期时长：从服务器联系不上主服务器时，多久后停止服务</li>
<li>通知机制：主服务器解析库发生变化时，会主动通知从服务器</li>
</ul>
</li>
<li>缓存DNS服务器（转发器）：</li>
</ul>
<p>权威DNS服务器：真正保存你要找的域名的IP的服务器</p>
<p>资源记录：RR Resource Record</p>
<ul>
<li><p>SOA：Start Of Authority，起始授权记录，一个区域解析库有且仅有一个SOA记录，必须位于解析库的第一条记录</p>
</li>
<li><p>A：Internet Address，正向解析</p>
</li>
<li><p>AAAA：正向解析，IPV6</p>
</li>
<li><p>PTR：PoinTeR，反向解析</p>
</li>
<li><p>NS：Name Server，专用于标明当前区域的DNS服务器</p>
</li>
<li><p>CNAME：Canonical Name，别名记录</p>
</li>
<li><p>MX：Mail exchanger，邮件交换器</p>
</li>
<li><p>TXT：对域名进行标识和说明的一种方式，一般做验证记录时会使用此项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name		[TTL]		IN			rr_type			value</span><br></pre></td></tr></table></figure>

<p>TTL：time to live 一个DNS记录在DNS服务器上的缓存时间，可以被继承</p>
<p>@：表示引用当前区域的名字</p>
<p>相邻的两个记录name相同时，后一个的name可以省略</p>
</li>
</ul>
<h3 id="3-实现主服务器"><a href="#3-实现主服务器" class="headerlink" title="3.实现主服务器"></a>3.实现主服务器</h3><p>bind软件实现</p>
<ul>
<li>bind主程序：/usr/sbin/named</li>
<li>主配置文件：/etc/named.conf,/etc/named.rfc1921.zones,/etc/rndc.key</li>
<li>管理工具：/usr/sbin/rndc  remote name domain controller ，默认与bind安装在同一主机，且只能通过127.0.0.1连接named进程，提供辅助性的管理功能；953/tcp</li>
<li>解析库文件：/var/named/ZONE_NAME&gt;ZONE<ul>
<li>一台物理服务器可以同时为多个区域提供解析</li>
<li>必须有两个根区域文件；named.cd</li>
<li>应该有两个实现localhost和本地回环地址的解析库</li>
</ul>
</li>
</ul>
<p>实现需要的资料：</p>
<ul>
<li><p>对主配置文件进行修改</p>
<p>/etc/named.conf</p>
</li>
<li><p>自定义区域解析库文件</p>
</li>
</ul>
<p>/var/named/xxxxx.zone</p>
<ul>
<li>生效工具</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三种方式</span><br><span class="line">rndc reload</span><br><span class="line">systemctl reload named</span><br><span class="line">service named reload</span><br></pre></td></tr></table></figure>

<ul>
<li>测试工具</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主配置文件语法检查</span><br><span class="line">named-checkconf</span><br><span class="line">解析库文件语法检查</span><br><span class="line">named-checkzone &quot;lvlvl.dota&quot; &#x2F;var&#x2F;named&#x2F;xxxx.dota.zone</span><br><span class="line">dig命令，只用于测试DNS，不会查询hosts文件</span><br><span class="line">host命令</span><br><span class="line">nsloopup命令，可以支持交互和非交互式</span><br></pre></td></tr></table></figure>

<p>实现步骤：</p>
<p>1.安装软件包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#yum -y insatll bind bind-utils</span><br></pre></td></tr></table></figure>

<p>2.主配置文件修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;etc&#x2F;named.conf</span><br><span class="line">注释掉这两行：</span><br><span class="line">&#x2F;&#x2F;  listen-on port 53 &#123; 127.0.0.1; &#125;;</span><br><span class="line">&#x2F;&#x2F;  allow-query     &#123; localhost; &#125;;</span><br><span class="line">[root@localhost etc]#vim named.rfc1912.zones</span><br><span class="line">添加下面的内容：</span><br><span class="line">zone &quot;lv.dota&quot; IN &#123;</span><br><span class="line">     type master;</span><br><span class="line">     file &quot;lv.dota.zone&quot;;</span><br><span class="line">&#125;;         </span><br></pre></td></tr></table></figure>

<p>3.DNS区域数据库文件 位于 /var/named/ 文件夹下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#cp -p &#x2F;var&#x2F;named&#x2F;named.localhost &#x2F;var&#x2F;named&#x2F;lv.dota.zone</span><br><span class="line">[root@localhost named]#vim named.localhost</span><br><span class="line">  1 $TTL 1D                                                                  </span><br><span class="line">  2 @   IN SOA  @ rname.invalid. (</span><br><span class="line">  3                     0   ; serial</span><br><span class="line">  4                     1D  ; refresh</span><br><span class="line">  5                     1H  ; retry</span><br><span class="line">  6                     1W  ; expire</span><br><span class="line">  7                     3H )    ; minimum</span><br><span class="line">  8     NS  @</span><br><span class="line">  9     A   127.0.0.1</span><br><span class="line"> 10     AAAA    ::1</span><br><span class="line"> </span><br><span class="line">[root@localhost named]#vim &#x2F;var&#x2F;named&#x2F;lv.dota.zone </span><br><span class="line">  1 $TTL 1D</span><br><span class="line">  2 @   IN SOA  master admin.lv.dota. (</span><br><span class="line">  3                     0   ; serial</span><br><span class="line">  4                     1D  ; refresh</span><br><span class="line">  5                     1H  ; retry</span><br><span class="line">  6                     1W  ; expire</span><br><span class="line">  7                     3H )    ; minimum</span><br><span class="line">  8     NS  master</span><br><span class="line">  9 master  A   10.0.0.7                                                     </span><br><span class="line"> 10 www     A   10.0.0.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.检查主配置文件和区域数据库文件的格式是否正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">named-checkconf</span><br><span class="line">named-checkzone lv.dota &#x2F;var&#x2F;named&#x2F;lv.dota.zone</span><br><span class="line">检查无误后启动服务</span><br></pre></td></tr></table></figure>

<p>5.启动服务，配合一台http主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start named</span><br><span class="line">rndc reload #这是重新加载</span><br><span class="line">去http主机上开启服务</span><br><span class="line">systemctl start httpd</span><br><span class="line">echo &quot;for your love&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure>

<p>6.去一台客户端服务器上测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">首先将客户端的DNS地址配成10.0.0.7</span><br><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">DNS1&#x3D;10.0.0.7</span><br><span class="line">service network restart</span><br><span class="line">检查DNS是不是改过来了</span><br><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">出现nameserver 10.0.0.7就是成功了</span><br><span class="line">用curl命令行浏览器测试</span><br><span class="line">curl www.lv.dota</span><br><span class="line">for your love</span><br><span class="line">成功</span><br></pre></td></tr></table></figure>

<h3 id="4-实现反向解析"><a href="#4-实现反向解析" class="headerlink" title="4.实现反向解析"></a>4.实现反向解析</h3><p>1.修改/etc/named.conf配置，</p>
<ul>
<li>监听socket改成当前IP地址，这样才能让监听到其他主机的访问请求</li>
<li>把访问请求开关打开</li>
<li>上面两项都可以调成//注释，这样默认都开了</li>
</ul>
<p>2.修改/etc/named.rfc1912.zones，将反向解析的zone输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;0.0.10.in-addr.arpa.&quot; IN &#123;</span><br><span class="line">	type master;</span><br><span class="line">	file &quot;10.0.0.zone&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.去/var/named/下面写这个文件：10.0.0.zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim 10.0.0.zone</span><br><span class="line">$TTL 1D</span><br><span class="line">@	SOA		IN		ns1		admin.lv.dota.(</span><br><span class="line">			0;#序列号</span><br><span class="line">			1D;#刷新时间间隔</span><br><span class="line">			1H;#重试时间间隔</span><br><span class="line">			1W；过期时长，expire</span><br><span class="line">			3H ) ；通知机制</span><br><span class="line">		NS 		ns1.lv.dota.</span><br><span class="line">199		PTR		www.lv.dota.</span><br><span class="line">99		PTR		fun.lv.dota.</span><br><span class="line">#* 序列号：主服务器的DNS数据库版本号</span><br><span class="line">#* 刷新时间间隔：从主服务器请求同步解析的时间间隔</span><br><span class="line">#* 重试时间间隔：从服务器请求同步失败时，再次尝试的时间间隔</span><br><span class="line">#* 过期时长：从服务器联系不上主服务器时，多久后停止服务</span><br><span class="line">#* 通知机制：主服务器解析库发生变化时，会主动通知从服务器</span><br></pre></td></tr></table></figure>

<p>4.去客户端测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$dig -x 10.0.0.100</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6 &lt;&lt;&gt;&gt; -x 10.0.0.100</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 10215</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;100.0.0.10.in-addr.arpa.	IN	PTR</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">0.0.10.in-addr.arpa.	10800	IN	SOA	ns1.0.0.10.in-addr.arpa. admin.lv.dota. 0 86400 3600 604800 10800</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 10.0.0.7#53(10.0.0.7)</span><br><span class="line">;; WHEN: Sun Sep 13 08:58:38 2020</span><br><span class="line">;; MSG SIZE  rcvd: 94</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$host 10.0.0.199</span><br><span class="line">199.0.0.10.in-addr.arpa domain name pointer www.lv.dota.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$nslookup 10.0.0.99</span><br><span class="line">Server:		10.0.0.7</span><br><span class="line">Address:	10.0.0.7#53</span><br><span class="line"></span><br><span class="line">99.0.0.10.in-addr.arpa	name &#x3D; fun.lv.dota.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-实现从服务器"><a href="#5-实现从服务器" class="headerlink" title="5.实现从服务器"></a>5.实现从服务器</h3><p>只有一台主DNS服务器存在单点失败问题，可以建立主DNS服务器的备份服务器，即从服务器，从而实现DNS的容错机制。从服务器可以自动和主服务器进行单向的数据同步，从而和主DNS服务器一样，也拥有区域解析数据库，也可以对外提供查询服务，但从服务器不提供数据更新服务。</p>
<p>从服务器的要求：</p>
<ul>
<li>一台独立的服务器</li>
<li>在主服务器的区域解析库文件中必须有一条NS记录指向从服务器</li>
<li>从服务器只需要定义区域，而不需要提供解析库文件，他从主服务器拿解析库文件，解析库文件应该放在/var/named/slaves/下</li>
<li>主服务器得允许从服务器作区域传送</li>
<li>主从服务器的时间应该同步</li>
<li>bind程序的版本应该保持一致，否则应该从服务器版本高，主服务器版本低</li>
</ul>
<p>主服务器的配置步骤：</p>
<p>1.配置/etc/named.conf，设置允许从服务器传输解析库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;etc&#x2F;named.conf</span><br><span class="line">allow-transfer &#123; 10.0.0.153; &#125;;  &#123;&#125; 中填写从服务器的地址</span><br></pre></td></tr></table></figure>

<p>2.记住/etc/named.rfc1912.zones中设置的zone配置，待会拿到从服务器改改使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">43 zone &quot;lv.dota&quot; IN &#123;</span><br><span class="line">44     type master;</span><br><span class="line">45     file &quot;lv.dota.zone&quot;;</span><br><span class="line">46 &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.配置解析库文件/var/named/xxx.zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;var&#x2F;named&#x2F;lv.dota.zone</span><br><span class="line">  1 $TTL 1D</span><br><span class="line">  2 @   IN SOA  master admin.lv.dota. (</span><br><span class="line">  3                     0   ; serial</span><br><span class="line">  4                     1D  ; refresh</span><br><span class="line">  5                     1H  ; retry</span><br><span class="line">  6                     1W  ; expire</span><br><span class="line">  7                     3H )    ; minimum</span><br><span class="line">  8     NS  master</span><br><span class="line">  9     NS  slave			#添加的从服务器</span><br><span class="line"> 10 master  A   10.0.0.7 </span><br><span class="line"> 11 slave   A   10.0.0.153   #添加的从服务器解析                                     </span><br><span class="line"> 12 www     A   10.0.0.3</span><br><span class="line">#添加上两条：</span><br><span class="line">		NS slave</span><br><span class="line">	slave	A	10.0.0.153</span><br></pre></td></tr></table></figure>

<p>4.重新加载配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#rndc reload</span><br><span class="line">server reload successful</span><br></pre></td></tr></table></figure>

<p>从服务器的配置步骤：</p>
<p>1.开启允许其他主机访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;etc&#x2F;named.conf</span><br><span class="line">&#x2F;&#x2F;  listen-on port 53 &#123; 127.0.0.1; &#125;;</span><br><span class="line">&#x2F;&#x2F;  allow-query     &#123; localhost; &#125;;</span><br><span class="line"> allow-transfer &#123; none; &#125;;  #这一步是设置不允许其他主机从这台从服务器上同步解析库文件</span><br></pre></td></tr></table></figure>

<p>2.配置/etc/named.rfc1912.zones</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加一个zone</span><br><span class="line"> 42 zone &quot;lv.dota&quot; IN &#123;</span><br><span class="line"> 43     type slave;</span><br><span class="line"> 44     masters &#123; 10.0.0.7; &#125;;</span><br><span class="line"> 45     file &quot;slaves&#x2F;lv.dota.slave&quot;;</span><br><span class="line"> 46 &#125;;</span><br><span class="line"> 这里的zone名称跟主服务器一样，下面的type改成slave，添加一行设置主服务器地址设置，解析库文件位置是用于放置一会从主服务器同步过来的解析库文件的</span><br></pre></td></tr></table></figure>

<p>3.启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#systemctl start named</span><br></pre></td></tr></table></figure>

<p>4.去客户端验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$dig www.lv.dota @10.0.0.153</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6 &lt;&lt;&gt;&gt; www.lv.dota @10.0.0.153</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 56037</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 2</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.lv.dota.			IN	A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.lv.dota.		86400	IN	A	10.0.0.3</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">lv.dota.		86400	IN	NS	master.lv.dota.</span><br><span class="line">lv.dota.		86400	IN	NS	slave.lv.dota.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">master.lv.dota.		86400	IN	A	10.0.0.7</span><br><span class="line">slave.lv.dota.		86400	IN	A	10.0.0.153</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 10.0.0.153#53(10.0.0.153)</span><br><span class="line">;; WHEN: Sun Sep 13 10:15:28 2020</span><br><span class="line">;; MSG SIZE  rcvd: 118</span><br></pre></td></tr></table></figure>

<p>成功</p>
<h3 id="6-实现子域"><a href="#6-实现子域" class="headerlink" title="6.实现子域"></a>6.实现子域</h3><p>子域父域是两台masterDNS主机，父域里面写上子域的域名和地址，子域里面只写自己的区域解析，不用写父域地址。DNS有这个规律，上级知道下级和根域，下级知道自己的区域解析和根域。</p>
<p>父域设置：父DNS主机设置</p>
<p>1.关闭加密验证，允许服务器进行区域传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow-transfer &#123; 子域服务器IP;&#125;;</span><br><span class="line">dnssec-enable no;</span><br><span class="line">dnssec-validation no;</span><br></pre></td></tr></table></figure>

<p>2.配置zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;etc&#x2F;named.rfc1912.zones</span><br><span class="line"> 43 zone &quot;lv.dota&quot; IN &#123;</span><br><span class="line"> 44     type master;</span><br><span class="line"> 45     file &quot;lv.dota.zone&quot;;</span><br><span class="line"> 46 &#125;;</span><br></pre></td></tr></table></figure>

<p>3.在/var/named/xxx.zone文件中加入子域的一些项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;var&#x2F;named&#x2F;lv.dota.zone</span><br><span class="line">  1 $TTL 1D</span><br><span class="line">  2 @   IN SOA  master admin.lv.dota. (</span><br><span class="line">  3                     1   ; serial</span><br><span class="line">  4                     1D  ; refresh</span><br><span class="line">  5                     1H  ; retry</span><br><span class="line">  6                     1W  ; expire</span><br><span class="line">  7                     3H )    ; minimum</span><br><span class="line">  8     NS  master</span><br><span class="line">  9 shanghai    NS  shanghains   #添加子域的NS</span><br><span class="line"> 10 master  A   10.0.0.7</span><br><span class="line"> 11 shanghains    A   10.0.0.153   #子域的IP地址</span><br><span class="line"> 12 fff     A   10.0.0.3</span><br><span class="line"> 13 www     CNAME   fff</span><br></pre></td></tr></table></figure>

<p>4.重新加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rndc reload</span><br></pre></td></tr></table></figure>

<p>子域设置：子DNS主机设置</p>
<p>1.禁止区域传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;named.conf</span><br><span class="line">allow-transfer &#123; none;&#125;;</span><br></pre></td></tr></table></figure>

<p>2.配置zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;etc&#x2F;named.rfc1912.zones</span><br><span class="line">添加下面的内容，注意zone名称</span><br><span class="line"> 42 zone &quot;shanghai.lv.dota&quot; IN &#123;</span><br><span class="line"> 43     type master;</span><br><span class="line"> 44     file &quot;shanghai.lv.dota.zone&quot;;</span><br><span class="line"> 45 &#125;;</span><br></pre></td></tr></table></figure>

<p>3.创建zone文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost named]#vim &#x2F;var&#x2F;named&#x2F;shanghai.lv.dota.zone </span><br><span class="line">子域中不需要写父域信息</span><br><span class="line">  1 $TTL 1D</span><br><span class="line">  2 @   IN SOA  master admin.lv.dota. (</span><br><span class="line">  3                     0   ; serial</span><br><span class="line">  4                     1D  ; refresh</span><br><span class="line">  5                     1H  ; retry</span><br><span class="line">  6                     1W  ; expire</span><br><span class="line">  7                     3H )    ; minimum</span><br><span class="line">  8     NS  master</span><br><span class="line">  9 master  A   10.0.0.153</span><br><span class="line"> 10 fff     A   10.0.0.4</span><br><span class="line"> 11 www     CNAME   fff  </span><br></pre></td></tr></table></figure>

<p>真正起作用的是zone名称</p>
<p>4.测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host www.lv.dota</span><br><span class="line">host www.shanghai.lv.dota</span><br></pre></td></tr></table></figure>

<h3 id="7-实现转发"><a href="#7-实现转发" class="headerlink" title="7.实现转发"></a>7.实现转发</h3><p>转发：利用DNS转发，可以将用户的DNS请求，转发至指定的DNS服务，而非默认的根DNS服务器，并将指定服务器查询的返回结果进行缓存，提高效率</p>
<p>转发需要关闭dnssec功能</p>
<p>转发的方式：</p>
<ul>
<li>全局转发</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">		forward first|only;</span><br><span class="line">		forwarders &#123;ip;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>特定区域转发，仅转发对特定区域的请求，比全局转发优先级高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;zone_name&quot; IN &#123;</span><br><span class="line">	type forward;</span><br><span class="line">	forward first|only;</span><br><span class="line">	forwarders &#123;ip;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>first:先转发至指定的DNS服务器，如果无法解析查询请求，则本服务器再去根服务器查询</p>
<p>only：先转发至指定DNS服务器，如果无法解析查询请求，则本服务器将不再去根服务器查询</p>
<p>主服务器配置：</p>
<p>主服务器正常配置一个DNS，其他不用配置</p>
<p>转发（缓存服务器）配置：</p>
<p>1.配置/etc/named.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;listen-on port 53 &#123;127.0.0.1;&#125;;</span><br><span class="line">&#x2F;&#x2F;allow-query &#123;localhost&#125;</span><br><span class="line">添加下面两行</span><br><span class="line">forward first;</span><br><span class="line">forwarders &#123; 10.0.0.7; &#125;; #主服务器的地址</span><br><span class="line">关闭dnssec功能</span><br><span class="line">dnssec-enable no;</span><br><span class="line">dnssec-validation no;</span><br></pre></td></tr></table></figure>

<p>2.重新加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rndc reload</span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<h3 id="8-实现智能DNS"><a href="#8-实现智能DNS" class="headerlink" title="8.实现智能DNS"></a>8.实现智能DNS</h3><p>1.GSLB概念：Global Server Load Balance全局负载均衡</p>
<p>GSLB是对服务器和链路进行综合判断来决定由哪个地点的服务器来提供服务，实现异地服务器群服务质量的保证</p>
<p>GSLB主要的目的是在整个网络范围内将用户的请求定向到最近的节点，GSBL分为基于DNS实现、基于重定向实现、基于路由协议实现，其中最通用的是基于DNS解析方式。</p>
<p>举个例子，从郑州dig测试<a target="_blank" rel="noopener" href="http://www.jd.com和从北京dig测试www.jd.com,你会发现解析到的ip地址不一样,分别是郑州的ip和北京的ip./">www.jd.com和从北京dig测试www.jd.com，你会发现解析到的IP地址不一样，分别是郑州的IP和北京的IP。</a></p>
<p>2.CDN 内容分发网络 Content Delivery Network</p>
<p>公用DNS比如阿里的233.5.5.5，他们都有自己的技术，可以自动判断你的IP是哪个地区的，然后让你的IP地址请求域名解析的时候指向他们当地的DNS服务器，这样根据当地DNS服务器的位置就可以让GSLB知道你的地区，然后把当前地区的内容服务器地址发给你的DNS，你就能享受CDN带来的快速访问了。</p>
<p><img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200914212757775.png" alt="image-20200914212757775"></p>
<p>工作原理：</p>
<p>1.用户访问<a target="_blank" rel="noopener" href="http://www.jd.com,发送域名解析请求到dns服务器,比如阿里的223.5.5.5,这时候有个情况,阿里或者国内其他的公用dns服务器有些技术,比如bgp/">www.jd.com，发送域名解析请求到DNS服务器，比如阿里的223.5.5.5，这时候有个情况，阿里或者国内其他的公用DNS服务器有些技术，比如bgp</a> anycast（多个服务器用了一个IP地址），可以让你访问距离你最近的DNS服务器，所以本来223.5.5.5服务器在浙江杭州，但是你访问的223.5.5.5就在郑州。</p>
<p>2.DNS服务器收到你的解析请求后，就去检查自己的解析库和缓存中有没有<a target="_blank" rel="noopener" href="http://www.jd.com的地址,如果有,就发给你;如果没有,就会从根域开始逐级查找,直到找到www.jd.com的解析地址.因为cdn技术,所以dns服务器找到的地址不是真的ip地址,而是一个cname,别名,指向了京东的gslb,全局负载均衡服务器,负载均衡服务器会根据dns的ip地址判断dns所在的地区,从而把距离该地区最近的内容分发服务器ip解析给dns/">www.jd.com的地址，如果有，就发给你；如果没有，就会从根域开始逐级查找，直到找到www.jd.com的解析地址。因为CDN技术，所以DNS服务器找到的地址不是真的IP地址，而是一个CNAME，别名，指向了京东的GSLB，全局负载均衡服务器，负载均衡服务器会根据DNS的IP地址判断DNS所在的地区，从而把距离该地区最近的内容分发服务器IP解析给DNS</a></p>
<p>3.DNS收到解析地址后把IP地址返还给用户</p>
<p>4.用户去访问这个IP地址，获取信息</p>
<p>5.如果这个IP地址对应的内容分发服务器上有用户需要的全部信息，那么就把全部信息发送给用户；如果内容分发服务器上没有足够的信息，那么它就会找临近的分发服务器查询是否有这个信息，如果有就从其他服务器上拿过来，如果没有，它就会找源服务器要，然后再发送给用户</p>
<p>6.上面的流程就是CDN的实现，通过DNS服务器，用户得以访问距离自己最近的内容分发服务器，可以用得到最快的信息加载速度，并且CDN还大大缓解了源服务器的访问带宽压力，缓解了运营商的带宽压力。</p>
<p>通过Linux实现智能DNS：</p>
<p>1.创建acl</p>
<p>acl的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">11 acl beijingnet &#123;</span><br><span class="line">12     10.0.0.5;</span><br><span class="line">13 &#125;;</span><br><span class="line">14 acl shanghainet &#123;</span><br><span class="line">15     10.0.0.151;</span><br><span class="line">16 &#125;;</span><br><span class="line">17 acl shenzhennet &#123;</span><br><span class="line">18     any;</span><br><span class="line">19 &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.创建view</p>
<p>view的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">63 view beijingview &#123;</span><br><span class="line">64     match-clients &#123; beijingnet ; &#125;;</span><br><span class="line">65     include &quot;&#x2F;etc&#x2F;named.rfc1912.zones.beijing&quot;;</span><br><span class="line">66 &#125;;</span><br><span class="line">67 view shanghaiview &#123;</span><br><span class="line">68     match-clients &#123; shanghainet ; &#125;;</span><br><span class="line">69     include &quot;&#x2F;etc&#x2F;named.rfc1912.zones.shanghai&quot;;</span><br><span class="line">70 &#125;;</span><br><span class="line">71 view shenzhenview &#123;</span><br><span class="line">72     match-clients &#123; shenzhennet ; &#125;;</span><br><span class="line">73     include &quot;&#x2F;etc&#x2F;named.rfc1912.zones.shenzhen&quot;;</span><br><span class="line">74 &#125;;</span><br><span class="line">75 include &quot;&#x2F;etc&#x2F;named.root.key&quot;;</span><br></pre></td></tr></table></figure>

<p>3.创建view规定的/etc/named.rfc1912.zones.xxx文件，里面写上zone</p>
<p>文件格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">第一个view的zone</span><br><span class="line"> 43 zone &quot;lv.dota&quot; IN &#123;</span><br><span class="line"> 44     type master;</span><br><span class="line"> 45     file &quot;beijing.lv.dota.zone&quot;;</span><br><span class="line"> 46 &#125;;</span><br><span class="line"> 47 zone &quot;.&quot; IN &#123;</span><br><span class="line"> 48     type hint;</span><br><span class="line"> 49     file &quot;named.ca&quot;;</span><br><span class="line"> 50 &#125;;   </span><br><span class="line">第二个view的zone</span><br><span class="line"> 43 zone &quot;lv.dota&quot; IN &#123;</span><br><span class="line"> 44     type master;</span><br><span class="line"> 45     file &quot;shanghai.lv.dota.zone&quot;;</span><br><span class="line"> 46 &#125;;</span><br><span class="line"> 47 zone &quot;.&quot; IN &#123;</span><br><span class="line"> 48     type hint;</span><br><span class="line"> 49     file &quot;named.ca&quot;;</span><br><span class="line"> 50 &#125;;</span><br><span class="line">第三个view的zone</span><br><span class="line"> 43 zone &quot;lv.dota&quot; IN &#123;</span><br><span class="line"> 44     type master;</span><br><span class="line"> 45     file &quot;shenzhen.lv.dota.zone&quot;;</span><br><span class="line"> 46 &#125;;</span><br><span class="line"> 47 zone &quot;.&quot; IN &#123;</span><br><span class="line"> 48     type hint;</span><br><span class="line"> 49     file &quot;named.ca&quot;;</span><br><span class="line"> 50 &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.创建zone文件规定的.zone解析库文件，放在/var/named/xxxx.zone</p>
<p>格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> 第一个.zone文件</span><br><span class="line">  1 $TTL 1D</span><br><span class="line">  2 @   IN  SOA     master  admin.lv.dota. (</span><br><span class="line">  3                       1  ;serial</span><br><span class="line">  4                       1D  ;refresh</span><br><span class="line">  5                       1H ;retry</span><br><span class="line">  6                       1W   ;expire</span><br><span class="line">  7                      3H  ) ; minimal</span><br><span class="line">  8         NS      master</span><br><span class="line">  9 master  A       10.0.0.7</span><br><span class="line"> 10 www     A       10.0.0.7 #不同的地方就是这里，www.lv.dota解析到了不同的IP地址</span><br><span class="line">第二个.zone文件</span><br><span class="line">  1 $TTL 1D</span><br><span class="line">  2 @   IN  SOA     master  admin.lv.dota. (</span><br><span class="line">  3                       1  ;serial</span><br><span class="line">  4                       1D  ;refresh</span><br><span class="line">  5                       1H ;retry</span><br><span class="line">  6                       1W   ;expire</span><br><span class="line">  7                      3H  ) ; minimal</span><br><span class="line">  8         NS      master</span><br><span class="line">  9 master  A       10.0.0.7</span><br><span class="line"> 10 www     A       10.0.0.3 #这里就是不同点</span><br><span class="line">第三个.zone文件</span><br><span class="line">  1 $TTL 1D</span><br><span class="line">  2 @   IN  SOA     master  admin.lv.dota. (</span><br><span class="line">  3                       1  ;serial</span><br><span class="line">  4                       1D  ;refresh</span><br><span class="line">  5                       1H ;retry</span><br><span class="line">  6                       1W   ;expire</span><br><span class="line">  7                      3H  ) ; minimal</span><br><span class="line">  8         NS      master</span><br><span class="line">  9 master  A       10.0.0.7</span><br><span class="line"> 10 www     A       10.0.0.4 #这里是不同点</span><br></pre></td></tr></table></figure>

<p>OK，分别从三个acl规定的区域中的IP解析<a target="_blank" rel="noopener" href="http://www.lv.dota,就会得到三个不同的ip地址了!/">www.lv.dota，就会得到三个不同的IP地址了！</a></p>
<h3 id="9-综合实验：DNS的使用"><a href="#9-综合实验：DNS的使用" class="headerlink" title="9.综合实验：DNS的使用"></a>9.综合实验：DNS的使用</h3><p>1.关于缓存（转发）服务器：</p>
<p>A是本地DNS服务器</p>
<p>B是转发服务器</p>
<p>A上面只配置开启转发，关闭安全加密选项</p>
<p>B上面配置一些域解析库，关闭安全加密选项</p>
<p>forward firest 是本地DNS首先会把客户端的解析请求转发到转发DNS服务器上，如果转发DNS服务器无法解析，那么本地DNS服务器会自己去找根服务器去迭代查询，直到有一个成功或失败的结果。</p>
<p>forward only 是本地DNS直接把客户端的解析请求转发到转发DNS服务器上，如果转发DNS服务器无法解析，那么本地DNS服务器也不管了，给客户端返回一个失败。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/18/DNS%E6%9C%8D%E5%8A%A1%E5%92%8CBIND%E8%BD%AF%E4%BB%B6/" data-id="ckhnf9heo000740utdf0m50c0" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo的环境搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/09/hexo%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2020-11-09T00:48:10.000Z" itemprop="datePublished">2020-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/09/hexo%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">hexo的环境搭建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1.安装nodejs：</p>
<p>​    下载慢的解决方法：在这里下载，速度很快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nodejs.cn&#x2F;download&#x2F;</span><br></pre></td></tr></table></figure>

<p>2.修改npm的源为淘宝源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure>

<p>3.安装git，去淘宝镜像网找一个git的Windows客户端，然后下载安装配置</p>
<p>4.找一个目录，进入里面，然后右键，打开git bash</p>
<p>5.使用npm安装hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;jinmie0193&#x2F;article&#x2F;details&#x2F;81589661</span><br></pre></td></tr></table></figure>

<p>5.按照下面的方法，使用gitee而不是git去安装hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;weilining.cf&#x2F;5.html</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm install hexo-cli@latest -g</span><br><span class="line">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class="line">cd blog</span><br><span class="line">## git submodule init</span><br><span class="line">## git submodule update</span><br><span class="line">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-theme-landscape.git themes&#x2F;landscape</span><br><span class="line">npm i</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>6.开始准备部署到github上</p>
<p>7.记得如果推送上去的hexo分支是master的话，在项目–&gt;settings里面把主页设置成master的，否则看不到页面</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/09/hexo%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" data-id="ckh9u4pb80000csute7080lbi" data-title="hexo的环境搭建" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/08/hello-world/" class="article-date">
  <time class="dt-published" datetime="2020-11-08T13:28:53.334Z" itemprop="datePublished">2020-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/08/hello-world/" data-id="ckh97b0y00000swut1zdkbox6" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/18/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/18/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91MYSQL8.0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/18/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-rsyslog/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/18/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85MySQL%E8%84%9A%E6%9C%AC/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2020 huihui<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>